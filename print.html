<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flatbuffers</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="FlatBuffers.html"><strong aria-hidden="true">1.</strong> Flatbuffers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Internals.html"><strong aria-hidden="true">1.1.</strong> Flatbuffers internals</a></li></ol></li><li class="chapter-item expanded "><a href="Schemas.html"><strong aria-hidden="true">2.</strong> Writing a schema</a></li><li class="chapter-item expanded "><a href="Compiler.html"><strong aria-hidden="true">3.</strong> flatc CLI</a></li><li class="chapter-item expanded "><a href="FlexBuffers.html"><strong aria-hidden="true">4.</strong> Flexbuffers</a></li><li class="chapter-item expanded "><a href="Benchmarks.html"><strong aria-hidden="true">5.</strong> Benchmarks</a></li><li class="chapter-item expanded "><a href="Support.html"><strong aria-hidden="true">6.</strong> Language Support</a></li><li class="chapter-item expanded "><a href="Tutorial.html"><strong aria-hidden="true">7.</strong> Tutorial</a></li><li class="chapter-item expanded "><a href="WhitePaper.html"><strong aria-hidden="true">8.</strong> White Paper</a></li><li class="chapter-item expanded affix "><li class="part-title">Guides</li><li class="chapter-item expanded "><a href="CppUsage.html"><strong aria-hidden="true">9.</strong> C++ Usage</a></li><li class="chapter-item expanded "><a href="CsharpUsage.html"><strong aria-hidden="true">10.</strong> C# Usage</a></li><li class="chapter-item expanded "><a href="CUsage.html"><strong aria-hidden="true">11.</strong> C Usage</a></li><li class="chapter-item expanded "><a href="DartUsage.html"><strong aria-hidden="true">12.</strong> Dart Usage</a></li><li class="chapter-item expanded "><a href="GoUsage.html"><strong aria-hidden="true">13.</strong> Go Usage</a></li><li class="chapter-item expanded "><a href="JavaScriptUsage.html"><strong aria-hidden="true">14.</strong> JavaScript Usage</a></li><li class="chapter-item expanded "><a href="JavaUsage.html"><strong aria-hidden="true">15.</strong> Java Usage</a></li><li class="chapter-item expanded "><a href="KotlinUsage.html"><strong aria-hidden="true">16.</strong> Kotlin Usage</a></li><li class="chapter-item expanded "><a href="LobsterUsage.html"><strong aria-hidden="true">17.</strong> Lobster Usage</a></li><li class="chapter-item expanded "><a href="LuaUsage.html"><strong aria-hidden="true">18.</strong> Lua Usage</a></li><li class="chapter-item expanded "><a href="PHPUsage.html"><strong aria-hidden="true">19.</strong> PHP Usage</a></li><li class="chapter-item expanded "><a href="PythonUsage.html"><strong aria-hidden="true">20.</strong> Python Usage</a></li><li class="chapter-item expanded "><a href="RustUsage.html"><strong aria-hidden="true">21.</strong> Rust Usage</a></li><li class="chapter-item expanded "><a href="SwiftUsage.html"><strong aria-hidden="true">22.</strong> Swift Usage</a></li><li class="chapter-item expanded "><a href="TypeScriptUsage.html"><strong aria-hidden="true">23.</strong> TypeScript Usage</a></li><li class="chapter-item expanded affix "><li class="part-title">Contributing</li><li class="chapter-item expanded "><a href="Building.html"><strong aria-hidden="true">24.</strong> Building</a></li><li class="chapter-item expanded "><a href="Grammar.html"><strong aria-hidden="true">25.</strong> Schema Grammar</a></li><li class="chapter-item expanded "><a href="IntermediateRepresentation.html"><strong aria-hidden="true">26.</strong> Intermediate Representation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flatbuffers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="flatbuffers"><a class="header" href="#flatbuffers">FlatBuffers</a></h1>
<p>FlatBuffers is an efficient cross platform
serialization library for C++, C#, C, Go, Java, Kotlin, JavaScript, Lobster, Lua, TypeScript, PHP, Python, Rust and Swift.
It was originally created at Google for game development and other
performance-critical applications.</p>
<p>It is available as Open Source on <a href="http://github.com/google/flatbuffers">GitHub</a>
under the Apache license, v2 (see LICENSE.txt).</p>
<h2 id="why-use-flatbuffers"><a class="header" href="#why-use-flatbuffers">Why use FlatBuffers?</a></h2>
<ul>
<li>
<p><strong>Access to serialized data without parsing/unpacking</strong> - What sets
FlatBuffers apart is that it represents hierarchical data in a flat
binary buffer in such a way that it can still be accessed directly
without parsing/unpacking, while also still supporting data
structure evolution (forwards/backwards compatibility).</p>
</li>
<li>
<p><strong>Memory efficiency and speed</strong> - The only memory needed to access
your data is that of the buffer. It requires 0 additional allocations
(in C++, other languages may vary). FlatBuffers is also very
suitable for use with mmap (or streaming), requiring only part of the
buffer to be in memory. Access is close to the speed of raw
struct access with only one extra indirection (a kind of vtable) to
allow for format evolution and optional fields. It is aimed at
projects where spending time and space (many memory allocations) to
be able to access or construct serialized data is undesirable, such
as in games or any other performance sensitive applications. See the
[benchmarks](@ref flatbuffers_benchmarks) for details.</p>
</li>
<li>
<p><strong>Flexible</strong> - Optional fields means not only do you get great
forwards and backwards compatibility (increasingly important for
long-lived games: don't have to update all data with each new
version!). It also means you have a lot of choice in what data you
write and what data you don't, and how you design data structures.</p>
</li>
<li>
<p><strong>Tiny code footprint</strong> - Small amounts of generated code, and just
a single small header as the minimum dependency, which is very easy
to integrate. Again, see the benchmark section for details.</p>
</li>
<li>
<p><strong>Strongly typed</strong> - Errors happen at compile time rather than
manually having to write repetitive and error prone run-time checks.
Useful code can be generated for you.</p>
</li>
<li>
<p><strong>Convenient to use</strong> - Generated C++ code allows for terse access
&amp; construction code. Then there's optional functionality for parsing
schemas and JSON-like text representations at runtime efficiently if
needed (faster and more memory efficient than other JSON
parsers).</p>
<p>Java, Kotlin and Go code supports object-reuse. C# has efficient struct based
accessors.</p>
</li>
<li>
<p><strong>Cross platform code with no dependencies</strong> - C++ code will work
with any recent gcc/clang and VS2010. Comes with build files for the tests &amp;
samples (Android .mk files, and cmake for all other platforms).</p>
</li>
</ul>
<h3 id="why-not-use-protocol-buffers-or--"><a class="header" href="#why-not-use-protocol-buffers-or--">Why not use Protocol Buffers, or .. ?</a></h3>
<p>Protocol Buffers is indeed relatively similar to FlatBuffers,
with the primary difference being that FlatBuffers does not need a parsing/
unpacking step to a secondary representation before you can
access data, often coupled with per-object memory allocation. The code
is an order of magnitude bigger, too. Protocol Buffers has no optional
text import/export.</p>
<h3 id="but-all-the-cool-kids-use-json"><a class="header" href="#but-all-the-cool-kids-use-json">But all the cool kids use JSON!</a></h3>
<p>JSON is very readable (which is why we use it as our optional text
format) and very convenient when used together with dynamically typed
languages (such as JavaScript). When serializing data from statically
typed languages, however, JSON not only has the obvious drawback of runtime
inefficiency, but also forces you to write <em>more</em> code to access data
(counterintuitively) due to its dynamic-typing serialization system.
In this context, it is only a better choice for systems that have very
little to no information ahead of time about what data needs to be stored.</p>
<p>If you do need to store data that doesn't fit a schema, FlatBuffers also
offers a schema-less (self-describing) version!</p>
<p>Read more about the &quot;why&quot; of FlatBuffers in the
<a href="./WhitePaper.html">white paper</a>.</p>
<h3 id="who-uses-flatbuffers"><a class="header" href="#who-uses-flatbuffers">Who uses FlatBuffers?</a></h3>
<ul>
<li><a href="http://www.cocos2d-x.org/">Cocos2d-x</a>, the #1 open source mobile game
engine, uses it to serialize all their
<a href="http://www.cocos2d-x.org/reference/native-cpp/V3.5/d7/d2d/namespaceflatbuffers.html">game data</a>.</li>
<li><a href="http://facebook.com/">Facebook</a> uses it for client-server communication in
their Android app. They have a nice
<a href="https://code.facebook.com/posts/872547912839369/improving-facebook-s-performance-on-android-with-flatbuffers/">article</a>
explaining how it speeds up loading their posts.</li>
<li><a href="https://developers.google.com/games/#Tools">Fun Propulsion Labs</a>
at Google uses it extensively in all their libraries and games.</li>
</ul>
<h2 id="usage-in-brief"><a class="header" href="#usage-in-brief">Usage in brief</a></h2>
<p>This section is a quick rundown of how to use this system. Subsequent
sections provide a more in-depth usage guide.</p>
<ul>
<li>
<p>Write a schema file that allows you to define the data structures
you may want to serialize. Fields can have a scalar type
(ints/floats of all sizes), or they can be a: string; array of any type;
reference to yet another object; or, a set of possible objects (unions).
Fields are optional and have defaults, so they don't need to be
present for every object instance.</p>
</li>
<li>
<p>Use <code>flatc</code> (the FlatBuffer compiler) to generate a C++ header (or
Java/Kotlin/C#/Go/Python.. classes) with helper classes to access and construct
serialized data. This header (say <code>mydata_generated.h</code>) only depends on
<code>flatbuffers.h</code>, which defines the core functionality.</p>
</li>
<li>
<p>Use the <code>FlatBufferBuilder</code> class to construct a flat binary buffer.
The generated functions allow you to add objects to this
buffer recursively, often as simply as making a single function call.</p>
</li>
<li>
<p>Store or send your buffer somewhere!</p>
</li>
<li>
<p>When reading it back, you can obtain the pointer to the root object
from the binary buffer, and from there traverse it conveniently
in-place with <code>object-&gt;field()</code>.</p>
</li>
</ul>
<h2 id="online-resources"><a class="header" href="#online-resources">Online resources</a></h2>
<ul>
<li><a href="http://github.com/google/flatbuffers">GitHub repository</a></li>
<li><a href="http://google.github.io/flatbuffers">Landing page</a></li>
<li><a href="https://groups.google.com/forum/#!forum/flatbuffers">FlatBuffers Google Group</a></li>
<li><a href="https://discord.gg/6qgKs3R">Discord</a> and <a href="https://gitter.im/lobster_programming_language/community">Gitter</a> chat.</li>
<li><a href="http://github.com/google/flatbuffers/issues">FlatBuffers Issues Tracker</a></li>
<li>Independent implementations &amp; tools:
<ul>
<li><a href="https://github.com/dvidelabs/flatcc">FlatCC</a> Alternative FlatBuffers
parser, code generator and runtime all in C.</li>
</ul>
</li>
<li>Videos:
<ul>
<li>Colt's <a href="https://www.youtube.com/watch?v=iQTxMkSJ1dQ">DevByte</a>.</li>
<li>GDC 2015 <a href="https://www.youtube.com/watch?v=olmL1fUnQAQ">Lightning Talk</a>.</li>
<li>FlatBuffers for <a href="https://www.youtube.com/watch?v=-BPVId_lA5w">Go</a>.</li>
<li>Evolution of FlatBuffers
<a href="https://www.youtube.com/watch?v=a0QE0xS8rKM">visualization</a>.</li>
</ul>
</li>
<li>Useful documentation created by others:
<ul>
<li><a href="https://rwinslow.com/tags/flatbuffers/">FlatBuffers in Go</a></li>
<li><a href="http://frogermcs.github.io/flatbuffers-in-android-introdution/">FlatBuffers in Android</a></li>
<li><a href="http://frogermcs.github.io/json-parsing-with-flatbuffers-in-android/">Parsing JSON to FlatBuffers in Java</a></li>
<li><a href="http://exiin.com/blog/flatbuffers-for-unity-sample-code/">FlatBuffers in Unity</a></li>
<li><a href="https://github.com/mzaks/FlexBuffers-CSharp">FlexBuffers C#</a> and
<a href="https://medium.com/@icex33/flexbuffers-for-unity3d-4d1ab5c53fbe?">article</a>
on its use.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flatbuffer-internals----flatbuffers_internals"><a class="header" href="#flatbuffer-internals----flatbuffers_internals">FlatBuffer Internals    {#flatbuffers_internals}</a></h1>
<p>This section is entirely optional for the use of FlatBuffers. In normal
usage, you should never need the information contained herein. If you're
interested however, it should give you more of an appreciation of why
FlatBuffers is both efficient and convenient.</p>
<h3 id="format-components"><a class="header" href="#format-components">Format components</a></h3>
<p>A FlatBuffer is a binary file and in-memory format consisting mostly of
scalars of various sizes, all aligned to their own size. Each scalar is
also always represented in little-endian format, as this corresponds to
all commonly used CPUs today. FlatBuffers will also work on big-endian
machines, but will be slightly slower because of additional
byte-swap intrinsics.</p>
<p>It is assumed that the following conditions are met, to ensure
cross-platform interoperability:</p>
<ul>
<li>The binary <code>IEEE-754</code> format is used for floating-point numbers.</li>
<li>The <code>two's complemented</code> representation is used for signed integers.</li>
<li>The endianness is the same for floating-point numbers as for integers.</li>
</ul>
<p>On purpose, the format leaves a lot of details about where exactly
things live in memory undefined, e.g. fields in a table can have any
order, and objects to some extent can be stored in many orders. This is
because the format doesn't need this information to be efficient, and it
leaves room for optimization and extension (for example, fields can be
packed in a way that is most compact). Instead, the format is defined in
terms of offsets and adjacency only. This may mean two different
implementations may produce different binaries given the same input
values, and this is perfectly valid.</p>
<h3 id="format-identification"><a class="header" href="#format-identification">Format identification</a></h3>
<p>The format also doesn't contain information for format identification
and versioning, which is also by design. FlatBuffers is a statically typed
system, meaning the user of a buffer needs to know what kind of buffer
it is. FlatBuffers can of course be wrapped inside other containers
where needed, or you can use its union feature to dynamically identify
multiple possible sub-objects stored. Additionally, it can be used
together with the schema parser if full reflective capabilities are
desired.</p>
<p>Versioning is something that is intrinsically part of the format (the
optionality / extensibility of fields), so the format itself does not
need a version number (it's a meta-format, in a sense). We're hoping
that this format can accommodate all data needed. If format breaking
changes are ever necessary, it would become a new kind of format rather
than just a variation.</p>
<h3 id="offsets"><a class="header" href="#offsets">Offsets</a></h3>
<p>The most important and generic offset type (see <code>flatbuffers.h</code>) is
<code>uoffset_t</code>, which is currently always a <code>uint32_t</code>, and is used to
refer to all tables/unions/strings/vectors (these are never stored
in-line). 32bit is
intentional, since we want to keep the format binary compatible between
32 and 64bit systems, and a 64bit offset would bloat the size for almost
all uses. A version of this format with 64bit (or 16bit) offsets is easy to set
when needed. Unsigned means they can only point in one direction, which
typically is forward (towards a higher memory location). Any backwards
offsets will be explicitly marked as such.</p>
<p>The format starts with an <code>uoffset_t</code> to the root table in the buffer.</p>
<p>We have two kinds of objects, structs and tables.</p>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>These are the simplest, and as mentioned, intended for simple data that
benefits from being extra efficient and doesn't need versioning /
extensibility. They are always stored inline in their parent (a struct,
table, or vector) for maximum compactness. Structs define a consistent
memory layout where all components are aligned to their size, and
structs aligned to their largest scalar member. This is done independent
of the alignment rules of the underlying compiler to guarantee a cross
platform compatible layout. This layout is then enforced in the generated
code.</p>
<h3 id="tables"><a class="header" href="#tables">Tables</a></h3>
<p>Unlike structs, these are not stored in inline in their parent, but are
referred to by offset.</p>
<p>They start with an <code>soffset_t</code> to a vtable. This is a signed version of
<code>uoffset_t</code>, since vtables may be stored anywhere relative to the object.
This offset is subtracted (not added) from the object start to arrive at
the vtable start. This offset is followed by all the
fields as aligned scalars (or offsets). Unlike structs, not all fields
need to be present. There is no set order and layout. A table may contain
field offsets that point to the same value if the user explicitly
serializes the same offset twice.</p>
<p>To be able to access fields regardless of these uncertainties, we go
through a vtable of offsets. Vtables are shared between any objects that
happen to have the same vtable values.</p>
<p>The elements of a vtable are all of type <code>voffset_t</code>, which is
a <code>uint16_t</code>. The first element is the size of the vtable in bytes,
including the size element. The second one is the size of the object, in bytes
(including the vtable offset). This size could be used for streaming, to know
how many bytes to read to be able to access all <em>inline</em> fields of the object.
The remaining elements are the N offsets, where N is the amount of fields
declared in the schema when the code that constructed this buffer was
compiled (thus, the size of the table is N + 2).</p>
<p>All accessor functions in the generated code for tables contain the
offset into this table as a constant. This offset is checked against the
first field (the number of elements), to protect against newer code
reading older data. If this offset is out of range, or the vtable entry
is 0, that means the field is not present in this object, and the
default value is return. Otherwise, the entry is used as offset to the
field to be read.</p>
<h3 id="unions"><a class="header" href="#unions">Unions</a></h3>
<p>Unions are encoded as the combination of two fields: an enum representing the
union choice and the offset to the actual element. FlatBuffers reserves the
enumeration constant <code>NONE</code> (encoded as 0) to mean that the union field is not
set.</p>
<h3 id="strings-and-vectors"><a class="header" href="#strings-and-vectors">Strings and Vectors</a></h3>
<p>Strings are simply a vector of bytes, and are always
null-terminated. Vectors are stored as contiguous aligned scalar
elements prefixed by a 32bit element count (not including any
null termination). Neither is stored inline in their parent, but are referred to
by offset. A vector may consist of more than one offset pointing to the same
value if the user explicitly serializes the same offset twice.</p>
<h3 id="construction"><a class="header" href="#construction">Construction</a></h3>
<p>The current implementation constructs these buffers backwards (starting
at the highest memory address of the buffer), since
that significantly reduces the amount of bookkeeping and simplifies the
construction API.</p>
<h3 id="code-example"><a class="header" href="#code-example">Code example</a></h3>
<p>Here's an example of the code that gets generated for the <code>samples/monster.fbs</code>.
What follows is the entire file, broken up by comments:</p>
<pre><code>// automatically generated, do not modify

#include &quot;flatbuffers/flatbuffers.h&quot;

namespace MyGame {
namespace Sample {
</code></pre>
<p>Nested namespace support.</p>
<pre><code>enum {
  Color_Red = 0,
  Color_Green = 1,
  Color_Blue = 2,
};

inline const char **EnumNamesColor() {
  static const char *names[] = { &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, nullptr };
  return names;
}

inline const char *EnumNameColor(int e) { return EnumNamesColor()[e]; }
</code></pre>
<p>Enums and convenient reverse lookup.</p>
<pre><code>enum {
  Any_NONE = 0,
  Any_Monster = 1,
};

inline const char **EnumNamesAny() {
  static const char *names[] = { &quot;NONE&quot;, &quot;Monster&quot;, nullptr };
  return names;
}

inline const char *EnumNameAny(int e) { return EnumNamesAny()[e]; }
</code></pre>
<p>Unions share a lot with enums.</p>
<pre><code>struct Vec3;
struct Monster;
</code></pre>
<p>Predeclare all data types since circular references between types are allowed
(circular references between object are not, though).</p>
<pre><code>FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3(float x, float y, float z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) {}

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);
</code></pre>
<p>These ugly macros do a couple of things: they turn off any padding the compiler
might normally do, since we add padding manually (though none in this example),
and they enforce alignment chosen by FlatBuffers. This ensures the layout of
this struct will look the same regardless of compiler and platform. Note that
the fields are private: this is because these store little endian scalars
regardless of platform (since this is part of the serialized data).
<code>EndianScalar</code> then converts back and forth, which is a no-op on all current
mobile and desktop platforms, and a single machine instruction on the few
remaining big endian platforms.</p>
<pre><code>struct Monster : private flatbuffers::Table {
  const Vec3 *pos() const { return GetStruct&lt;const Vec3 *&gt;(4); }
  int16_t mana() const { return GetField&lt;int16_t&gt;(6, 150); }
  int16_t hp() const { return GetField&lt;int16_t&gt;(8, 100); }
  const flatbuffers::String *name() const { return GetPointer&lt;const flatbuffers::String *&gt;(10); }
  const flatbuffers::Vector&lt;uint8_t&gt; *inventory() const { return GetPointer&lt;const flatbuffers::Vector&lt;uint8_t&gt; *&gt;(14); }
  int8_t color() const { return GetField&lt;int8_t&gt;(16, 2); }
};
</code></pre>
<p>Tables are a bit more complicated. A table accessor struct is used to point at
the serialized data for a table, which always starts with an offset to its
vtable. It derives from <code>Table</code>, which contains the <code>GetField</code> helper functions.
GetField takes a vtable offset, and a default value. It will look in the vtable
at that offset. If the offset is out of bounds (data from an older version) or
the vtable entry is 0, the field is not present and the default is returned.
Otherwise, it uses the entry as an offset into the table to locate the field.</p>
<pre><code>struct MonsterBuilder {
  flatbuffers::FlatBufferBuilder &amp;fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(const Vec3 *pos) { fbb_.AddStruct(4, pos); }
  void add_mana(int16_t mana) { fbb_.AddElement&lt;int16_t&gt;(6, mana, 150); }
  void add_hp(int16_t hp) { fbb_.AddElement&lt;int16_t&gt;(8, hp, 100); }
  void add_name(flatbuffers::Offset&lt;flatbuffers::String&gt; name) { fbb_.AddOffset(10, name); }
  void add_inventory(flatbuffers::Offset&lt;flatbuffers::Vector&lt;uint8_t&gt;&gt; inventory) { fbb_.AddOffset(14, inventory); }
  void add_color(int8_t color) { fbb_.AddElement&lt;int8_t&gt;(16, color, 2); }
  MonsterBuilder(flatbuffers::FlatBufferBuilder &amp;_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset&lt;Monster&gt; Finish() { return flatbuffers::Offset&lt;Monster&gt;(fbb_.EndTable(start_, 7)); }
};
</code></pre>
<p><code>MonsterBuilder</code> is the base helper struct to construct a table using a
<code>FlatBufferBuilder</code>. You can add the fields in any order, and the <code>Finish</code>
call will ensure the correct vtable gets generated.</p>
<pre><code>inline flatbuffers::Offset&lt;Monster&gt; CreateMonster(flatbuffers::FlatBufferBuilder &amp;_fbb,
                                                  const Vec3 *pos, int16_t mana,
                                                  int16_t hp,
                                                  flatbuffers::Offset&lt;flatbuffers::String&gt; name,
                                                  flatbuffers::Offset&lt;flatbuffers::Vector&lt;uint8_t&gt;&gt; inventory,
                                                  int8_t color) {
  MonsterBuilder builder_(_fbb);
  builder_.add_inventory(inventory);
  builder_.add_name(name);
  builder_.add_pos(pos);
  builder_.add_hp(hp);
  builder_.add_mana(mana);
  builder_.add_color(color);
  return builder_.Finish();
}
</code></pre>
<p><code>CreateMonster</code> is a convenience function that calls all functions in
<code>MonsterBuilder</code> above for you. Note that if you pass values which are
defaults as arguments, it will not actually construct that field, so
you can probably use this function instead of the builder class in
almost all cases.</p>
<pre><code>inline const Monster *GetMonster(const void *buf) { return flatbuffers::GetRoot&lt;Monster&gt;(buf); }
</code></pre>
<p>This function is only generated for the root table type, to be able to
start traversing a FlatBuffer from a raw buffer pointer.</p>
<pre><code>}; // namespace MyGame
}; // namespace Sample
</code></pre>
<h3 id="encoding-example"><a class="header" href="#encoding-example">Encoding example.</a></h3>
<p>Below is a sample encoding for the following JSON corresponding to the above
schema:</p>
<pre><code>{ pos: { x: 1, y: 2, z: 3 }, name: &quot;fred&quot;, hp: 50 }
</code></pre>
<p>Resulting in this binary buffer:</p>
<pre><code>// Start of the buffer:
uint32_t 20  // Offset to the root table.

// Start of the vtable. Not shared in this example, but could be:
uint16_t 16 // Size of table, starting from here.
uint16_t 22 // Size of object inline data.
uint16_t 4, 0, 20, 16, 0, 0  // Offsets to fields from start of (root) table, 0 for not present.

// Start of the root table:
int32_t 16     // Offset to vtable used (default negative direction)
float 1, 2, 3  // the Vec3 struct, inline.
uint32_t 8     // Offset to the name string.
int16_t 50     // hp field.
int16_t 0      // Padding for alignment.

// Start of name string:
uint32_t 4  // Length of string.
int8_t 'f', 'r', 'e', 'd', 0, 0, 0, 0  // Text + 0 termination + padding.
</code></pre>
<p>Note that this not the only possible encoding, since the writer has some
flexibility in which of the children of root object to write first (though in
this case there's only one string), and what order to write the fields in.
Different orders may also cause different alignments to happen.</p>
<h3 id="additional-reading"><a class="header" href="#additional-reading">Additional reading.</a></h3>
<p>The author of the C language implementation has made a similar
<a href="https://github.com/dvidelabs/flatcc/blob/master/doc/binary-format.md#flatbuffers-binary-format">document</a>
that may further help clarify the format.</p>
<h1 id="flexbuffers"><a class="header" href="#flexbuffers">FlexBuffers</a></h1>
<p>The [schema-less](@ref flexbuffers) version of FlatBuffers have their
own encoding, detailed here.</p>
<p>It shares many properties mentioned above, in that all data is accessed
over offsets, all scalars are aligned to their own size, and
all data is always stored in little endian format.</p>
<p>One difference is that FlexBuffers are built front to back, so children are
stored before parents, and the root of the data starts at the last byte.</p>
<p>Another difference is that scalar data is stored with a variable number of bits
(8/16/32/64). The current width is always determined by the <em>parent</em>, i.e. if
the scalar sits in a vector, the vector determines the bit width for all
elements at once. Selecting the minimum bit width for a particular vector is
something the encoder does automatically and thus is typically of no concern
to the user, though being aware of this feature (and not sticking a double in
the same vector as a bunch of byte sized elements) is helpful for efficiency.</p>
<p>Unlike FlatBuffers there is only one kind of offset, and that is an unsigned
integer indicating the number of bytes in a negative direction from the address
of itself (where the offset is stored).</p>
<h3 id="vectors"><a class="header" href="#vectors">Vectors</a></h3>
<p>The representation of the vector is at the core of how FlexBuffers works (since
maps are really just a combination of 2 vectors), so it is worth starting there.</p>
<p>As mentioned, a vector is governed by a single bit width (supplied by its
parent). This includes the size field. For example, a vector that stores the
integer values <code>1, 2, 3</code> is encoded as follows:</p>
<pre><code>uint8_t 3, 1, 2, 3, 4, 4, 4
</code></pre>
<p>The first <code>3</code> is the size field, and is placed before the vector (an offset
from the parent to this vector points to the first element, not the size
field, so the size field is effectively at index -1).
Since this is an untyped vector <code>SL_VECTOR</code>, it is followed by 3 type
bytes (one per element of the vector), which are always following the vector,
and are always a uint8_t even if the vector is made up of bigger scalars.</p>
<p>A vector may include more than one offset pointing to the same value if the
user explicitly serializes the same offset twice.</p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>A type byte is made up of 2 components (see flexbuffers.h for exact values):</p>
<ul>
<li>2 lower bits representing the bit-width of the child (8, 16, 32, 64).
This is only used if the child is accessed over an offset, such as a child
vector. It is ignored for inline types.</li>
<li>6 bits representing the actual type (see flexbuffers.h).</li>
</ul>
<p>Thus, in this example <code>4</code> means 8 bit child (value 0, unused, since the value is
in-line), type <code>SL_INT</code> (value 1).</p>
<h3 id="typed-vectors"><a class="header" href="#typed-vectors">Typed Vectors</a></h3>
<p>These are like the Vectors above, but omit the type bytes. The type is instead
determined by the vector type supplied by the parent. Typed vectors are only
available for a subset of types for which these savings can be significant,
namely inline signed/unsigned integers (<code>TYPE_VECTOR_INT</code> / <code>TYPE_VECTOR_UINT</code>),
floats (<code>TYPE_VECTOR_FLOAT</code>), and keys (<code>TYPE_VECTOR_KEY</code>, see below).</p>
<p>Additionally, for scalars, there are fixed length vectors of sizes 2 / 3 / 4
that don't store the size (<code>TYPE_VECTOR_INT2</code> etc.), for an additional savings
in space when storing common vector or color data.</p>
<h3 id="scalars"><a class="header" href="#scalars">Scalars</a></h3>
<p>FlexBuffers supports integers (<code>TYPE_INT</code> and <code>TYPE_UINT</code>) and floats
(<code>TYPE_FLOAT</code>), available in the bit-widths mentioned above. They can be stored
both inline and over an offset (<code>TYPE_INDIRECT_*</code>).</p>
<p>The offset version is useful to encode costly 64bit (or even 32bit) quantities
into vectors / maps of smaller sizes, and to share / repeat a value multiple
times.</p>
<h3 id="booleans-and-nulls"><a class="header" href="#booleans-and-nulls">Booleans and Nulls</a></h3>
<p>Booleans (<code>TYPE_BOOL</code>) and nulls (<code>TYPE_NULL</code>) are encoded as inlined unsigned integers.</p>
<h3 id="blobs-strings-and-keys"><a class="header" href="#blobs-strings-and-keys">Blobs, Strings and Keys.</a></h3>
<p>A blob (<code>TYPE_BLOB</code>) is encoded similar to a vector, with one difference: the
elements are always <code>uint8_t</code>. The parent bit width only determines the width of
the size field, allowing blobs to be large without the elements being large.</p>
<p>Strings (<code>TYPE_STRING</code>) are similar to blobs, except they have an additional 0
termination byte for convenience, and they MUST be UTF-8 encoded (since an
accessor in a language that does not support pointers to UTF-8 data may have to
convert them to a native string type).</p>
<p>A &quot;Key&quot; (<code>TYPE_KEY</code>) is similar to a string, but doesn't store the size
field. They're so named because they are used with maps, which don't care
for the size, and can thus be even more compact. Unlike strings, keys cannot
contain bytes of value 0 as part of their data (size can only be determined by
<code>strlen</code>), so while you can use them outside the context of maps if you so
desire, you're usually better off with strings.</p>
<h3 id="maps"><a class="header" href="#maps">Maps</a></h3>
<p>A map (<code>TYPE_MAP</code>) is like an (untyped) vector, but with 2 prefixes before the
size field:</p>
<table><thead><tr><th align="right">index</th><th align="left">field</th></tr></thead><tbody>
<tr><td align="right">-3</td><td align="left">An offset to the keys vector (may be shared between tables).</td></tr>
<tr><td align="right">-2</td><td align="left">Byte width of the keys vector.</td></tr>
<tr><td align="right">-1</td><td align="left">Size (from here on it is compatible with <code>TYPE_VECTOR</code>)</td></tr>
<tr><td align="right">0</td><td align="left">Elements.</td></tr>
<tr><td align="right">Size</td><td align="left">Types.</td></tr>
</tbody></table>
<p>Since a map is otherwise the same as a vector, it can be iterated like
a vector (which is probably faster than lookup by key).</p>
<p>The keys vector is a typed vector of keys. Both the keys and corresponding
values <em>have</em> to be stored in sorted order (as determined by <code>strcmp</code>), such
that lookups can be made using binary search.</p>
<p>The reason the key vector is a separate structure from the value vector is
such that it can be shared between multiple value vectors, and also to
allow it to be treated as its own individual vector in code.</p>
<p>An example map { foo: 13, bar: 14 } would be encoded as:</p>
<pre><code>0 : uint8_t 'b', 'a', 'r', 0
4 : uint8_t 'f', 'o', 'o', 0
8 : uint8_t 2      // key vector of size 2
// key vector offset points here
9 : uint8_t 9, 6   // offsets to bar_key and foo_key
11: uint8_t 2, 1   // offset to key vector, and its byte width
13: uint8_t 2      // value vector of size
// value vector offset points here
14: uint8_t 14, 13 // values
16: uint8_t 4, 4   // types
</code></pre>
<h3 id="the-root"><a class="header" href="#the-root">The root</a></h3>
<p>As mentioned, the root starts at the end of the buffer.
The last uint8_t is the width in bytes of the root (normally the parent
determines the width, but the root has no parent). The uint8_t before this is
the type of the root, and the bytes before that are the root value (of the
number of bytes specified by the last byte).</p>
<p>So for example, the integer value <code>13</code> as root would be:</p>
<pre><code>uint8_t 13, 4, 1    // Value, type, root byte width.
</code></pre>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-schema----flatbuffers_guide_writing_schema"><a class="header" href="#writing-a-schema----flatbuffers_guide_writing_schema">Writing a schema    {#flatbuffers_guide_writing_schema}</a></h1>
<p>The syntax of the schema language (aka IDL, <a href="https://en.wikipedia.org/wiki/Interface_description_language">Interface Definition Language</a>)
should look quite familiar to users of any of the C family of
languages, and also to users of other IDLs. Let's look at an example
first:</p>
<pre><code>// example IDL file

namespace MyGame;

attribute &quot;priority&quot;;

enum Color : byte { Red = 1, Green, Blue }

union Any { Monster, Weapon, Pickup }

struct Vec3 {
  x:float;
  y:float;
  z:float;
}

table Monster {
  pos:Vec3;
  mana:short = 150;
  hp:short = 100;
  name:string;
  friendly:bool = false (deprecated, priority: 1);
  inventory:[ubyte];
  color:Color = Blue;
  test:Any;
}

root_type Monster;
</code></pre>
<p>(<code>Weapon</code> &amp; <code>Pickup</code> not defined as part of this example).</p>
<h3 id="tables-1"><a class="header" href="#tables-1">Tables</a></h3>
<p>Tables are the main way of defining objects in FlatBuffers, and consist of a
name (here <code>Monster</code>) and a list of fields. Each field has a name, a type, and
optionally a default value. If the default value is not specified in the schema,
it will be <code>0</code> for scalar types, or <code>null</code> for other types. Some languages
support setting a scalar's default to <code>null</code>. This makes the scalar optional.</p>
<p>Fields do not have to appear in the wire representation, and you can choose
to omit fields when constructing an object. You have the flexibility to add
fields without fear of bloating your data. This design is also FlatBuffer's
mechanism for forward and backwards compatibility. Note that:</p>
<ul>
<li>
<p>You can add new fields in the schema ONLY at the end of a table
definition. Older data will still
read correctly, and give you the default value when read. Older code
will simply ignore the new field.
If you want to have flexibility to use any order for fields in your
schema, you can manually assign ids (much like Protocol Buffers),
see the <code>id</code> attribute below.</p>
</li>
<li>
<p>You cannot delete fields you don't use anymore from the schema,
but you can simply
stop writing them into your data for almost the same effect.
Additionally you can mark them as <code>deprecated</code> as in the example
above, which will prevent the generation of accessors in the
generated C++, as a way to enforce the field not being used any more.
(careful: this may break code!).</p>
</li>
<li>
<p>You may change field names and table names, if you're ok with your
code breaking until you've renamed them there too.</p>
</li>
</ul>
<p>See &quot;Schema evolution examples&quot; below for more on this
topic.</p>
<h3 id="structs-1"><a class="header" href="#structs-1">Structs</a></h3>
<p>Similar to a table, only now none of the fields are optional (so no defaults
either), and fields may not be added or be deprecated. Structs may only contain
scalars or other structs. Use this for
simple objects where you are very sure no changes will ever be made
(as quite clear in the example <code>Vec3</code>). Structs use less memory than
tables and are even faster to access (they are always stored in-line in their
parent object, and use no virtual table).</p>
<h3 id="types-1"><a class="header" href="#types-1">Types</a></h3>
<p>Built-in scalar types are</p>
<ul>
<li>
<p>8 bit: <code>byte</code> (<code>int8</code>), <code>ubyte</code> (<code>uint8</code>), <code>bool</code></p>
</li>
<li>
<p>16 bit: <code>short</code> (<code>int16</code>), <code>ushort</code> (<code>uint16</code>)</p>
</li>
<li>
<p>32 bit: <code>int</code> (<code>int32</code>), <code>uint</code> (<code>uint32</code>), <code>float</code> (<code>float32</code>)</p>
</li>
<li>
<p>64 bit: <code>long</code> (<code>int64</code>), <code>ulong</code> (<code>uint64</code>), <code>double</code> (<code>float64</code>)</p>
</li>
</ul>
<p>The type names in parentheses are alias names such that for example
<code>uint8</code> can be used in place of <code>ubyte</code>, and <code>int32</code> can be used in
place of <code>int</code> without affecting code generation.</p>
<p>Built-in non-scalar types:</p>
<ul>
<li>
<p>Vector of any other type (denoted with <code>[type]</code>). Nesting vectors
is not supported, instead you can wrap the inner vector in a table.</p>
</li>
<li>
<p><code>string</code>, which may only hold UTF-8 or 7-bit ASCII. For other text encodings
or general binary data use vectors (<code>[byte]</code> or <code>[ubyte]</code>) instead.</p>
</li>
<li>
<p>References to other tables or structs, enums or unions (see
below).</p>
</li>
</ul>
<p>You can't change types of fields once they're used, with the exception
of same-size data where a <code>reinterpret_cast</code> would give you a desirable result,
e.g. you could change a <code>uint</code> to an <code>int</code> if no values in current data use the
high bit yet.</p>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Arrays are a convenience short-hand for a fixed-length collection of elements.
Arrays can be used to replace the following schema:</p>
<pre><code>struct Vec3 {
    x:float;
    y:float;
    z:float;
}
</code></pre>
<p>with the following schema:</p>
<pre><code>struct Vec3 {
    v:[float:3];
}
</code></pre>
<p>Both representations are binary equivalent.</p>
<p>Arrays are currently only supported in a <code>struct</code>.</p>
<h3 id="default-optional-and-required-values"><a class="header" href="#default-optional-and-required-values">Default, Optional and Required Values</a></h3>
<p>There are three, mutually exclusive, reactions to the non-presence of a table's
field in the binary data:</p>
<ol>
<li>Default valued fields will return the default value (as defined in the schema).</li>
<li>Optional valued fields will return some form of <code>null</code> depending on the
local language. (In a sense, <code>null</code> is the default value).</li>
<li>Required fields will cause an error. Flatbuffer verifiers would
consider the whole buffer invalid. See the <code>required</code> tag below.</li>
</ol>
<p>When writing a schema, values are a sequence of digits. Values may be optionally
followed by a decimal point (<code>.</code>) and more digits, for float constants, or
optionally prefixed by a <code>-</code>. Floats may also be in scientific notation;
optionally ending with an <code>e</code> or <code>E</code>, followed by a <code>+</code> or <code>-</code> and more digits.
Values can also be the keyword <code>null</code>.</p>
<p>Only scalar values can have defaults, non-scalar (string/vector/table) fields
default to <code>null</code> when not present.</p>
<p>You generally do not want to change default values after they're initially
defined. Fields that have the default value are not actually stored in the
serialized data (see also Gotchas below). Values explicitly written by code
generated by the old schema old version, if they happen to be the default, will
be read as a different value by code generated with the new schema. This is
slightly less bad when converting an optional scalar into a default valued
scalar since non-presence would not be overloaded with a previous default value.
There are situations, however, where this may be desirable, especially if you
can ensure a simultaneous rebuild of all code.</p>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p>Define a sequence of named constants, each with a given value, or
increasing by one from the previous one. The default first value
is <code>0</code>. As you can see in the enum declaration, you specify the underlying
integral type of the enum with <code>:</code> (in this case <code>byte</code>), which then determines
the type of any fields declared with this enum type.</p>
<p>Only integer types are allowed, i.e. <code>byte</code>, <code>ubyte</code>, <code>short</code> <code>ushort</code>, <code>int</code>,
<code>uint</code>, <code>long</code> and <code>ulong</code>.</p>
<p>Typically, enum values should only ever be added, never removed (there is no
deprecation for enums). This requires code to handle forwards compatibility
itself, by handling unknown enum values.</p>
<h3 id="unions-1"><a class="header" href="#unions-1">Unions</a></h3>
<p>Unions share a lot of properties with enums, but instead of new names
for constants, you use names of tables. You can then declare
a union field, which can hold a reference to any of those types, and
additionally a field with the suffix <code>_type</code> is generated that holds
the corresponding enum value, allowing you to know which type to cast
to at runtime.</p>
<p>It's possible to give an alias name to a type union. This way a type can even be
used to mean different things depending on the name used:</p>
<pre><code>table PointPosition { x:uint; y:uint; }
table MarkerPosition {}
union Position {
  Start:MarkerPosition,
  Point:PointPosition,
  Finish:MarkerPosition
}
</code></pre>
<p>Unions contain a special <code>NONE</code> marker to denote that no value is stored so that
name cannot be used as an alias.</p>
<p>Unions are a good way to be able to send multiple message types as a FlatBuffer.
Note that because a union field is really two fields, it must always be
part of a table, it cannot be the root of a FlatBuffer by itself.</p>
<p>If you have a need to distinguish between different FlatBuffers in a more
open-ended way, for example for use as files, see the file identification
feature below.</p>
<p>There is an experimental support only in C++ for a vector of unions (and
types). In the example IDL file above, use [Any] to add a vector of Any to
Monster table. There is also experimental support for other types besides
tables in unions, in particular structs and strings. There's no direct support
for scalars in unions, but they can be wrapped in a struct at no space cost.</p>
<h3 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h3>
<p>These will generate the corresponding namespace in C++ for all helper
code, and packages in Java. You can use <code>.</code> to specify nested namespaces /
packages.</p>
<h3 id="includes"><a class="header" href="#includes">Includes</a></h3>
<p>You can include other schemas files in your current one, e.g.:</p>
<pre><code>include &quot;mydefinitions.fbs&quot;;
</code></pre>
<p>This makes it easier to refer to types defined elsewhere. <code>include</code>
automatically ensures each file is parsed just once, even when referred to
more than once.</p>
<p>When using the <code>flatc</code> compiler to generate code for schema definitions,
only definitions in the current file will be generated, not those from the
included files (those you still generate separately).</p>
<h3 id="root-type"><a class="header" href="#root-type">Root type</a></h3>
<p>This declares what you consider to be the root table of the serialized
data. This is particularly important for parsing JSON data, which doesn't
include object type information.</p>
<h3 id="file-identification-and-extension"><a class="header" href="#file-identification-and-extension">File identification and extension</a></h3>
<p>Typically, a FlatBuffer binary buffer is not self-describing, i.e. it
needs you to know its schema to parse it correctly. But if you
want to use a FlatBuffer as a file format, it would be convenient
to be able to have a &quot;magic number&quot; in there, like most file formats
have, to be able to do a sanity check to see if you're reading the
kind of file you're expecting.</p>
<p>Now, you can always prefix a FlatBuffer with your own file header,
but FlatBuffers has a built-in way to add an identifier to a
FlatBuffer that takes up minimal space, and keeps the buffer
compatible with buffers that don't have such an identifier.</p>
<p>You can specify in a schema, similar to <code>root_type</code>, that you intend
for this type of FlatBuffer to be used as a file format:</p>
<pre><code>file_identifier &quot;MYFI&quot;;
</code></pre>
<p>Identifiers must always be exactly 4 characters long. These 4 characters
will end up as bytes at offsets 4-7 (inclusive) in the buffer.</p>
<p>For any schema that has such an identifier, <code>flatc</code> will automatically
add the identifier to any binaries it generates (with <code>-b</code>),
and generated calls like <code>FinishMonsterBuffer</code> also add the identifier.
If you have specified an identifier and wish to generate a buffer
without one, you can always still do so by calling
<code>FlatBufferBuilder::Finish</code> explicitly.</p>
<p>After loading a buffer, you can use a call like
<code>MonsterBufferHasIdentifier</code> to check if the identifier is present.</p>
<p>Note that this is best for open-ended uses such as files. If you simply wanted
to send one of a set of possible messages over a network for example, you'd
be better off with a union.</p>
<p>Additionally, by default <code>flatc</code> will output binary files as <code>.bin</code>.
This declaration in the schema will change that to whatever you want:</p>
<pre><code>file_extension &quot;ext&quot;;
</code></pre>
<h3 id="rpc-interface-declarations"><a class="header" href="#rpc-interface-declarations">RPC interface declarations</a></h3>
<p>You can declare RPC calls in a schema, that define a set of functions
that take a FlatBuffer as an argument (the request) and return a FlatBuffer
as the response (both of which must be table types):</p>
<pre><code>rpc_service MonsterStorage {
  Store(Monster):StoreResponse;
  Retrieve(MonsterId):Monster;
}
</code></pre>
<p>What code this produces and how it is used depends on language and RPC system
used, there is preliminary support for GRPC through the <code>--grpc</code> code generator,
see <code>grpc/tests</code> for an example.</p>
<h3 id="comments--documentation"><a class="header" href="#comments--documentation">Comments &amp; documentation</a></h3>
<p>May be written as in most C-based languages. Additionally, a triple
comment (<code>///</code>) on a line by itself signals that a comment is documentation
for whatever is declared on the line after it
(table/struct/field/enum/union/element), and the comment is output
in the corresponding C++ code. Multiple such lines per item are allowed.</p>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Attributes may be attached to a declaration, behind a field/enum value,
or after the name of a table/struct/enum/union. These may either have
a value or not. Some attributes like <code>deprecated</code> are understood by
the compiler; user defined ones need to be declared with the attribute
declaration (like <code>priority</code> in the example above), and are
available to query if you parse the schema at runtime.
This is useful if you write your own code generators/editors etc., and
you wish to add additional information specific to your tool (such as a
help text).</p>
<p>Current understood attributes:</p>
<ul>
<li><code>id: n</code> (on a table field): manually set the field identifier to <code>n</code>.
If you use this attribute, you must use it on ALL fields of this table,
and the numbers must be a contiguous range from 0 onwards.
Additionally, since a union type effectively adds two fields, its
id must be that of the second field (the first field is the type
field and not explicitly declared in the schema).
For example, if the last field before the union field had id 6,
the union field should have id 8, and the unions type field will
implicitly be 7.
IDs allow the fields to be placed in any order in the schema.
When a new field is added to the schema it must use the next available ID.</li>
<li><code>deprecated</code> (on a field): do not generate accessors for this field
anymore, code should stop using this data. Old data may still contain this
field, but it won't be accessible anymore by newer code. Note that if you
deprecate a field that was previous required, old code may fail to validate
new data (when using the optional verifier).</li>
<li><code>required</code> (on a non-scalar table field): this field must always be set.
By default, fields do not need to be present in the binary. This is
desirable, as it helps with forwards/backwards compatibility, and
flexibility of data structures. By specifying this attribute, you make non-
presence in an error for both reader and writer. The reading code may access
the field directly, without checking for null. If the constructing code does
not initialize this field, they will get an assert, and also the verifier
will fail on buffers that have missing required fields. Both adding and
removing this attribute may be forwards/backwards incompatible as readers
will be unable read old or new data, respectively, unless the data happens to
always have the field set.</li>
<li><code>force_align: size</code> (on a struct): force the alignment of this struct
to be something higher than what it is naturally aligned to. Causes
these structs to be aligned to that amount inside a buffer, IF that
buffer is allocated with that alignment (which is not necessarily
the case for buffers accessed directly inside a <code>FlatBufferBuilder</code>).
Note: currently not guaranteed to have an effect when used with
<code>--object-api</code>, since that may allocate objects at alignments less than
what you specify with <code>force_align</code>.</li>
<li><code>force_align: size</code> (on a vector): force the alignment of this vector to be
something different than what the element size would normally dictate.
Note: Now only work for generated C++ code.</li>
<li><code>bit_flags</code> (on an unsigned enum): the values of this field indicate bits,
meaning that any unsigned value N specified in the schema will end up
representing 1&lt;&lt;N, or if you don't specify values at all, you'll get
the sequence 1, 2, 4, 8, ...</li>
<li><code>nested_flatbuffer: &quot;table_name&quot;</code> (on a field): this indicates that the field
(which must be a vector of ubyte) contains flatbuffer data, for which the
root type is given by <code>table_name</code>. The generated code will then produce
a convenient accessor for the nested FlatBuffer.</li>
<li><code>flexbuffer</code> (on a field): this indicates that the field
(which must be a vector of ubyte) contains flexbuffer data. The generated
code will then produce a convenient accessor for the FlexBuffer root.</li>
<li><code>key</code> (on a field): this field is meant to be used as a key when sorting
a vector of the type of table it sits in. Can be used for in-place
binary search.</li>
<li><code>hash</code> (on a field). This is an (un)signed 32/64 bit integer field, whose
value during JSON parsing is allowed to be a string, which will then be
stored as its hash. The value of attribute is the hashing algorithm to
use, one of <code>fnv1_32</code> <code>fnv1_64</code> <code>fnv1a_32</code> <code>fnv1a_64</code>.</li>
<li><code>original_order</code> (on a table): since elements in a table do not need
to be stored in any particular order, they are often optimized for
space by sorting them to size. This attribute stops that from happening.
There should generally not be any reason to use this flag.</li>
<li>'native_*'.  Several attributes have been added to support the [C++ object
Based API](@ref flatbuffers_cpp_object_based_api).  All such attributes
are prefixed with the term &quot;native_&quot;.</li>
</ul>
<h2 id="json-parsing"><a class="header" href="#json-parsing">JSON Parsing</a></h2>
<p>The same parser that parses the schema declarations above is also able
to parse JSON objects that conform to this schema. So, unlike other JSON
parsers, this parser is strongly typed, and parses directly into a FlatBuffer
(see the compiler documentation on how to do this from the command line, or
the C++ documentation on how to do this at runtime).</p>
<p>Besides needing a schema, there are a few other changes to how it parses
JSON:</p>
<ul>
<li>It accepts field names with and without quotes, like many JSON parsers
already do. It outputs them without quotes as well, though can be made
to output them using the <code>strict_json</code> flag.</li>
<li>If a field has an enum type, the parser will recognize symbolic enum
values (with or without quotes) instead of numbers, e.g.
<code>field: EnumVal</code>. If a field is of integral type, you can still use
symbolic names, but values need to be prefixed with their type and
need to be quoted, e.g. <code>field: &quot;Enum.EnumVal&quot;</code>. For enums
representing flags, you may place multiple inside a string
separated by spaces to OR them, e.g.
<code>field: &quot;EnumVal1 EnumVal2&quot;</code> or <code>field: &quot;Enum.EnumVal1 Enum.EnumVal2&quot;</code>.</li>
<li>Similarly, for unions, these need to specified with two fields much like
you do when serializing from code. E.g. for a field <code>foo</code>, you must
add a field <code>foo_type: FooOne</code> right before the <code>foo</code> field, where
<code>FooOne</code> would be the table out of the union you want to use.</li>
<li>A field that has the value <code>null</code> (e.g. <code>field: null</code>) is intended to
have the default value for that field (thus has the same effect as if
that field wasn't specified at all).</li>
<li>It has some built in conversion functions, so you can write for example
<code>rad(180)</code> where ever you'd normally write <code>3.14159</code>.
Currently supports the following functions: <code>rad</code>, <code>deg</code>, <code>cos</code>, <code>sin</code>,
<code>tan</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>.</li>
</ul>
<p>When parsing JSON, it recognizes the following escape codes in strings:</p>
<ul>
<li><code>\n</code> - linefeed.</li>
<li><code>\t</code> - tab.</li>
<li><code>\r</code> - carriage return.</li>
<li><code>\b</code> - backspace.</li>
<li><code>\f</code> - form feed.</li>
<li><code>\&quot;</code> - double quote.</li>
<li><code>\\</code> - backslash.</li>
<li><code>\/</code> - forward slash.</li>
<li><code>\uXXXX</code> - 16-bit unicode code point, converted to the equivalent UTF-8
representation.</li>
<li><code>\xXX</code> - 8-bit binary hexadecimal number XX. This is the only one that is
not in the JSON spec (see http://json.org/), but is needed to be able to
encode arbitrary binary in strings to text and back without losing
information (e.g. the byte 0xFF can't be represented in standard JSON).</li>
</ul>
<p>It also generates these escape codes back again when generating JSON from a
binary representation.</p>
<p>When parsing numbers, the parser is more flexible than JSON.
A format of numeric literals is more close to the C/C++.
According to the [grammar](@ref flatbuffers_grammar), it accepts the following
numerical literals:</p>
<ul>
<li>
<p>An integer literal can have any number of leading zero <code>0</code> digits.
Unlike C/C++, the parser ignores a leading zero, not interpreting it as the
beginning of the octal number.
The numbers <code>[081, -00094]</code> are equal to <code>[81, -94]</code>  decimal integers.</p>
</li>
<li>
<p>The parser accepts unsigned and signed hexadecimal integer numbers.
For example: <code>[0x123, +0x45, -0x67]</code> are equal to <code>[291, 69, -103]</code> decimals.</p>
</li>
<li>
<p>The format of float-point numbers is fully compatible with C/C++ format.
If a modern C++ compiler is used the parser accepts hexadecimal and special
floating-point literals as well:
<code>[-1.0, 2., .3e0, 3.e4, 0x21.34p-5, -inf, nan]</code>.</p>
<p>The following conventions for floating-point numbers are used:</p>
<ul>
<li>The exponent suffix of hexadecimal floating-point number is mandatory.</li>
<li>Parsed <code>NaN</code> converted to unsigned IEEE-754 <code>quiet-NaN</code> value.</li>
</ul>
<p>Extended floating-point support was tested with:</p>
<ul>
<li>x64 Windows: <code>MSVC2015</code> and higher.</li>
<li>x64 Linux: <code>LLVM 6.0</code>, <code>GCC 4.9</code> and higher.</li>
</ul>
<p>For details, see [Use in C++](@ref flatbuffers_guide_use_cpp) section.</p>
</li>
<li>
<p>For compatibility with a JSON lint tool all numeric literals of scalar
fields can be wrapped to quoted string:
<code>&quot;1&quot;, &quot;2.0&quot;, &quot;0x48A&quot;, &quot;0x0C.0Ep-1&quot;, &quot;-inf&quot;, &quot;true&quot;</code>.</p>
</li>
</ul>
<h2 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h2>
<h3 id="efficiency"><a class="header" href="#efficiency">Efficiency</a></h3>
<p>FlatBuffers is all about efficiency, but to realize that efficiency you
require an efficient schema. There are usually multiple choices on
how to represent data that have vastly different size characteristics.</p>
<p>It is very common nowadays to represent any kind of data as dictionaries
(as in e.g. JSON), because of its flexibility and extensibility. While
it is possible to emulate this in FlatBuffers (as a vector
of tables with key and value(s)), this is a bad match for a strongly
typed system like FlatBuffers, leading to relatively large binaries.
FlatBuffer tables are more flexible than classes/structs in most systems,
since having a large number of fields only few of which are actually
used is still efficient. You should thus try to organize your data
as much as possible such that you can use tables where you might be
tempted to use a dictionary.</p>
<p>Similarly, strings as values should only be used when they are
truly open-ended. If you can, always use an enum instead.</p>
<p>FlatBuffers doesn't have inheritance, so the way to represent a set
of related data structures is a union. Unions do have a cost however,
so an alternative to a union is to have a single table that has
all the fields of all the data structures you are trying to
represent, if they are relatively similar / share many fields.
Again, this is efficient because non-present fields are cheap.</p>
<p>FlatBuffers supports the full range of integer sizes, so try to pick
the smallest size needed, rather than defaulting to int/long.</p>
<p>Remember that you can share data (refer to the same string/table
within a buffer), so factoring out repeating data into its own
data structure may be worth it.</p>
<h3 id="style-guide"><a class="header" href="#style-guide">Style guide</a></h3>
<p>Identifiers in a schema are meant to translate to many different programming
languages, so using the style of your &quot;main&quot; language is generally a bad idea.</p>
<p>For this reason, below is a suggested style guide to adhere to, to keep schemas
consistent for interoperation regardless of the target language.</p>
<p>Where possible, the code generators for specific languages will generate
identifiers that adhere to the language style, based on the schema identifiers.</p>
<ul>
<li>Table, struct, enum and rpc names (types): UpperCamelCase.</li>
<li>Table and struct field names: snake_case. This is translated to lowerCamelCase
automatically for some languages, e.g. Java.</li>
<li>Enum values: UpperCamelCase.</li>
<li>namespaces: UpperCamelCase.</li>
</ul>
<p>Formatting (this is less important, but still worth adhering to):</p>
<ul>
<li>Opening brace: on the same line as the start of the declaration.</li>
<li>Spacing: Indent by 2 spaces. None around <code>:</code> for types, on both sides for <code>=</code>.</li>
</ul>
<p>For an example, see the schema at the top of this file.</p>
<h2 id="gotchas"><a class="header" href="#gotchas">Gotchas</a></h2>
<h3 id="schemas-and-version-control"><a class="header" href="#schemas-and-version-control">Schemas and version control</a></h3>
<p>FlatBuffers relies on new field declarations being added at the end, and earlier
declarations to not be removed, but be marked deprecated when needed. We think
this is an improvement over the manual number assignment that happens in
Protocol Buffers (and which is still an option using the <code>id</code> attribute
mentioned above).</p>
<p>One place where this is possibly problematic however is source control. If user
A adds a field, generates new binary data with this new schema, then tries to
commit both to source control after user B already committed a new field also,
and just auto-merges the schema, the binary files are now invalid compared to
the new schema.</p>
<p>The solution of course is that you should not be generating binary data before
your schema changes have been committed, ensuring consistency with the rest of
the world. If this is not practical for you, use explicit field ids, which
should always generate a merge conflict if two people try to allocate the same
id.</p>
<h3 id="schema-evolution-examples-tables"><a class="header" href="#schema-evolution-examples-tables">Schema evolution examples (tables)</a></h3>
<p>Some examples to clarify what happens as you change a schema:</p>
<p>If we have the following original schema:</p>
<pre><code>table { a:int; b:int; }
</code></pre>
<p>And we extend it:</p>
<pre><code>table { a:int; b:int; c:int; }
</code></pre>
<p>This is ok. Code compiled with the old schema reading data generated with the
new one will simply ignore the presence of the new field. Code compiled with the
new schema reading old data will get the default value for <code>c</code> (which is 0
in this case, since it is not specified).</p>
<pre><code>table { a:int (deprecated); b:int; }
</code></pre>
<p>This is also ok. Code compiled with the old schema reading newer data will now
always get the default value for <code>a</code> since it is not present. Code compiled
with the new schema now cannot read nor write <code>a</code> anymore (any existing code
that tries to do so will result in compile errors), but can still read
old data (they will ignore the field).</p>
<pre><code>table { c:int; a:int; b:int; }
</code></pre>
<p>This is NOT ok, as this makes the schemas incompatible. Old code reading newer
data will interpret <code>c</code> as if it was <code>a</code>, and new code reading old data
accessing <code>a</code> will instead receive <code>b</code>.</p>
<pre><code>table { c:int (id: 2); a:int (id: 0); b:int (id: 1); }
</code></pre>
<p>This is ok. If your intent was to order/group fields in a way that makes sense
semantically, you can do so using explicit id assignment. Now we are compatible
with the original schema, and the fields can be ordered in any way, as long as
we keep the sequence of ids.</p>
<pre><code>table { b:int; }
</code></pre>
<p>NOT ok. We can only remove a field by deprecation, regardless of whether we use
explicit ids or not.</p>
<pre><code>table { a:uint; b:uint; }
</code></pre>
<p>This is MAYBE ok, and only in the case where the type change is the same size,
like here. If old data never contained any negative numbers, this will be
safe to do.</p>
<pre><code>table { a:int = 1; b:int = 2; }
</code></pre>
<p>Generally NOT ok. Any older data written that had 0 values were not written to
the buffer, and rely on the default value to be recreated. These will now have
those values appear to <code>1</code> and <code>2</code> instead. There may be cases in which this
is ok, but care must be taken.</p>
<pre><code>table { aa:int; bb:int; }
</code></pre>
<p>Occasionally ok. You've renamed fields, which will break all code (and JSON
files!) that use this schema, but as long as the change is obvious, this is not
incompatible with the actual binary buffers, since those only ever address
fields by id/offset.</p>
<h4 id="schema-evolution-examples-unions"><a class="header" href="#schema-evolution-examples-unions">Schema evolution examples (unions)</a></h4>
<p>Suppose we have the following schema:</p>
<pre><code>union Foo { A, B }
</code></pre>
<p>We can add another variant at the end.</p>
<pre><code>union Foo { A, B, another_a: A }
</code></pre>
<p>and this will be okay. Old code will not recognize <code>another_a</code>.
However if we add <code>another_a</code> anywhere but the end, e.g.</p>
<pre><code>union Foo { A, another_a: A, B }
</code></pre>
<p>this is not okay. When new code writes <code>another_a</code>, old code will
misinterpret it as <code>B</code> (and vice versa). However you can explicitly
set the union's &quot;discriminant&quot; value like so:</p>
<pre><code>union Foo { A = 1, another_a: A = 3, B = 2 }
</code></pre>
<p>This is okay.</p>
<pre><code>union Foo { original_a: A = 1, another_a: A = 3, B = 2 }
</code></pre>
<p>Renaming fields will break code and any saved human readable representations,
such as json files, but the binary buffers will be the same.</p>
<br>
<h3 id="testing-whether-a-field-is-present-in-a-table"><a class="header" href="#testing-whether-a-field-is-present-in-a-table">Testing whether a field is present in a table</a></h3>
<p>Most serialization formats (e.g. JSON or Protocol Buffers) make it very
explicit in the format whether a field is present in an object or not,
allowing you to use this as &quot;extra&quot; information.</p>
<p>FlatBuffers will not write fields that are equal to their default value,
sometimes resulting in significant space savings. However, this also means we
cannot disambiguate the meaning of non-presence as &quot;written default value&quot; or
&quot;not written at all&quot;. This only applies to scalar fields since only they support
default values. Unless otherwise specified, their default is 0.</p>
<p>If you care about the presence of scalars, most languages support &quot;optional
scalars.&quot; You can set <code>null</code> as the default value in the schema. <code>null</code> is a
value that's outside of all types, so we will always write if <code>add_field</code> is
called. The generated field accessor should use the local language's canonical
optional type.</p>
<p>Some <code>FlatBufferBuilder</code> implementations have an option called <code>force_defaults</code>
that circumvents this &quot;not writing defaults&quot; behavior you can then use
<code>IsFieldPresent</code> to query presence.
/
Another option that works in all languages is to wrap a scalar field in a
struct. This way it will return null if it is not present. This will be slightly
less ergonomic but structs don't take up any more space than the scalar they
represent.</p>
<h2 id="writing-your-own-code-generator"><a class="header" href="#writing-your-own-code-generator">Writing your own code generator.</a></h2>
<p>See [our intermediate representation](@ref intermediate_representation).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-schema-compiler----flatbuffers_guide_using_schema_compiler"><a class="header" href="#using-the-schema-compiler----flatbuffers_guide_using_schema_compiler">Using the schema compiler    {#flatbuffers_guide_using_schema_compiler}</a></h1>
<p>Usage:</p>
<pre><code>flatc [ GENERATOR OPTIONS ] [ -o PATH ] [ -I PATH ] FILES...
      [ -- FILES...]
</code></pre>
<p>The files are read and parsed in order, and can contain either schemas
or data (see below). Data files are processed according to the definitions of
the most recent schema specified.</p>
<p><code>--</code> indicates that the following files are binary files in
FlatBuffer format conforming to the schema indicated before it.</p>
<p>Depending on the flags passed, additional files may
be generated for each file processed:</p>
<p>For any schema input files, one or more generators can be specified:</p>
<ul>
<li>
<p><code>--cpp</code>, <code>-c</code> : Generate a C++ header for all definitions in this file (as
<code>filename_generated.h</code>).</p>
</li>
<li>
<p><code>--java</code>, <code>-j</code> : Generate Java code.</p>
</li>
<li>
<p><code>--kotlin</code>, <code>-k</code> : Generate Kotlin code.</p>
</li>
<li>
<p><code>--csharp</code>, <code>-n</code> : Generate C# code.</p>
</li>
<li>
<p><code>--go</code>, <code>-g</code> : Generate Go code.</p>
</li>
<li>
<p><code>--python</code>, <code>-p</code>: Generate Python code.</p>
</li>
<li>
<p><code>--js</code>, <code>-s</code>: Generate JavaScript code.</p>
</li>
<li>
<p><code>--ts</code>: Generate TypeScript code.</p>
</li>
<li>
<p><code>--php</code>: Generate PHP code.</p>
</li>
<li>
<p><code>--grpc</code>: Generate RPC stub code for GRPC.</p>
</li>
<li>
<p><code>--dart</code>: Generate Dart code.</p>
</li>
<li>
<p><code>--lua</code>: Generate Lua code.</p>
</li>
<li>
<p><code>--lobster</code>: Generate Lobster code.</p>
</li>
<li>
<p><code>--rust</code>, <code>-r</code> : Generate Rust code.</p>
</li>
<li>
<p><code>--swift</code>: Generate Swift code.</p>
</li>
</ul>
<p>For any data input files:</p>
<ul>
<li>
<p><code>--binary</code>, <code>-b</code> : If data is contained in this file, generate a
<code>filename.bin</code> containing the binary flatbuffer (or a different extension
if one is specified in the schema).</p>
</li>
<li>
<p><code>--json</code>, <code>-t</code> : If data is contained in this file, generate a
<code>filename.json</code> representing the data in the flatbuffer.</p>
</li>
</ul>
<p>Additional options:</p>
<ul>
<li>
<p><code>-o PATH</code> : Output all generated files to PATH (either absolute, or
relative to the current directory). If omitted, PATH will be the
current directory. PATH should end in your systems path separator,
e.g. <code>/</code> or <code>\</code>.</p>
</li>
<li>
<p><code>-I PATH</code> : when encountering <code>include</code> statements, attempt to load the
files from this path. Paths will be tried in the order given, and if all
fail (or none are specified) it will try to load relative to the path of
the schema file being parsed.</p>
</li>
<li>
<p><code>-M</code> : Print make rules for generated files.</p>
</li>
<li>
<p><code>--strict-json</code> : Require &amp; generate strict JSON (field names are enclosed
in quotes, no trailing commas in tables/vectors). By default, no quotes are
required/generated, and trailing commas are allowed.</p>
</li>
<li>
<p><code>--allow-non-utf8</code> : Pass non-UTF-8 input through parser and emit nonstandard
\x escapes in JSON. (Default is to raise parse error on non-UTF-8 input.)</p>
</li>
<li>
<p><code>--natural-utf8</code> : Output strings with UTF-8 as human-readable strings.
By default, UTF-8 characters are printed as \uXXXX escapes.&quot;</p>
</li>
<li>
<p><code>--defaults-json</code> : Output fields whose value is equal to the default value
when writing JSON text.</p>
</li>
<li>
<p><code>--no-prefix</code> : Don't prefix enum values in generated C++ by their enum
type.</p>
</li>
<li>
<p><code>--scoped-enums</code> : Use C++11 style scoped and strongly typed enums in
generated C++. This also implies <code>--no-prefix</code>.</p>
</li>
<li>
<p><code>--gen-includes</code> : (deprecated), this is the default behavior.
If the original behavior is required (no include
statements) use <code>--no-includes.</code></p>
</li>
<li>
<p><code>--no-includes</code> : Don't generate include statements for included schemas the
generated file depends on (C++ / Python).</p>
</li>
<li>
<p><code>--gen-mutable</code> : Generate additional non-const accessors for mutating
FlatBuffers in-place.</p>
</li>
<li>
<p><code>--gen-onefile</code> : Generate single output file for C#, Go, and Python.</p>
</li>
<li>
<p><code>--gen-name-strings</code> : Generate type name functions for C++.</p>
</li>
<li>
<p><code>--gen-object-api</code> : Generate an additional object-based API. This API is
more convenient for object construction and mutation than the base API,
at the cost of efficiency (object allocation). Recommended only to be used
if other options are insufficient.</p>
</li>
<li>
<p><code>--gen-compare</code>  :  Generate operator== for object-based API types.</p>
</li>
<li>
<p><code>--gen-nullable</code> : Add Clang _Nullable for C++ pointer. or @Nullable for Java.</p>
</li>
<li>
<p><code>--gen-generated</code> : Add @Generated annotation for Java.</p>
</li>
<li>
<p><code>--gen-jvmstatic</code> : Add @JvmStatic annotation for Kotlin methods
in companion object for interop from Java to Kotlin.</p>
</li>
<li>
<p><code>--gen-all</code> : Generate not just code for the current schema files, but
for all files it includes as well. If the language uses a single file for
output (by default the case for C++ and JS), all code will end up in
this one file.</p>
</li>
<li>
<p><code>--cpp-include</code> : Adds an #include in generated file</p>
</li>
<li>
<p><code>--cpp-ptr-type T</code> : Set object API pointer type (default std::unique_ptr)</p>
</li>
<li>
<p><code>--cpp-str-type T</code> : Set object API string type (default std::string)
T::c_str(), T::length() and T::empty() must be supported.
The custom type also needs to be constructible from std::string (see the
--cpp-str-flex-ctor option to change this behavior).</p>
</li>
<li>
<p><code>--cpp-str-flex-ctor</code> : Don't construct custom string types by passing
std::string from Flatbuffers, but (char* + length). This allows efficient
construction of custom string types, including zero-copy construction.</p>
</li>
<li>
<p><code>--no-cpp-direct-copy</code> : Don't generate direct copy methods for C++
object-based API.</p>
</li>
<li>
<p><code>--cpp-std CPP_STD</code> : Generate a C++ code using features of selected C++ standard.
Supported <code>CPP_STD</code> values:</p>
<ul>
<li><code>c++0x</code> - generate code compatible with old compilers (VS2010),</li>
<li><code>c++11</code> - use C++11 code generator (default),</li>
<li><code>c++17</code> - use C++17 features in generated code (experimental).</li>
</ul>
</li>
<li>
<p><code>--object-prefix</code> : Customise class prefix for C++ object-based API.</p>
</li>
<li>
<p><code>--object-suffix</code> : Customise class suffix for C++ object-based API.</p>
</li>
<li>
<p><code>--go-namespace</code> : Generate the overrided namespace in Golang.</p>
</li>
<li>
<p><code>--go-import</code> : Generate the overrided import for flatbuffers in Golang.
(default is &quot;github.com/google/flatbuffers/go&quot;).</p>
</li>
<li>
<p><code>--raw-binary</code> : Allow binaries without a file_indentifier to be read.
This may crash flatc given a mismatched schema.</p>
</li>
<li>
<p><code>--size-prefixed</code> : Input binaries are size prefixed buffers.</p>
</li>
<li>
<p><code>--proto</code>: Expect input files to be .proto files (protocol buffers).
Output the corresponding .fbs file.
Currently supports: <code>package</code>, <code>message</code>, <code>enum</code>, nested declarations,
<code>import</code> (use <code>-I</code> for paths), <code>extend</code>, <code>oneof</code>, <code>group</code>.
Does not support, but will skip without error: <code>option</code>, <code>service</code>,
<code>extensions</code>, and most everything else.</p>
</li>
<li>
<p><code>--oneof-union</code> : Translate .proto oneofs to flatbuffer unions.</p>
</li>
<li>
<p><code>--grpc</code> : Generate GRPC interfaces for the specified languages.</p>
</li>
<li>
<p><code>--schema</code>: Serialize schemas instead of JSON (use with -b). This will
output a binary version of the specified schema that itself corresponds
to the reflection/reflection.fbs schema. Loading this binary file is the
basis for reflection functionality.</p>
</li>
<li>
<p><code>--bfbs-comments</code>: Add doc comments to the binary schema files.</p>
</li>
<li>
<p><code>--conform FILE</code> : Specify a schema the following schemas should be
an evolution of. Gives errors if not. Useful to check if schema
modifications don't break schema evolution rules.</p>
</li>
<li>
<p><code>--conform-includes PATH</code> : Include path for the schema given with
<code>--conform PATH</code>.</p>
</li>
<li>
<p><code>--filename-suffix SUFFIX</code> : The suffix appended to the generated
file names. Default is '_generated'.</p>
</li>
<li>
<p><code>--filename-ext EXTENSION</code> : The extension appended to the generated
file names. Default is language-specific (e.g. &quot;h&quot; for C++). This
should not be used when multiple languages are specified.</p>
</li>
<li>
<p><code>--include-prefix PATH</code> : Prefix this path to any generated include
statements.</p>
</li>
<li>
<p><code>--keep-prefix</code> : Keep original prefix of schema include statement.</p>
</li>
<li>
<p><code>--reflect-types</code> : Add minimal type reflection to code generation.</p>
</li>
<li>
<p><code>--reflect-names</code> : Add minimal type/name reflection.</p>
</li>
<li>
<p><code>--root-type T</code> : Select or override the default root_type.</p>
</li>
<li>
<p><code>--require-explicit-ids</code> : When parsing schemas, require explicit ids (id: x).</p>
</li>
<li>
<p><code>--force-defaults</code> : Emit default values in binary output from JSON.</p>
</li>
<li>
<p><code>--force-empty</code> : When serializing from object API representation, force
strings and vectors to empty rather than null.</p>
</li>
<li>
<p><code>--force-empty-vectors</code> : When serializing from object API representation, force
vectors to empty rather than null.</p>
</li>
<li>
<p><code>--flexbuffers</code> : Used with &quot;binary&quot; and &quot;json&quot; options, it generates
data using schema-less FlexBuffers.</p>
</li>
<li>
<p><code>--no-warnings</code> : Inhibit all warning messages.</p>
</li>
<li>
<p><code>--cs-global-alias</code> : Prepend <code>global::</code> to all user generated csharp classes and structs.</p>
</li>
<li>
<p><code>--json-nested-bytes</code> : Allow a nested_flatbuffer field to be parsed as a
vector of bytes in JSON, which is unsafe unless checked by a verifier
afterwards.</p>
</li>
</ul>
<p>NOTE: short-form options for generators are deprecated, use the long form
whenever possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flexbuffers-1"><a class="header" href="#flexbuffers-1">FlexBuffers</a></h1>
<p>FlatBuffers was designed around schemas, because when you want maximum
performance and data consistency, strong typing is helpful.</p>
<p>There are however times when you want to store data that doesn't fit a
schema, because you can't know ahead of time what all needs to be stored.</p>
<p>For this, FlatBuffers has a dedicated format, called FlexBuffers.
This is a binary format that can be used in conjunction
with FlatBuffers (by storing a part of a buffer in FlexBuffers
format), or also as its own independent serialization format.</p>
<p>While it loses the strong typing, you retain the most unique advantage
FlatBuffers has over other serialization formats (schema-based or not):
FlexBuffers can also be accessed without parsing / copying / object allocation.
This is a huge win in efficiency / memory friendly-ness, and allows unique
use cases such as mmap-ing large amounts of free-form data.</p>
<p>FlexBuffers' design and implementation allows for a very compact encoding,
combining automatic pooling of strings with automatic sizing of containers to
their smallest possible representation (8/16/32/64 bits). Many values and
offsets can be encoded in just 8 bits. While a schema-less representation is
usually more bulky because of the need to be self-descriptive, FlexBuffers
generates smaller binaries for many cases than regular FlatBuffers.</p>
<p>FlexBuffers is still slower than regular FlatBuffers though, so we recommend to
only use it if you need it.</p>
<h1 id="usage-in-c"><a class="header" href="#usage-in-c">Usage in C++</a></h1>
<p>Include the header <code>flexbuffers.h</code>, which in turn depends on <code>flatbuffers.h</code>
and <code>util.h</code>.</p>
<p>To create a buffer:</p>
<pre><code class="language-{.cpp}">flexbuffers::Builder fbb;
fbb.Int(13);
fbb.Finish();
</code></pre>
<p>You create any value, followed by <code>Finish</code>. Unlike FlatBuffers which requires
the root value to be a table, here any value can be the root, including a lonely
int value.</p>
<p>You can now access the <code>std::vector&lt;uint8_t&gt;</code> that contains the encoded value
as <code>fbb.GetBuffer()</code>. Write it, send it, or store it in a parent FlatBuffer. In
this case, the buffer is just 3 bytes in size.</p>
<p>To read this value back, you could just say:</p>
<pre><code class="language-{.cpp}">auto root = flexbuffers::GetRoot(my_buffer);
int64_t i = root.AsInt64();
</code></pre>
<p>FlexBuffers stores ints only as big as needed, so it doesn't differentiate
between different sizes of ints. You can ask for the 64 bit version,
regardless of what you put in. In fact, since you demand to read the root
as an int, if you supply a buffer that actually contains a float, or a
string with numbers in it, it will convert it for you on the fly as well,
or return 0 if it can't. If instead you actually want to know what is inside
the buffer before you access it, you can call <code>root.GetType()</code> or <code>root.IsInt()</code>
etc.</p>
<p>Here's a slightly more complex value you could write instead of <code>fbb.Int</code> above:</p>
<pre><code class="language-{.cpp}">fbb.Map([&amp;]() {
  fbb.Vector(&quot;vec&quot;, [&amp;]() {
    fbb.Int(-100);
    fbb.String(&quot;Fred&quot;);
    fbb.IndirectFloat(4.0f);
  });
  fbb.UInt(&quot;foo&quot;, 100);
});
</code></pre>
<p>This stores the equivalent of the JSON value
<code>{ vec: [ -100, &quot;Fred&quot;, 4.0 ], foo: 100 }</code>. The root is a dictionary that has
just two key-value pairs, with keys <code>vec</code> and <code>foo</code>. Unlike FlatBuffers, it
actually has to store these keys in the buffer (which it does only once if
you store multiple such objects, by pooling key values), but also unlike
FlatBuffers it has no restriction on the keys (fields) that you use.</p>
<p>The map constructor uses a C++11 Lambda to group its children, but you can
also use more conventional start/end calls if you prefer.</p>
<p>The first value in the map is a vector. You'll notice that unlike FlatBuffers,
you can use mixed types. There is also a <code>TypedVector</code> variant that only
allows a single type, and uses a bit less memory.</p>
<p><code>IndirectFloat</code> is an interesting feature that allows you to store values
by offset rather than inline. Though that doesn't make any visible change
to the user, the consequence is that large values (especially doubles or
64 bit ints) that occur more than once can be shared (see ReuseValue).
Another use case is inside of vectors, where the largest element makes
up the size of all elements (e.g. a single double forces all elements to
64bit), so storing a lot of small integers together with a double is more efficient if the double is indirect.</p>
<p>Accessing it:</p>
<pre><code class="language-{.cpp}">auto map = flexbuffers::GetRoot(my_buffer).AsMap();
map.size();  // 2
auto vec = map[&quot;vec&quot;].AsVector();
vec.size();  // 3
vec[0].AsInt64();  // -100;
vec[1].AsString().c_str();  // &quot;Fred&quot;;
vec[1].AsInt64();  // 0 (Number parsing failed).
vec[2].AsDouble();  // 4.0
vec[2].AsString().IsTheEmptyString();  // true (Wrong Type).
vec[2].AsString().c_str();  // &quot;&quot; (This still works though).
vec[2].ToString().c_str();  // &quot;4&quot; (Or have it converted).
map[&quot;foo&quot;].AsUInt8();  // 100
map[&quot;unknown&quot;].IsNull();  // true
</code></pre>
<h1 id="usage-in-java"><a class="header" href="#usage-in-java">Usage in Java</a></h1>
<p>Java implementation follows the C++ one, closely.</p>
<p>For creating the equivalent of the same JSON <code>{ vec: [ -100, &quot;Fred&quot;, 4.0 ], foo: 100 }</code>,
one could use the following code:</p>
<pre><code class="language-{.java}">FlexBuffersBuilder builder = new FlexBuffersBuilder(ByteBuffer.allocate(512),
		                                                FlexBuffersBuilder.BUILDER_FLAG_SHARE_KEYS_AND_STRINGS);
int smap = builder.startMap();
int svec = builder.startVector();
builder.putInt(-100);
builder.putString(&quot;Fred&quot;);
builder.putFloat(4.0);
builder.endVector(&quot;vec&quot;, svec, false, false);
builder.putInt(&quot;foo&quot;, 100);
builder.endMap(null, smap);
ByteBuffer bb = builder.finish();
</code></pre>
<p>Similarly, to read the data, just:</p>
<pre><code class="language-{.java}">FlexBuffers.Map map = FlexBuffers.getRoot(bb).asMap();
map.size();  // 2
FlexBuffers.Vector vec = map.get(&quot;vec&quot;).asVector();
vec.size();  // 3
vec.get(0).asLong();  // -100;
vec.get(1).asString();  // &quot;Fred&quot;;
vec.get(1).asLong();  // 0 (Number parsing failed).
vec.get(2).asFloat();  // 4.0
vec.get(2).asString().isEmpty();  // true (Wrong Type).
vec.get(2).asString();  // &quot;&quot; (This still works though).
vec.get(2).toString();  // &quot;4.0&quot; (Or have it converted).
map.get(&quot;foo&quot;).asUInt();  // 100
map.get(&quot;unknown&quot;).isNull();  // true
</code></pre>
<h1 id="binary-encoding"><a class="header" href="#binary-encoding">Binary encoding</a></h1>
<p>A description of how FlexBuffers are encoded is in the
[internals](@ref flatbuffers_internals) document.</p>
<h1 id="nesting-inside-a-flatbuffer"><a class="header" href="#nesting-inside-a-flatbuffer">Nesting inside a FlatBuffer</a></h1>
<p>You can mark a field as containing a FlexBuffer, e.g.</p>
<pre><code>a:[ubyte] (flexbuffer);
</code></pre>
<p>A special accessor will be generated that allows you to access the root value
directly, e.g. <code>a_flexbuffer_root().AsInt64()</code>.</p>
<h1 id="efficiency-tips"><a class="header" href="#efficiency-tips">Efficiency tips</a></h1>
<ul>
<li>Vectors generally are a lot more efficient than maps, so prefer them over maps
when possible for small objects. Instead of a map with keys <code>x</code>, <code>y</code> and <code>z</code>,
use a vector. Better yet, use a typed vector. Or even better, use a fixed
size typed vector.</li>
<li>Maps are backwards compatible with vectors, and can be iterated as such.
You can iterate either just the values (<code>map.Values()</code>), or in parallel with
the keys vector (<code>map.Keys()</code>). If you intend
to access most or all elements, this is faster than looking up each element
by key, since that involves a binary search of the key vector.</li>
<li>When possible, don't mix values that require a big bit width (such as double)
in a large vector of smaller values, since all elements will take on this
width. Use <code>IndirectDouble</code> when this is a possibility. Note that
integers automatically use the smallest width possible, i.e. if you ask
to serialize an int64_t whose value is actually small, you will use less
bits. Doubles are represented as floats whenever possible losslessly, but
this is only possible for few values.
Since nested vectors/maps are stored over offsets, they typically don't
affect the vector width.</li>
<li>To store large arrays of byte data, use a blob. If you'd use a typed
vector, the bit width of the size field may make it use more space than
expected, and may not be compatible with <code>memcpy</code>.
Similarly, large arrays of (u)int16_t may be better off stored as a
binary blob if their size could exceed 64k elements.
Construction and use are otherwise similar to strings.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-benchmarks"><a class="header" href="#c-benchmarks">C++ Benchmarks</a></h1>
<p>Comparing against other serialization solutions, running on Windows 7
64bit. We use the LITE runtime for Protocol Buffers (less code / lower
overhead), Rapid JSON (one of the fastest C++ JSON parsers around),
and pugixml, also one of the fastest XML parsers.</p>
<p>We also compare against code that doesn't use a serialization library
at all (the column &quot;Raw structs&quot;), which is what you get if you write
hardcoded code that just writes structs. This is the fastest possible,
but of course is not cross platform nor has any kind of forwards /
backwards compatibility.</p>
<p>We compare against Flatbuffers with the binary wire format (as
intended), and also with JSON as the wire format with the optional JSON
parser (which, using a schema, parses JSON into a binary buffer that can
then be accessed as before).</p>
<p>The benchmark object is a set of about 10 objects containing an array, 4
strings, and a large variety of int/float scalar values of all sizes,
meant to be representative of game data, e.g. a scene format.</p>
<table><thead><tr><th></th><th>FlatBuffers (binary)</th><th>Protocol Buffers LITE</th><th>Rapid JSON</th><th>FlatBuffers (JSON)</th><th>pugixml</th><th>Raw structs</th></tr></thead><tbody>
<tr><td>Decode + Traverse + Dealloc (1 million times, seconds)</td><td>0.08</td><td>302</td><td>583</td><td>105</td><td>196</td><td>0.02</td></tr>
<tr><td>Decode / Traverse / Dealloc (breakdown)</td><td>0 / 0.08 / 0</td><td>220 / 0.15 / 81</td><td>294 / 0.9 / 287</td><td>70 / 0.08 / 35</td><td>41 / 3.9 / 150</td><td>0 / 0.02 / 0</td></tr>
<tr><td>Encode (1 million times, seconds)</td><td>3.2</td><td>185</td><td>650</td><td>169</td><td>273</td><td>0.15</td></tr>
<tr><td>Wire format size (normal / zlib, bytes)</td><td>344 / 220</td><td>228 / 174</td><td>1475 / 322</td><td>1029 / 298</td><td>1137 / 341</td><td>312 / 187</td></tr>
<tr><td>Memory needed to store decoded wire (bytes / blocks)</td><td>0 / 0</td><td>760 / 20</td><td>65689 / 4</td><td>328 / 1</td><td>34194 / 3</td><td>0 / 0</td></tr>
<tr><td>Transient memory allocated during decode (KB)</td><td>0</td><td>1</td><td>131</td><td>4</td><td>34</td><td>0</td></tr>
<tr><td>Generated source code size (KB)</td><td>4</td><td>61</td><td>0</td><td>4</td><td>0</td><td>0</td></tr>
<tr><td>Field access in handwritten traversal code</td><td>typed accessors</td><td>typed accessors</td><td>manual error checking</td><td>typed accessors</td><td>manual error checking</td><td>typed but no safety</td></tr>
<tr><td>Library source code (KB)</td><td>15</td><td>some subset of 3800</td><td>87</td><td>43</td><td>327</td><td>0</td></tr>
</tbody></table>
<h3 id="some-other-serialization-systems-we-compared-against-but-did-not-benchmark-yet-in-rough-order-of-applicability"><a class="header" href="#some-other-serialization-systems-we-compared-against-but-did-not-benchmark-yet-in-rough-order-of-applicability">Some other serialization systems we compared against but did not benchmark (yet), in rough order of applicability:</a></h3>
<ul>
<li>Cap'n'Proto promises to reduce Protocol Buffers much like FlatBuffers does,
though with a more complicated binary encoding and less flexibility (no
optional fields to allow deprecating fields or serializing with missing
fields for which defaults exist).
It currently also isn't fully cross-platform portable (lack of VS support).</li>
<li>msgpack: has very minimal forwards/backwards compatibility support when used
with the typed C++ interface. Also lacks VS2010 support.</li>
<li>Thrift: very similar to Protocol Buffers, but appears to be less efficient,
and have more dependencies.</li>
<li>YAML: a superset of JSON and otherwise very similar. Used by e.g. Unity.</li>
<li>C# comes with built-in serialization functionality, as used by Unity also.
Being tied to the language, and having no automatic versioning support
limits its applicability.</li>
<li>Project Anarchy (the free mobile engine by Havok) comes with a serialization
system, that however does no automatic versioning (have to code around new
fields manually), is very much tied to the rest of the engine, and works
without a schema to generate code (tied to your C++ class definition).</li>
</ul>
<h3 id="code-for-benchmarks"><a class="header" href="#code-for-benchmarks">Code for benchmarks</a></h3>
<p>Code for these benchmarks sits in <code>benchmarks/</code> in git branch <code>benchmarks</code>.
It sits in its own branch because it has submodule dependencies that the main
project doesn't need, and the code standards do not meet those of the main
project. Please read <code>benchmarks/cpp/README.txt</code> before working with the code.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform--language--feature-support----flatbuffers_support"><a class="header" href="#platform--language--feature-support----flatbuffers_support">Platform / Language / Feature support    {#flatbuffers_support}</a></h1>
<p>FlatBuffers is actively being worked on, which means that certain platform /
language / feature combinations may not be available yet.</p>
<p>This page tries to track those issues, to make informed decisions easier.
In general:</p>
<ul>
<li>Languages: language support beyond the ones created by the original
FlatBuffer authors typically depends on community contributions.</li>
<li>Features: C++ was the first language supported, since our original
target was high performance game development. It thus has the richest
feature set, and is likely most robust. Other languages are catching up
however.</li>
<li>Platforms: All language implementations are typically portable to most
platforms, unless where noted otherwise.</li>
</ul>
<p>NOTE: this table is a start, it needs to be extended.</p>
<table><thead><tr><th>Feature</th><th>C++</th><th>Java</th><th>C#</th><th>Go</th><th>Python</th><th>JS</th><th>TS</th><th>C</th><th>PHP</th><th>Dart</th><th>Lobster</th><th>Rust</th><th>Swift</th></tr></thead><tbody>
<tr><td>Codegen for all basic features</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>WiP</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>JSON parsing</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td>Simple mutation</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr>
<tr><td>Reflection</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Basic</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td>Buffer verifier</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td>Native Object API</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td>Optional Scalars</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Flexbuffers</td><td>Yes</td><td>Yes</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>Yes</td><td>?</td></tr>
<tr><td>Testing: basic</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>?</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Testing: fuzz</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>?</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td>Performance:</td><td>Superb</td><td>Great</td><td>Great</td><td>Great</td><td>Ok</td><td>?</td><td>?</td><td>Superb</td><td>?</td><td>?</td><td>Great</td><td>Superb</td><td>Great</td></tr>
<tr><td>Platform: Windows</td><td>VS2010</td><td>Yes</td><td>Yes</td><td>?</td><td>?</td><td>?</td><td>Yes</td><td>VS2010</td><td>?</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td>Platform: Linux</td><td>GCC282</td><td>Yes</td><td>?</td><td>Yes</td><td>Yes</td><td>?</td><td>Yes</td><td>Yes</td><td>?</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Platform: OS X</td><td>Xcode4</td><td>?</td><td>?</td><td>?</td><td>Yes</td><td>?</td><td>Yes</td><td>Yes</td><td>?</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Platform: Android</td><td>NDK10d</td><td>Yes</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>Flutter</td><td>Yes</td><td>?</td><td>No</td></tr>
<tr><td>Platform: iOS</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>Flutter</td><td>Yes</td><td>?</td><td>Yes</td></tr>
<tr><td>Engine: Unity</td><td>?</td><td>?</td><td>Yes</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>No</td><td>?</td><td>No</td></tr>
<tr><td>Primary authors (github)</td><td>aard</td><td>aard</td><td>ev/js/df</td><td>rw</td><td>rw</td><td>ew/ev</td><td>kr</td><td>mik</td><td>ch</td><td>df</td><td>aard</td><td>rw/cn</td><td>mi/mz</td></tr>
</tbody></table>
<table><thead><tr><th>Above</th><th>Github username</th></tr></thead><tbody>
<tr><td>aard</td><td>aardappel (previously: gwvo)</td></tr>
<tr><td>ch</td><td>chobie</td></tr>
<tr><td>cn</td><td>caspern</td></tr>
<tr><td>df</td><td>dnfield</td></tr>
<tr><td>ev</td><td>evolutional</td></tr>
<tr><td>ew</td><td>evanw</td></tr>
<tr><td>js</td><td>jonsimantov</td></tr>
<tr><td>kr</td><td>krojew</td></tr>
<tr><td>mi</td><td>mustiikhalil</td></tr>
<tr><td>mik</td><td>mikkelfj</td></tr>
<tr><td>mz</td><td>mzaks</td></tr>
<tr><td>rw</td><td>rw</td></tr>
</tbody></table>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial---flatbuffers_guide_tutorial"><a class="header" href="#tutorial---flatbuffers_guide_tutorial">Tutorial   {#flatbuffers_guide_tutorial}</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This tutorial provides a basic example of how to work with
[FlatBuffers](@ref flatbuffers_overview). We will step through a simple example
application, which shows you how to:</p>
<ul>
<li>Write a FlatBuffer <code>schema</code> file.</li>
<li>Use the <code>flatc</code> FlatBuffer compiler.</li>
<li>Parse <a href="http://json.org">JSON</a> files that conform to a schema into
FlatBuffer binary files.</li>
<li>Use the generated files in many of the supported languages (such as C++,
Java, and more.)</li>
</ul>
<p>During this example, imagine that you are creating a game where the main
character, the hero of the story, needs to slay some <code>orc</code>s. We will walk
through each step necessary to create this monster type using FlatBuffers.</p>
<p>Please select your desired language for our quest:
\htmlonly</p>
<form>
  <input type="radio" name="language" value="cpp" checked="checked">C++</input>
  <input type="radio" name="language" value="java">Java</input>
  <input type="radio" name="language" value="kotlin">Kotlin</input>
  <input type="radio" name="language" value="csharp">C#</input>
  <input type="radio" name="language" value="go">Go</input>
  <input type="radio" name="language" value="python">Python</input>
  <input type="radio" name="language" value="javascript">JavaScript</input>
  <input type="radio" name="language" value="typescript">TypeScript</input>
  <input type="radio" name="language" value="php">PHP</input>
  <input type="radio" name="language" value="c">C</input>
  <input type="radio" name="language" value="dart">Dart</input>
  <input type="radio" name="language" value="lua">Lua</input>
  <input type="radio" name="language" value="lobster">Lobster</input>
  <input type="radio" name="language" value="rust">Rust</input>
  <input type="radio" name="language" value="swift">Swift</input>
</form>
\endhtmlonly
<p>\htmlonly</p>
<script>
  /**
   * Check if an HTML `class` attribute is in the language-specific format.
   * @param {string} languageClass An HTML `class` attribute in the format
   * 'language-{lang}', where {lang} is a programming language (e.g. 'cpp',
   * 'java', 'go', etc.).
   * @return {boolean} Returns `true` if `languageClass` was in the valid
   * format, prefixed with 'language-'. Otherwise, it returns false.
   */
  function isProgrammingLanguageClassName(languageClass) {
    if (languageClass && languageClass.substring(0, 9) == 'language-' &&
        languageClass.length > 8) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Given a language-specific HTML `class` attribute, extract the language.
   * @param {string} languageClass The string name of an HTML `class` attribute,
   * in the format `language-{lang}`, where {lang} is a programming language
   * (e.g. 'cpp', 'java', 'go', etc.).
   * @return {string} Returns a string containing only the {lang} portion of
   * the class name. If the input was invalid, then it returns `null`.
   */
  function extractProgrammingLanguageFromLanguageClass(languageClass) {
    if (isProgrammingLanguageClassName(languageClass)) {
      return languageClass.substring(9);
    } else {
      return null;
    }
  }

  /**
   * Hide every code snippet, except for the language that is selected.
   */
  function displayChosenLanguage() {
    var selection = $('input:checked').val();

    var htmlElements = document.getElementsByTagName('*');
    for (var i = 0; i < htmlElements.length; i++) {
      if (isProgrammingLanguageClassName(htmlElements[i].className)) {
        if (extractProgrammingLanguageFromLanguageClass(
              htmlElements[i].className).toLowerCase() != selection) {
          htmlElements[i].style.display = 'none';
        } else {
          htmlElements[i].style.display = 'initial';
        }
      }
    }
  }

  $( document ).ready(displayChosenLanguage);

  $('input[type=radio]').on("click", displayChosenLanguage);
</script>
<p>\endhtmlonly</p>
<h2 id="where-to-find-the-example-code"><a class="header" href="#where-to-find-the-example-code">Where to Find the Example Code</a></h2>
<p>Samples demonstating the concepts in this example are located in the source code
package, under the <code>samples</code> directory. You can browse the samples on GitHub
<a href="https://github.com/google/flatbuffers/tree/master/samples">here</a>.</p>
<div class="language-c">
*Note: The above does not apply to C, instead [look here](https://github.com/dvidelabs/flatcc/tree/master/samples).*
</div>
<p>For your chosen language, please cross-reference with:</p>
<div class="language-cpp">
[sample_binary.cpp](https://github.com/google/flatbuffers/blob/master/samples/sample_binary.cpp)
</div>
<div class="language-java">
[SampleBinary.java](https://github.com/google/flatbuffers/blob/master/samples/SampleBinary.java)
</div>
<div class="language-kotlin">
[SampleBinary.kt](https://github.com/google/flatbuffers/blob/master/samples/SampleBinary.kt)
</div>
<div class="language-csharp">
[SampleBinary.cs](https://github.com/google/flatbuffers/blob/master/samples/SampleBinary.cs)
</div>
<div class="language-go">
[sample_binary.go](https://github.com/google/flatbuffers/blob/master/samples/sample_binary.go)
</div>
<div class="language-python">
[sample_binary.py](https://github.com/google/flatbuffers/blob/master/samples/sample_binary.py)
</div>
<div class="language-javascript">
No sample binary is provided, since JS needs to be transpiled from TypeScript. Please see TypeScript support.
</div>
<div class="language-typescript">
<em>none yet</em>
</div>
<div class="language-php">
[SampleBinary.php](https://github.com/google/flatbuffers/blob/master/samples/SampleBinary.php)
</div>
<div class="language-c">
[monster.c](https://github.com/dvidelabs/flatcc/blob/master/samples/monster/monster.c)
</div>
<div class="language-dart">
[example.dart](https://github.com/google/flatbuffers/blob/master/dart/example/example.dart)
</div>
<div class="language-lua">
[sample_binary.lua](https://github.com/google/flatbuffers/blob/master/samples/sample_binary.lua)
</div>
<div class="language-lobster">
[sample_binary.lobster](https://github.com/google/flatbuffers/blob/master/samples/sample_binary.lobster)
</div>
<div class="language-rust">
[sample_binary.rs](https://github.com/google/flatbuffers/blob/master/samples/sample_binary.rs)
</div>
<div class="language-swift">
[sample_binary.swift](https://github.com/google/flatbuffers/blob/master/samples/sample_binary.swift)
</div>
<h2 id="writing-the-monsters-flatbuffer-schema"><a class="header" href="#writing-the-monsters-flatbuffer-schema">Writing the Monsters' FlatBuffer Schema</a></h2>
<p>To start working with FlatBuffers, you first need to create a <code>schema</code> file,
which defines the format for each data structure you wish to serialize. Here is
the <code>schema</code> that defines the template for our monsters:</p>
<pre><code>  // Example IDL file for our monster's schema.

  namespace MyGame.Sample;

  enum Color:byte { Red = 0, Green, Blue = 2 }

  union Equipment { Weapon } // Optionally add more tables.

  struct Vec3 {
    x:float;
    y:float;
    z:float;
  }

  table Monster {
    pos:Vec3; // Struct.
    mana:short = 150;
    hp:short = 100;
    name:string;
    friendly:bool = false (deprecated);
    inventory:[ubyte];  // Vector of scalars.
    color:Color = Blue; // Enum.
    weapons:[Weapon];   // Vector of tables.
    equipped:Equipment; // Union.
    path:[Vec3];        // Vector of structs.
  }

  table Weapon {
    name:string;
    damage:short;
  }

  root_type Monster;
</code></pre>
<p>As you can see, the syntax for the <code>schema</code>
<a href="https://en.wikipedia.org/wiki/Interface_description_language">Interface Definition Language (IDL)</a>
is similar to those of the C family of languages, and other IDL languages. Let's
examine each part of this <code>schema</code> to determine what it does.</p>
<p>The <code>schema</code> starts with a <code>namespace</code> declaration. This determines the
corresponding package/namespace for the generated code. In our example, we have
the <code>Sample</code> namespace inside of the <code>MyGame</code> namespace.</p>
<p>Next, we have an <code>enum</code> definition. In this example, we have an <code>enum</code> of type
<code>byte</code>, named <code>Color</code>. We have three values in this <code>enum</code>: <code>Red</code>, <code>Green</code>, and
<code>Blue</code>. We specify <code>Red = 0</code> and <code>Blue = 2</code>, but we do not specify an explicit
value for <code>Green</code>. Since the behavior of an <code>enum</code> is to increment if
unspecified, <code>Green</code> will receive the implicit value of <code>1</code>.</p>
<p>Following the <code>enum</code> is a <code>union</code>. The <code>union</code> in this example is not very
useful, as it only contains the one <code>table</code> (named <code>Weapon</code>). If we had created
multiple tables that we would want the <code>union</code> to be able to reference, we
could add more elements to the <code>union Equipment</code>.</p>
<p>After the <code>union</code> comes a <code>struct Vec3</code>, which represents a floating point
vector with <code>3</code> dimensions. We use a <code>struct</code> here, over a <code>table</code>, because
<code>struct</code>s are ideal for data structures that will not change, since they use
less memory and have faster lookup.</p>
<p>The <code>Monster</code> table is the main object in our FlatBuffer. This will be used as
the template to store our <code>orc</code> monster. We specify some default values for
fields, such as <code>mana:short = 150</code>. If unspecified, scalar fields (like <code>int</code>,
<code>uint</code>, or <code>float</code>) will be given a default of <code>0</code> while strings and tables will
be given a default of <code>null</code>. Another thing to note is the line <code>friendly:bool = false (deprecated);</code>. Since you cannot delete fields from a <code>table</code> (to support
backwards compatibility), you can set fields as <code>deprecated</code>, which will prevent
the generation of accessors for this field in the generated code. Be careful
when using <code>deprecated</code>, however, as it may break legacy code that used this
accessor.</p>
<p>The <code>Weapon</code> table is a sub-table used within our FlatBuffer. It is
used twice: once within the <code>Monster</code> table and once within the <code>Equipment</code>
union. For our <code>Monster</code>, it is used to populate a <code>vector of tables</code> via the
<code>weapons</code> field within our <code>Monster</code>. It is also the only table referenced by
the <code>Equipment</code> union.</p>
<p>The last part of the <code>schema</code> is the <code>root_type</code>. The root type declares what
will be the root table for the serialized data. In our case, the root type is
our <code>Monster</code> table.</p>
<p>The scalar types can also use alias type names such as <code>int16</code> instead
of <code>short</code> and <code>float32</code> instead of <code>float</code>. Thus we could also write
the <code>Weapon</code> table as:</p>
<pre><code>  table Weapon {
    name:string;
    damage:int16;
  }
</code></pre>
<h4 id="more-information-about-schemas"><a class="header" href="#more-information-about-schemas">More Information About Schemas</a></h4>
<p>You can find a complete guide to writing <code>schema</code> files in the
[Writing a schema](@ref flatbuffers_guide_writing_schema) section of the
Programmer's Guide. You can also view the formal
[Grammar of the schema language](@ref flatbuffers_grammar).</p>
<h2 id="compiling-the-monsters-schema"><a class="header" href="#compiling-the-monsters-schema">Compiling the Monsters' Schema</a></h2>
<p>After you have written the FlatBuffers schema, the next step is to compile it.</p>
<p>If you have not already done so, please follow
[these instructions](@ref flatbuffers_guide_building) to build <code>flatc</code>, the
FlatBuffer compiler.</p>
<p>Once <code>flatc</code> is built successfully, compile the schema for your language:</p>
<div class="language-c">
*Note: If you're working in C, you need to use the separate project [FlatCC](https://github.com/dvidelabs/flatcc) which contains a schema compiler and runtime library in C for C.*
<br>
See [flatcc build instructions](https://github.com/dvidelabs/flatcc#building).
<br>
Please be aware of the difference between `flatc` and `flatcc` tools.
<br>
</div>
<div class="language-cpp">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --cpp monster.fbs
~~~
</div>
<div class="language-java">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --java monster.fbs
~~~
</div>
<div class="language-kotlin">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --kotlin monster.fbs
~~~
</div>
<div class="language-csharp">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --csharp monster.fbs
~~~
</div>
<div class="language-go">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --go monster.fbs
~~~
</div>
<div class="language-python">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --python monster.fbs
~~~
</div>
<div class="language-javascript">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --ts monster.fbs
  # customize your TS -> JS transpilation
  tsc monster_generated.ts
~~~
</div>
<div class="language-typescript">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --ts monster.fbs
~~~
</div>
<div class="language-php">
~~~{.sh}
  cd flatbuffers/sample
  ./../flatc --php monster.fbs
~~~
</div>
<div class="language-c">
~~~{.sh}
  cd flatcc
  mkdir -p build/tmp/samples/monster
  bin/flatcc -a -o build/tmp/samples/monster samples/monster/monster.fbs
  # or just
  flatcc/samples/monster/build.sh
~~~
</div>
<div class="language-dart">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --dart monster.fbs
~~~
</div>
<div class="language-lua">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --lua monster.fbs
~~~
</div>
<div class="language-lobster">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --lobster monster.fbs
~~~
</div>
<div class="language-rust">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --rust monster.fbs
~~~
</div>
<div class="language-swift">
~~~{.sh}
  cd flatbuffers/samples
  ./../flatc --swift monster.fbs
~~~
</div>
<p>For a more complete guide to using the <code>flatc</code> compiler, please read the
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler)
section of the Programmer's Guide.</p>
<h2 id="reading-and-writing-monster-flatbuffers"><a class="header" href="#reading-and-writing-monster-flatbuffers">Reading and Writing Monster FlatBuffers</a></h2>
<p>Now that we have compiled the schema for our programming language, we can
start creating some monsters and serializing/deserializing them from
FlatBuffers.</p>
<h4 id="creating-and-writing-orc-flatbuffers"><a class="header" href="#creating-and-writing-orc-flatbuffers">Creating and Writing Orc FlatBuffers</a></h4>
<p>The first step is to import/include the library, generated files, etc.</p>
<div class="language-cpp">
~~~{.cpp}
  #include "monster_generated.h" // This was generated by `flatc`.
<p>using namespace MyGame::Sample; // Specified in the schema.</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-java&quot;&gt;
~~~{.java}
  import MyGame.Sample.*; //The `flatc` generated files. (Monster, Vec3, etc.)

  import com.google.flatbuffers.FlatBufferBuilder;
</code></pre>
</div>
<div class="language-kotlin">
~~~{.kotlin}
  import MyGame.Sample.* //The `flatc` generated files. (Monster, Vec3, etc.)
<p>import com.google.flatbuffers.FlatBufferBuilder</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-csharp&quot;&gt;
~~~{.cs}
  using FlatBuffers;
  using MyGame.Sample; // The `flatc` generated files. (Monster, Vec3, etc.)
</code></pre>
</div>
<div class="language-go">
~~~{.go}
  import (
          flatbuffers "github.com/google/flatbuffers/go"
          sample "MyGame/Sample"
  )
~~~
</div>
<div class="language-python">
~~~{.py}
  import flatbuffers
<h1 id="generated-by-flatc"><a class="header" href="#generated-by-flatc">Generated by <code>flatc</code>.</a></h1>
<p>import MyGame.Sample.Color
import MyGame.Sample.Equipment
import MyGame.Sample.Monster
import MyGame.Sample.Vec3
import MyGame.Sample.Weapon</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-javascript&quot;&gt;
~~~{.js}
  // The following code is an example - use your desired module flavor by transpiling from TS. 
  var flatbuffers = require('/js/flatbuffers').flatbuffers;
  var MyGame = require('./monster_generated').MyGame; // Generated by `flatc`.

  //--------------------------------------------------------------------------//

  // The following code is for browser-based HTML/JavaScript. Use the above code
  // for JavaScript module loaders (e.g. Node.js).
  &lt;script src=&quot;../js/flatbuffers.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;monster_generated.js&quot;&gt;&lt;/script&gt; // Generated by `flatc`.
</code></pre>
</div>
<div class="language-typescript">
~~~{.ts}
  // note: import flatbuffers with your desired import method
<p>import { MyGame } from './monster_generated';</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-php&quot;&gt;
~~~{.php}
  // It is recommended that your use PSR autoload when using FlatBuffers in PHP.
  // Here is an example from `SampleBinary.php`:
  function __autoload($class_name) {
    // The last segment of the class name matches the file name.
    $class = substr($class_name, strrpos($class_name, &quot;\\&quot;) + 1);
    $root_dir = join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)))); // `flatbuffers` root.

    // Contains the `*.php` files for the FlatBuffers library and the `flatc` generated files.
    $paths = array(join(DIRECTORY_SEPARATOR, array($root_dir, &quot;php&quot;)),
                   join(DIRECTORY_SEPARATOR, array($root_dir, &quot;samples&quot;, &quot;MyGame&quot;, &quot;Sample&quot;)));
    foreach ($paths as $path) {
      $file = join(DIRECTORY_SEPARATOR, array($path, $class . &quot;.php&quot;));
      if (file_exists($file)) {
        require($file);
        break;
      }
    }
  }
</code></pre>
</div>
<div class="language-c">
~~~{.c}
  #include "monster_builder.h" // Generated by `flatcc`.
<p>// Convenient namespace macro to manage long namespace prefix.
#undef ns
#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(MyGame_Sample, x) // Specified in the schema.</p>
<p>// A helper to simplify creating vectors from C-arrays.
#define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-dart&quot;&gt;
~~~{.dart}
  import 'package:flat_buffers/flat_buffers.dart' as fb;

  // Generated by `flatc`.
  import 'monster_my_game.sample_generated.dart' as myGame;
</code></pre>
</div>
<div class="language-lua">
~~~{.lua}
  -- require the flatbuffers module
  local flatbuffers = require("flatbuffers")
<p>-- require the generated files from <code>flatc</code>.
local color = require(&quot;MyGame.Sample.Color&quot;)
local equipment = require(&quot;MyGame.Sample.Equipment&quot;)
local monster = require(&quot;MyGame.Sample.Monster&quot;)
local vec3 = require(&quot;MyGame.Sample.Vec3&quot;)
local weapon = require(&quot;MyGame.Sample.Weapon&quot;)</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-lobster&quot;&gt;
~~~{.lobster}
  import from &quot;../lobster/&quot;  // Where to find flatbuffers.lobster
  import monster_generated
</code></pre>
</div>
<div class="language-rust">
~~~{.rs}
  // import the flatbuffers runtime library
  extern crate flatbuffers;
<p>// import the generated code
#[allow(dead_code, unused_imports)]
#[path = &quot;./monster_generated.rs&quot;]
mod monster_generated;
pub use monster_generated::my_game::sample::{get_root_as_monster,
Color, Equipment,
Monster, MonsterArgs,
Vec3,
Weapon, WeaponArgs};</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-swift&quot;&gt;
~~~{.swift}
  /**
  // make sure that monster_generated.swift is included in your project
  */
  import Flatbuffers

  // typealiases for convenience
  typealias Monster = MyGame1_Sample_Monster
  typealias Weapon = MyGame1_Sample_Weapon
  typealias Color = MyGame1_Sample_Color
  typealias Vec3 = MyGame1_Sample_Vec3
</code></pre>
</div>
<p>Now we are ready to start building some buffers. In order to start, we need
to create an instance of the <code>FlatBufferBuilder</code>, which will contain the buffer
as it grows. You can pass an initial size of the buffer (here 1024 bytes),
which will grow automatically if needed:</p>
<div class="language-cpp">
~~~{.cpp}
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  flatbuffers::FlatBufferBuilder builder(1024);
~~~
</div>
<div class="language-java">
~~~{.java}
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  FlatBufferBuilder builder = new FlatBufferBuilder(1024);
~~~
</div>
<div class="language-kotlin">
~~~{.kt}
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  val builder = FlatBufferBuilder(1024)
~~~
</div>
<div class="language-csharp">
~~~{.cs}
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  var builder = new FlatBufferBuilder(1024);
~~~
</div>
<div class="language-go">
~~~{.go}
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  builder := flatbuffers.NewBuilder(1024)
~~~
</div>
<div class="language-python">
~~~{.py}
  # Create a `FlatBufferBuilder`, which will be used to create our
  # monsters' FlatBuffers.
  builder = flatbuffers.Builder(1024)
~~~
</div>
<div class="language-javascript">
~~~{.js}
  // Create a `flatbuffer.Builder`, which will be used to create our
  // monsters' FlatBuffers.
  var builder = new flatbuffers.Builder(1024);
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  // Create a `flatbuffer.Builder`, which will be used to create our
  // monsters' FlatBuffers.
  let builder = new flatbuffers.Builder(1024);
~~~
</div>
<div class="language-php">
~~~{.php}
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  $builder = new Google\FlatBuffers\FlatbufferBuilder(1024);
~~~
</div>
<div class="language-c">
~~~{.c}
    flatcc_builder_t builder, *B;
    B = &builder;
    // Initialize the builder object.
    flatcc_builder_init(B);
~~~
</div>
<div class="language-dart">
~~~{.dart}
  // Create the fb.Builder object that will be used by our generated builders
  // Note that if you are only planning to immediately get the byte array this builder would create,
  // you can use the convenience method `toBytes()` on the generated builders.
  // For example, you could do something like `new myGame.MonsterBuilder(...).toBytes()`
  var builder = new fb.Builder(initialSize: 1024);
~~~
</div>
<div class="language-lua">
~~~{.lua}
  -- get access to the builder, providing an array of size 1024
  local builder = flatbuffers.Builder(1024)
~~~
</div>
<div class="language-lobster">
~~~{.lobster}
  // get access to the builder
  let builder = flatbuffers_builder {}
~~~
</div>
<div class="language-rust">
~~~{.rs}
  // Build up a serialized buffer algorithmically.
  // Initialize it with a capacity of 1024 bytes.
  let mut builder = flatbuffers::FlatBufferBuilder::new_with_capacity(1024);
~~~
</div>
<div class="language-swift">
~~~{.swift}
  // create a `FlatBufferBuilder`, which will be used to serialize objects
  let builder = FlatBufferBuilder(initialSize: 1024)
~~~
</div>
<p>After creating the <code>builder</code>, we can start serializing our data. Before we make
our <code>orc</code> Monster, let's create some <code>Weapon</code>s: a <code>Sword</code> and an <code>Axe</code>.</p>
<div class="language-cpp">
~~~{.cpp}
  auto weapon_one_name = builder.CreateString("Sword");
  short weapon_one_damage = 3;
<p>auto weapon_two_name = builder.CreateString(&quot;Axe&quot;);
short weapon_two_damage = 5;</p>
<p>// Use the <code>CreateWeapon</code> shortcut to create Weapons with all the fields set.
auto sword = CreateWeapon(builder, weapon_one_name, weapon_one_damage);
auto axe = CreateWeapon(builder, weapon_two_name, weapon_two_damage);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-java&quot;&gt;
~~~{.java}
  int weaponOneName = builder.createString(&quot;Sword&quot;)
  short weaponOneDamage = 3;

  int weaponTwoName = builder.createString(&quot;Axe&quot;);
  short weaponTwoDamage = 5;

  // Use the `createWeapon()` helper function to create the weapons, since we set every field.
  int sword = Weapon.createWeapon(builder, weaponOneName, weaponOneDamage);
  int axe = Weapon.createWeapon(builder, weaponTwoName, weaponTwoDamage);
</code></pre>
</div>
<div class="language-kotlin">
~~~{.kt}
  val weaponOneName = builder.createString("Sword")
  val weaponOneDamage: Short = 3;
<p>val weaponTwoName = builder.createString(&quot;Axe&quot;)
val weaponTwoDamage: Short = 5;</p>
<p>// Use the <code>createWeapon()</code> helper function to create the weapons, since we set every field.
val sword = Weapon.createWeapon(builder, weaponOneName, weaponOneDamage)
val axe = Weapon.createWeapon(builder, weaponTwoName, weaponTwoDamage)</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-csharp&quot;&gt;
~~~{.cs}
  var weaponOneName = builder.CreateString(&quot;Sword&quot;);
  var weaponOneDamage = 3;

  var weaponTwoName = builder.CreateString(&quot;Axe&quot;);
  var weaponTwoDamage = 5;

  // Use the `CreateWeapon()` helper function to create the weapons, since we set every field.
  var sword = Weapon.CreateWeapon(builder, weaponOneName, (short)weaponOneDamage);
  var axe = Weapon.CreateWeapon(builder, weaponTwoName, (short)weaponTwoDamage);
</code></pre>
</div>
<div class="language-go">
~~~{.go}
  weaponOne := builder.CreateString("Sword")
  weaponTwo := builder.CreateString("Axe")
<p>// Create the first <code>Weapon</code> (&quot;Sword&quot;).
sample.WeaponStart(builder)
sample.WeaponAddName(builder, weaponOne)
sample.WeaponAddDamage(builder, 3)
sword := sample.WeaponEnd(builder)</p>
<p>// Create the second <code>Weapon</code> (&quot;Axe&quot;).
sample.WeaponStart(builder)
sample.WeaponAddName(builder, weaponTwo)
sample.WeaponAddDamage(builder, 5)
axe := sample.WeaponEnd(builder)</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-python&quot;&gt;
~~~{.py}
  weapon_one = builder.CreateString('Sword')
  weapon_two = builder.CreateString('Axe')

  # Create the first `Weapon` ('Sword').
  MyGame.Sample.Weapon.Start(builder)
  MyGame.Sample.Weapon.AddName(builder, weapon_one)
  MyGame.Sample.Weapon.AddDamage(builder, 3)
  sword = MyGame.Sample.Weapon.End(builder)

  # Create the second `Weapon` ('Axe').
  MyGame.Sample.Weapon.Start(builder)
  MyGame.Sample.Weapon.AddName(builder, weapon_two)
  MyGame.Sample.Weapon.AddDamage(builder, 5)
  axe = MyGame.Sample.Weapon.End(builder)
</code></pre>
</div>
<div class="language-javascript">
~~~{.js}
  var weaponOne = builder.createString('Sword');
  var weaponTwo = builder.createString('Axe');
<p>// Create the first <code>Weapon</code> ('Sword').
MyGame.Sample.Weapon.startWeapon(builder);
MyGame.Sample.Weapon.addName(builder, weaponOne);
MyGame.Sample.Weapon.addDamage(builder, 3);
var sword = MyGame.Sample.Weapon.endWeapon(builder);</p>
<p>// Create the second <code>Weapon</code> ('Axe').
MyGame.Sample.Weapon.startWeapon(builder);
MyGame.Sample.Weapon.addName(builder, weaponTwo);
MyGame.Sample.Weapon.addDamage(builder, 5);
var axe = MyGame.Sample.Weapon.endWeapon(builder);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-typescript&quot;&gt;
~~~{.ts}
  let weaponOne = builder.createString('Sword');
  let weaponTwo = builder.createString('Axe');

  // Create the first `Weapon` ('Sword').
  MyGame.Sample.Weapon.startWeapon(builder);
  MyGame.Sample.Weapon.addName(builder, weaponOne);
  MyGame.Sample.Weapon.addDamage(builder, 3);
  let sword = MyGame.Sample.Weapon.endWeapon(builder);

  // Create the second `Weapon` ('Axe').
  MyGame.Sample.Weapon.startWeapon(builder);
  MyGame.Sample.Weapon.addName(builder, weaponTwo);
  MyGame.Sample.Weapon.addDamage(builder, 5);
  let axe = MyGame.Sample.Weapon.endWeapon(builder);
</code></pre>
</div>
<div class="language-php">
~~~{.php}
  // Create the `Weapon`s using the `createWeapon()` helper function.
  $weapon_one_name = $builder->createString("Sword");
  $sword = \MyGame\Sample\Weapon::CreateWeapon($builder, $weapon_one_name, 3);
<p>$weapon_two_name = $builder-&gt;createString(&quot;Axe&quot;);
$axe = \MyGame\Sample\Weapon::CreateWeapon($builder, $weapon_two_name, 5);</p>
<p>// Create an array from the two <code>Weapon</code>s and pass it to the
// <code>CreateWeaponsVector()</code> method to create a FlatBuffer vector.
$weaps = array($sword, $axe);
$weapons = \MyGame\Sample\Monster::CreateWeaponsVector($builder, $weaps);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-c&quot;&gt;
~~~{.c}
  flatbuffers_string_ref_t weapon_one_name = flatbuffers_string_create_str(B, &quot;Sword&quot;);
  uint16_t weapon_one_damage = 3;

  flatbuffers_string_ref_t weapon_two_name = flatbuffers_string_create_str(B, &quot;Axe&quot;);
  uint16_t weapon_two_damage = 5;

  ns(Weapon_ref_t) sword = ns(Weapon_create(B, weapon_one_name, weapon_one_damage));
  ns(Weapon_ref_t) axe = ns(Weapon_create(B, weapon_two_name, weapon_two_damage));
</code></pre>
</div>
<div class="language-dart">
~~~{.dart}
  // The generated Builder classes work much like in other languages,
  final int weaponOneName = builder.writeString("Sword");
  final int weaponOneDamage = 3;
<p>final int weaponTwoName = builder.writeString(&quot;Axe&quot;);
final int weaponTwoDamage = 5;</p>
<p>final swordBuilder = new myGame.WeaponBuilder(builder)
..begin()
..addNameOffset(weaponOneName)
..addDamage(weaponOneDamage);
final int sword = swordBuilder.finish();</p>
<p>final axeBuilder = new myGame.WeaponBuilder(builder)
..begin()
..addNameOffset(weaponTwoName)
..addDamage(weaponTwoDamage);
final int axe = axeBuilder.finish();</p>
<p>// The generated ObjectBuilder classes offer an easier to use alternative
// at the cost of requiring some additional reference allocations. If memory
// usage is critical, or if you'll be working with especially large messages
// or tables, you should prefer using the generated Builder classes.
// The following code would produce an identical buffer as above.
final String weaponOneName = &quot;Sword&quot;;
final int weaponOneDamage = 3;</p>
<p>final String weaponTwoName = &quot;Axe&quot;;
final int weaponTwoDamage = 5;</p>
<p>final myGame.WeaponBuilder sword = new myGame.WeaponObjectBuilder(
name: weaponOneName,
damage: weaponOneDamage,
);</p>
<p>final myGame.WeaponBuilder axe = new myGame.WeaponObjectBuilder(
name: weaponTwoName,
damage: weaponTwoDamage,
);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-lua&quot;&gt;
~~~{.lua}
    local weaponOne = builder:CreateString(&quot;Sword&quot;)
    local weaponTwo = builder:CreateString(&quot;Axe&quot;)

    -- Create the first 'Weapon'
    weapon.Start(builder)
    weapon.AddName(builder, weaponOne)
    weapon.AddDamage(builder, 3)
    local sword = weapon.End(builder)

    -- Create the second 'Weapon'
    weapon.Start(builder)
    weapon.AddName(builder, weaponTwo)
    weapon.AddDamage(builder, 5)
    local axe = weapon.End(builder)
</code></pre>
</div>
<div class="language-lobster">
~~~{.lobster}
  let weapon_names = [ "Sword", "Axe" ]
  let weapon_damages = [ 3, 5 ]
<p>let weapon_offsets = map(weapon_names) name, i:
let ns = builder.CreateString(name)
MyGame_Sample_WeaponBuilder { b }
.start()
.add_name(ns)
.add_damage(weapon_damages[i])
.end()</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-rust&quot;&gt;
~~~{.rs}
  // Serialize some weapons for the Monster: A 'sword' and an 'axe'.
  let weapon_one_name = builder.create_string(&quot;Sword&quot;);
  let weapon_two_name = builder.create_string(&quot;Axe&quot;);

  // Use the `Weapon::create` shortcut to create Weapons with named field
  // arguments.
  let sword = Weapon::create(&amp;mut builder, &amp;WeaponArgs{
      name: Some(weapon_one_name),
      damage: 3,
  });
  let axe = Weapon::create(&amp;mut builder, &amp;WeaponArgs{
      name: Some(weapon_two_name),
      damage: 5,
  });
</code></pre>
</div>
<div class="language-swift">
~~~{.swift}
  let weapon1Name = builder.create(string: "Sword")
  let weapon2Name = builder.create(string: "Axe")
<p>// start creating the weapon by calling startWeapon
let weapon1Start = Weapon.startWeapon(&amp;builder)
Weapon.add(name: weapon1Name, &amp;builder)
Weapon.add(damage: 3, &amp;builder)
// end the object by passing the start point for the weapon 1
let sword = Weapon.endWeapon(&amp;builder, start: weapon1Start)</p>
<p>let weapon2Start = Weapon.startWeapon(&amp;builder)
Weapon.add(name: weapon2Name, &amp;builder)
Weapon.add(damage: 5, &amp;builder)
let axe = Weapon.endWeapon(&amp;builder, start: weapon2Start)</p>
<pre><code>&lt;/div&gt;

Now let's create our monster, the `orc`. For this `orc`, lets make him
`red` with rage, positioned at `(1.0, 2.0, 3.0)`, and give him
a large pool of hit points with `300`. We can give him a vector of weapons
to choose from (our `Sword` and `Axe` from earlier). In this case, we will
equip him with the `Axe`, since it is the most powerful of the two. Lastly,
let's fill his inventory with some potential treasures that can be taken once he
is defeated.

Before we serialize a monster, we need to first serialize any objects that are
contained therein, i.e. we serialize the data tree using depth-first, pre-order
traversal. This is generally easy to do on any tree structures.

&lt;div class=&quot;language-cpp&quot;&gt;
~~~{.cpp}
  // Serialize a name for our monster, called &quot;Orc&quot;.
  auto name = builder.CreateString(&quot;Orc&quot;);

  // Create a `vector` representing the inventory of the Orc. Each number
  // could correspond to an item that can be claimed after he is slain.
  unsigned char treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  auto inventory = builder.CreateVector(treasure, 10);
</code></pre>
</div>
<div class="language-java">
~~~{.java}
  // Serialize a name for our monster, called "Orc".
  int name = builder.createString("Orc");
<p>// Create a <code>vector</code> representing the inventory of the Orc. Each number
// could correspond to an item that can be claimed after he is slain.
byte[] treasure = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int inv = Monster.createInventoryVector(builder, treasure);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-kotlin&quot;&gt;
~~~{.kt}
  // Serialize a name for our monster, called &quot;Orc&quot;.
  val name = builder.createString(&quot;Orc&quot;)

  // Create a `vector` representing the inventory of the Orc. Each number
  // could correspond to an item that can be claimed after he is slain.
  val treasure = byteArrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
  val inv = Monster.createInventoryVector(builder, treasure)
</code></pre>
</div>
<div class="language-csharp">
~~~{.cs}
  // Serialize a name for our monster, called "Orc".
  var name = builder.CreateString("Orc");
<p>// Create a <code>vector</code> representing the inventory of the Orc. Each number
// could correspond to an item that can be claimed after he is slain.
// Note: Since we prepend the bytes, this loop iterates in reverse order.
Monster.StartInventoryVector(builder, 10);
for (int i = 9; i &gt;= 0; i--)
{
builder.AddByte((byte)i);
}
var inv = builder.EndVector();</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-go&quot;&gt;
~~~{.go}
  // Serialize a name for our monster, called &quot;Orc&quot;.
  name := builder.CreateString(&quot;Orc&quot;)

  // Create a `vector` representing the inventory of the Orc. Each number
  // could correspond to an item that can be claimed after he is slain.
  // Note: Since we prepend the bytes, this loop iterates in reverse.
  sample.MonsterStartInventoryVector(builder, 10)
  for i := 9; i &gt;= 0; i-- {
          builder.PrependByte(byte(i))
  }
  inv := builder.EndVector(10)
</code></pre>
</div>
<div class="language-python">
~~~{.py}
  # Serialize a name for our monster, called "Orc".
  name = builder.CreateString("Orc")
<h1 id="create-a-vector-representing-the-inventory-of-the-orc-each-number"><a class="header" href="#create-a-vector-representing-the-inventory-of-the-orc-each-number">Create a <code>vector</code> representing the inventory of the Orc. Each number</a></h1>
<h1 id="could-correspond-to-an-item-that-can-be-claimed-after-he-is-slain"><a class="header" href="#could-correspond-to-an-item-that-can-be-claimed-after-he-is-slain">could correspond to an item that can be claimed after he is slain.</a></h1>
<h1 id="note-since-we-prepend-the-bytes-this-loop-iterates-in-reverse"><a class="header" href="#note-since-we-prepend-the-bytes-this-loop-iterates-in-reverse">Note: Since we prepend the bytes, this loop iterates in reverse.</a></h1>
<p>MyGame.Sample.Monster.StartInventoryVector(builder, 10)
for i in reversed(range(0, 10)):
builder.PrependByte(i)
inv = builder.EndVector()</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-javascript&quot;&gt;
~~~{.js}
  // Serialize a name for our monster, called 'Orc'.
  var name = builder.createString('Orc');

  // Create a `vector` representing the inventory of the Orc. Each number
  // could correspond to an item that can be claimed after he is slain.
  var treasure = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  var inv = MyGame.Sample.Monster.createInventoryVector(builder, treasure);
</code></pre>
</div>
<div class="language-typescript">
~~~{.ts}
  // Serialize a name for our monster, called 'Orc'.
  let name = builder.createString('Orc');
<p>// Create a <code>vector</code> representing the inventory of the Orc. Each number
// could correspond to an item that can be claimed after he is slain.
let treasure = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
let inv = MyGame.Sample.Monster.createInventoryVector(builder, treasure);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-php&quot;&gt;
~~~{.php}
  // Serialize a name for our monster, called &quot;Orc&quot;.
  $name = $builder-&gt;createString(&quot;Orc&quot;);

  // Create a `vector` representing the inventory of the Orc. Each number
  // could correspond to an item that can be claimed after he is slain.
  $treasure = array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
  $inv = \MyGame\Sample\Monster::CreateInventoryVector($builder, $treasure);
</code></pre>
</div>
<div class="language-c">
~~~{.c}
  // Serialize a name for our monster, called "Orc".
  // The _str suffix indicates the source is an ascii-z string.
  flatbuffers_string_ref_t name = flatbuffers_string_create_str(B, "Orc");
<p>// Create a <code>vector</code> representing the inventory of the Orc. Each number
// could correspond to an item that can be claimed after he is slain.
uint8_t treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
flatbuffers_uint8_vec_ref_t inventory;
// <code>c_vec_len</code> is the convenience macro we defined earlier.
inventory = flatbuffers_uint8_vec_create(B, treasure, c_vec_len(treasure));</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-dart&quot;&gt;
~~~{.dart}
  // Serialize a name for our monster, called &quot;Orc&quot;.
  final int name = builder.writeString('Orc');

  // Create a list representing the inventory of the Orc. Each number
  // could correspond to an item that can be claimed after he is slain.
  final List&lt;int&gt; treasure = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  final inventory = builder.writeListUint8(treasure);

  // The following code should be used instead if you intend to use the
  // ObjectBuilder classes:
  // Serialize a name for our monster, called &quot;Orc&quot;.
  final String name = 'Orc';

  // Create a list representing the inventory of the Orc. Each number
  // could correspond to an item that can be claimed after he is slain.
  final List&lt;int&gt; treasure = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
</code></pre>
</div>
<div class="language-lua">
~~~{.py}
    -- Serialize a name for our monster, called 'orc'
    local name = builder:CreateString("Orc")
<pre><code>-- Create a `vector` representing the inventory of the Orc. Each number
-- could correspond to an item that can be claimed after he is slain.
-- Note: Since we prepend the bytes, this loop iterates in reverse.
monster.StartInventoryVector(builder, 10)
for i=10,1,-1 do
    builder:PrependByte(i)
end
local inv = builder:EndVector(10)
</code></pre>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-lobster&quot;&gt;
~~~{.lobster}
  // Name of the monster.
  let name = builder.CreateString(&quot;Orc&quot;)

  // Inventory.
  let inv = builder.MyGame_Sample_MonsterCreateInventoryVector(map(10): _)
</code></pre>
</div>
<div class="language-rust">
~~~{.rs}
  // Name of the Monster.
  let name = builder.create_string("Orc");
<p>// Inventory.
let inventory = builder.create_vector(&amp;[0u8, 1, 2, 3, 4, 5, 6, 7, 8, 9]);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-swift&quot;&gt;
~~~{.swift}
  // Name of the Monster.
  let name = builder.create(string: &quot;Orc&quot;)

  // create inventory
  let inventory: [Byte] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  let inventoryOffset = builder.createVector(inventory)
</code></pre>
</div>
<p>We serialized two built-in data types (<code>string</code> and <code>vector</code>) and captured
their return values. These values are offsets into the serialized data,
indicating where they are stored, such that we can refer to them below when
adding fields to our monster.</p>
<p><em>Note: To create a <code>vector</code> of nested objects (e.g. <code>table</code>s, <code>string</code>s, or
other <code>vector</code>s), collect their offsets into a temporary data structure, and
then create an additional <code>vector</code> containing their offsets.</em></p>
<p>If instead of creating a vector from an existing array you serialize elements
individually one by one, take care to note that this happens in reverse order,
as buffers are built back to front.</p>
<p>For example, take a look at the two <code>Weapon</code>s that we created earlier (<code>Sword</code>
and <code>Axe</code>). These are both FlatBuffer <code>table</code>s, whose offsets we now store in
memory. Therefore we can create a FlatBuffer <code>vector</code> to contain these
offsets.</p>
<div class="language-cpp">
~~~{.cpp}
  // Place the weapons into a `std::vector`, then convert that into a FlatBuffer `vector`.
  std::vector<flatbuffers::Offset<Weapon>> weapons_vector;
  weapons_vector.push_back(sword);
  weapons_vector.push_back(axe);
  auto weapons = builder.CreateVector(weapons_vector);
~~~
</div>
<div class="language-java">
~~~{.java}
  // Place the two weapons into an array, and pass it to the `createWeaponsVector()` method to
  // create a FlatBuffer vector.
  int[] weaps = new int[2];
  weaps[0] = sword;
  weaps[1] = axe;
<p>// Pass the <code>weaps</code> array into the <code>createWeaponsVector()</code> method to create a FlatBuffer vector.
int weapons = Monster.createWeaponsVector(builder, weaps);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-kotlin&quot;&gt;
~~~{.kt}
  // Place the two weapons into an array, and pass it to the `createWeaponsVector()` method to
  // create a FlatBuffer vector.
  val weaps = intArrayOf(sword, axe)

  // Pass the `weaps` array into the `createWeaponsVector()` method to create a FlatBuffer vector.
  val weapons = Monster.createWeaponsVector(builder, weaps)
</code></pre>
</div>
<div class="language-csharp">
~~~{.cs}
  var weaps = new Offset<Weapon>[2];
  weaps[0] = sword;
  weaps[1] = axe;
<p>// Pass the <code>weaps</code> array into the <code>CreateWeaponsVector()</code> method to create a FlatBuffer vector.
var weapons = Monster.CreateWeaponsVector(builder, weaps);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-go&quot;&gt;
~~~{.go}
  // Create a FlatBuffer vector and prepend the weapons.
  // Note: Since we prepend the data, prepend them in reverse order.
  sample.MonsterStartWeaponsVector(builder, 2)
  builder.PrependUOffsetT(axe)
  builder.PrependUOffsetT(sword)
  weapons := builder.EndVector(2)
</code></pre>
</div>
<div class="language-python">
~~~{.py}
  # Create a FlatBuffer vector and prepend the weapons.
  # Note: Since we prepend the data, prepend them in reverse order.
  MyGame.Sample.Monster.StartWeaponsVector(builder, 2)
  builder.PrependUOffsetTRelative(axe)
  builder.PrependUOffsetTRelative(sword)
  weapons = builder.EndVector()
~~~
</div>
<div class="language-javascript">
~~~{.js}
  // Create an array from the two `Weapon`s and pass it to the
  // `createWeaponsVector()` method to create a FlatBuffer vector.
  var weaps = [sword, axe];
  var weapons = MyGame.Sample.Monster.createWeaponsVector(builder, weaps);
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  // Create an array from the two `Weapon`s and pass it to the
  // `createWeaponsVector()` method to create a FlatBuffer vector.
  let weaps = [sword, axe];
  let weapons = MyGame.Sample.Monster.createWeaponsVector(builder, weaps);
~~~
</div>
<div class="language-php">
~~~{.php}
  // Create an array from the two `Weapon`s and pass it to the
  // `CreateWeaponsVector()` method to create a FlatBuffer vector.
  $weaps = array($sword, $axe);
  $weapons = \MyGame\Sample\Monster::CreateWeaponsVector($builder, $weaps);
~~~
</div>
<div class="language-c">
~~~{.c}
  // We use the internal builder stack to implement a dynamic vector.
  ns(Weapon_vec_start(B));
  ns(Weapon_vec_push(B, sword));
  ns(Weapon_vec_push(B, axe));
  ns(Weapon_vec_ref_t) weapons = ns(Weapon_vec_end(B));
~~~
</div>
<div class="language-dart">
~~~{.dart}
  // If using the Builder classes, serialize the `[sword,axe]`
  final weapons = builder.writeList([sword, axe]);
<p>// If using the ObjectBuilders, just create an array from the two <code>Weapon</code>s
final List&lt;myGame.WeaponBuilder&gt; weaps = [sword, axe];</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-lua&quot;&gt;
~~~{.lua}
    -- Create a FlatBuffer vector and prepend the weapons.
    -- Note: Since we prepend the data, prepend them in reverse order.
    monster.StartWeaponsVector(builder, 2)
    builder:PrependUOffsetTRelative(axe)
    builder:PrependUOffsetTRelative(sword)
    local weapons = builder:EndVector(2)
</code></pre>
</div>
<div class="language-lobster">
~~~{.lobster}
  let weapons = builder.MyGame_Sample_MonsterCreateWeaponsVector(weapon_offsets)
~~~
</div>
<div class="language-rust">
~~~{.rs}
  // Create a FlatBuffer `vector` that contains offsets to the sword and axe
  // we created above.
  let weapons = builder.create_vector(&[sword, axe]);
~~~
</div>
<div class="language-swift">
~~~{.swift}
  // Create a FlatBuffer `vector` that contains offsets to the sword and axe
  // we created above.
  let weaponsOffset = builder.createVector(ofOffsets: [sword, axe])
~~~
</div>
<br>
Note there are additional convenience overloads of `CreateVector`, allowing you
to work with data that's not in a `std::vector` or allowing you to generate
elements by calling a lambda. For the common case of `std::vector<std::string>`
there's also `CreateVectorOfStrings`.
</div>
<p>Note that vectors of structs are serialized differently from tables, since
structs are stored in-line in the vector. For example, to create a vector
for the <code>path</code> field above:</p>
<div class="language-cpp">
~~~{.cpp}
  Vec3 points[] = { Vec3(1.0f, 2.0f, 3.0f), Vec3(4.0f, 5.0f, 6.0f) };
  auto path = builder.CreateVectorOfStructs(points, 2);
~~~
</div>
<div class="language-java">
~~~{.java}
  Monster.startPathVector(fbb, 2);
  Vec3.createVec3(builder, 1.0f, 2.0f, 3.0f);
  Vec3.createVec3(builder, 4.0f, 5.0f, 6.0f);
  int path = fbb.endVector();
~~~
</div>
<div class="language-kotlin">
~~~{.kt}
  Monster.startPathVector(fbb, 2)
  Vec3.createVec3(builder, 1.0f, 2.0f, 3.0f)
  Vec3.createVec3(builder, 4.0f, 5.0f, 6.0f)
  val path = fbb.endVector()
~~~
</div>
<div class="language-csharp">
~~~{.cs}
  Monster.StartPathVector(fbb, 2);
  Vec3.CreateVec3(builder, 1.0f, 2.0f, 3.0f);
  Vec3.CreateVec3(builder, 4.0f, 5.0f, 6.0f);
  var path = fbb.EndVector();
~~~
</div>
<div class="language-go">
~~~{.go}
  sample.MonsterStartPathVector(builder, 2)
  sample.CreateVec3(builder, 1.0, 2.0, 3.0)
  sample.CreateVec3(builder, 4.0, 5.0, 6.0)
  path := builder.EndVector(2)
~~~
</div>
<div class="language-python">
~~~{.py}
  MyGame.Sample.Monster.StartPathVector(builder, 2)
  MyGame.Sample.Vec3.CreateVec3(builder, 1.0, 2.0, 3.0)
  MyGame.Sample.Vec3.CreateVec3(builder, 4.0, 5.0, 6.0)
  path = builder.EndVector()
~~~
</div>
<div class="language-javascript">
~~~{.js}
  MyGame.Sample.Monster.startPathVector(builder, 2);
  MyGame.Sample.Vec3.createVec3(builder, 1.0, 2.0, 3.0);
  MyGame.Sample.Vec3.createVec3(builder, 4.0, 5.0, 6.0);
  var path = builder.endVector();
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  MyGame.Sample.Monster.startPathVector(builder, 2);
  MyGame.Sample.Vec3.createVec3(builder, 1.0, 2.0, 3.0);
  MyGame.Sample.Vec3.createVec3(builder, 4.0, 5.0, 6.0);
  let path = builder.endVector();
~~~
</div>
<div class="language-php">
~~~{.php}
  \MyGame\Example\Monster::StartPathVector($builder, 2);
  \MyGame\Sample\Vec3::CreateVec3($builder, 1.0, 2.0, 3.0);
  \MyGame\Sample\Vec3::CreateVec3($builder, 1.0, 2.0, 3.0);
  $path = $builder->endVector();
~~~
</div>
<div class="language-c">
~~~{.c}
  // TBD
~~~
</div>
<div class="language-dart">
~~~{.dart}
  // Using the Builder classes, you can write a list of structs like so:
  // Note that the intended order should be reversed if order is important.
  final vec3Builder = new myGame.Vec3Builder(builder);
  vec3Builder.finish(4.0, 5.0, 6.0);
  vec3Builder.finish(1.0, 2.0, 3.0);
  final int path = builder.endStructVector(2); // the length of the vector
<p>// Otherwise, using the ObjectBuilder classes:
// The dart implementation provides a simple interface for writing vectors
// of structs, in <code>writeListOfStructs</code>. This method takes
// <code>List&lt;ObjectBuilder&gt;</code> and is used by the generated builder classes.
final List&lt;myGame.Vec3ObjectBuilder&gt; path = [
new myGame.Vec3ObjectBuilder(x: 1.0, y: 2.0, z: 3.0),
new myGame.Vec3ObjectBuilder(x: 4.0, y: 5.0, z: 6.0)
];</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-lua&quot;&gt;
~~~{.lua}
    -- Create a FlatBuffer vector and prepend the path locations.
    -- Note: Since we prepend the data, prepend them in reverse order.
    monster.StartPathVector(builder, 2)
    vec3.CreateVec3(builder, 1.0, 2.0, 3.0)
    vec3.CreateVec3(builder, 4.0, 5.0, 6.0)
    local path = builder:EndVector(2)
</code></pre>
</div>
<div class="language-lobster">
~~~{.lobster}
  builder.MyGame_Sample_MonsterStartPathVector(2)
  builder.MyGame_Sample_CreateVec3(1.0, 2.0, 3.0)
  builder.MyGame_Sample_CreateVec3(4.0, 5.0, 6.0)
  let path = builder.EndVector(2)
~~~
</div>
<div class="language-rust">
~~~{.rs}
  // Create the path vector of Vec3 objects.
  let x = Vec3::new(1.0, 2.0, 3.0);
  let y = Vec3::new(4.0, 5.0, 6.0);
  let path = builder.create_vector(&[x, y]);
<p>// Note that, for convenience, it is also valid to create a vector of
// references to structs, like this:
// let path = builder.create_vector(&amp;[&amp;x, &amp;y]);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-swift&quot;&gt;
~~~{.swift}
  //
  let points = fbb.createVector(ofStructs: [
    Vec3(x: 1, y: 2, z: 3),
    Vec3(x: 4, y: 5, z: 6)
  ])

  // OR
  var vec3 = [
    Vec3(x: 1, y: 2, z: 3),
    Vec3(x: 4, y: 5, z: 6)
  ]
  Monster.startVectorOfVec3(2, in: &amp;fbb)
  for i in obj {
    _ = create(struct: i)
  }
  let points = fbb.endVector(len: size)
</code></pre>
</div>
<p>We have now serialized the non-scalar components of the orc, so we
can serialize the monster itself:</p>
<div class="language-cpp">
~~~{.cpp}
  // Create the position struct
  auto position = Vec3(1.0f, 2.0f, 3.0f);
<p>// Set his hit points to 300 and his mana to 150.
int hp = 300;
int mana = 150;</p>
<p>// Finally, create the monster using the <code>CreateMonster</code> helper function
// to set all fields.
auto orc = CreateMonster(builder, &amp;position, mana, hp, name, inventory,
Color_Red, weapons, Equipment_Weapon, axe.Union(),
path);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-java&quot;&gt;
~~~{.java}
  // Create our monster using `startMonster()` and `endMonster()`.
  Monster.startMonster(builder);
  Monster.addPos(builder, Vec3.createVec3(builder, 1.0f, 2.0f, 3.0f));
  Monster.addName(builder, name);
  Monster.addColor(builder, Color.Red);
  Monster.addHp(builder, (short)300);
  Monster.addInventory(builder, inv);
  Monster.addWeapons(builder, weapons);
  Monster.addEquippedType(builder, Equipment.Weapon);
  Monster.addEquipped(builder, axe);
  Monster.addPath(builder, path);
  int orc = Monster.endMonster(builder);
</code></pre>
</div>
<div class="language-kotlin">
~~~{.kt}
  // Create our monster using `startMonster()` and `endMonster()`.
  Monster.startMonster(builder)
  Monster.addPos(builder, Vec3.createVec3(builder, 1.0f, 2.0f, 3.0f))
  Monster.addName(builder, name)
  Monster.addColor(builder, Color.Red)
  Monster.addHp(builder, 300.toShort())
  Monster.addInventory(builder, inv)
  Monster.addWeapons(builder, weapons)
  Monster.addEquippedType(builder, Equipment.Weapon)
  Monster.addEquipped(builder, axe)
  Monster.addPath(builder, path)
  val orc = Monster.endMonster(builder)
~~~
</div>
<div class="language-csharp">
~~~{.cs}
  // Create our monster using `StartMonster()` and `EndMonster()`.
  Monster.StartMonster(builder);
  Monster.AddPos(builder, Vec3.CreateVec3(builder, 1.0f, 2.0f, 3.0f));
  Monster.AddHp(builder, (short)300);
  Monster.AddName(builder, name);
  Monster.AddInventory(builder, inv);
  Monster.AddColor(builder, Color.Red);
  Monster.AddWeapons(builder, weapons);
  Monster.AddEquippedType(builder, Equipment.Weapon);
  Monster.AddEquipped(builder, axe.Value); // Axe
  Monster.AddPath(builder, path);
  var orc = Monster.EndMonster(builder);
~~~
</div>
<div class="language-go">
~~~{.go}
  // Create our monster using `MonsterStart()` and `MonsterEnd()`.
  sample.MonsterStart(builder)
  sample.MonsterAddPos(builder, sample.CreateVec3(builder, 1.0, 2.0, 3.0))
  sample.MonsterAddHp(builder, 300)
  sample.MonsterAddName(builder, name)
  sample.MonsterAddInventory(builder, inv)
  sample.MonsterAddColor(builder, sample.ColorRed)
  sample.MonsterAddWeapons(builder, weapons)
  sample.MonsterAddEquippedType(builder, sample.EquipmentWeapon)
  sample.MonsterAddEquipped(builder, axe)
  sample.MonsterAddPath(builder, path)
  orc := sample.MonsterEnd(builder)
~~~
</div>
<div class="language-python">
~~~{.py}
  # Create our monster by using `Monster.Start()` and `Monster.End()`.
  MyGame.Sample.Monster.Start(builder)
  MyGame.Sample.Monster.AddPos(builder,
                          MyGame.Sample.Vec3.CreateVec3(builder, 1.0, 2.0, 3.0))
  MyGame.Sample.Monster.AddHp(builder, 300)
  MyGame.Sample.Monster.AddName(builder, name)
  MyGame.Sample.Monster.AddInventory(builder, inv)
  MyGame.Sample.Monster.AddColor(builder,
                                        MyGame.Sample.Color.Color().Red)
  MyGame.Sample.Monster.AddWeapons(builder, weapons)
  MyGame.Sample.Monster.AddEquippedType(
      builder, MyGame.Sample.Equipment.Equipment().Weapon)
  MyGame.Sample.Monster.AddEquipped(builder, axe)
  MyGame.Sample.Monster.AddPath(builder, path)
  orc = MyGame.Sample.Monster.End(builder)
~~~
</div>
<div class="language-javascript">
~~~{.js}
  // Create our monster by using `startMonster()` and `endMonster()`.
  MyGame.Sample.Monster.startMonster(builder);
  MyGame.Sample.Monster.addPos(builder,
                         MyGame.Sample.Vec3.createVec3(builder, 1.0, 2.0, 3.0));
  MyGame.Sample.Monster.addHp(builder, 300);
  MyGame.Sample.Monster.addColor(builder, MyGame.Sample.Color.Red)
  MyGame.Sample.Monster.addName(builder, name);
  MyGame.Sample.Monster.addInventory(builder, inv);
  MyGame.Sample.Monster.addWeapons(builder, weapons);
  MyGame.Sample.Monster.addEquippedType(builder, MyGame.Sample.Equipment.Weapon);
  MyGame.Sample.Monster.addEquipped(builder, axe);
  MyGame.Sample.Monster.addPath(builder, path);
  var orc = MyGame.Sample.Monster.endMonster(builder);
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  // Create our monster by using `startMonster()` and `endMonster()`.
  MyGame.Sample.Monster.startMonster(builder);
  MyGame.Sample.Monster.addPos(builder,
                         MyGame.Sample.Vec3.createVec3(builder, 1.0, 2.0, 3.0));
  MyGame.Sample.Monster.addHp(builder, 300);
  MyGame.Sample.Monster.addColor(builder, MyGame.Sample.Color.Red)
  MyGame.Sample.Monster.addName(builder, name);
  MyGame.Sample.Monster.addInventory(builder, inv);
  MyGame.Sample.Monster.addWeapons(builder, weapons);
  MyGame.Sample.Monster.addEquippedType(builder, MyGame.Sample.Equipment.Weapon);
  MyGame.Sample.Monster.addEquipped(builder, axe);
  MyGame.Sample.Monster.addPath(builder, path);
  let orc = MyGame.Sample.Monster.endMonster(builder);
~~~
</div>
<div class="language-php">
~~~{.php}
  // Create our monster by using `StartMonster()` and `EndMonster()`.
  \MyGame\Sample\Monster::StartMonster($builder);
  \MyGame\Sample\Monster::AddPos($builder,
                      \MyGame\Sample\Vec3::CreateVec3($builder, 1.0, 2.0, 3.0));
  \MyGame\Sample\Monster::AddHp($builder, 300);
  \MyGame\Sample\Monster::AddName($builder, $name);
  \MyGame\Sample\Monster::AddInventory($builder, $inv);
  \MyGame\Sample\Monster::AddColor($builder, \MyGame\Sample\Color::Red);
  \MyGame\Sample\Monster::AddWeapons($builder, $weapons);
  \MyGame\Sample\Monster::AddEquippedType($builder, \MyGame\Sample\Equipment::Weapon);
  \MyGame\Sample\Monster::AddEquipped($builder, $axe);
  \MyGame\Sample\Monster::AddPath($builder, $path);
  $orc = \MyGame\Sample\Monster::EndMonster($builder);
~~~
</div>
<div class="language-c">
~~~{.c}
  // Set his hit points to 300 and his mana to 150.
  uint16_t hp = 300;
  uint16_t mana = 150;
<p>// Define an equipment union. <code>create</code> calls in C has a single
// argument for unions where C++ has both a type and a data argument.
ns(Equipment_union_ref_t) equipped = ns(Equipment_as_Weapon(axe));
ns(Vec3_t) pos = { 1.0f, 2.0f, 3.0f };
ns(Monster_create_as_root(B, &amp;pos, mana, hp, name, inventory, ns(Color_Red),
weapons, equipped, path));</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-dart&quot;&gt;
~~~{.dart}
  // Using the Builder API:
  // Set his hit points to 300 and his mana to 150.
  final int hp = 300;
  final int mana = 150;

  final monster = new myGame.MonsterBuilder(builder)
    ..begin()
    ..addNameOffset(name)
    ..addInventoryOffset(inventory)
    ..addWeaponsOffset(weapons)
    ..addEquippedType(myGame.EquipmentTypeId.Weapon)
    ..addEquippedOffset(axe)
    ..addHp(hp)
    ..addMana(mana)
    ..addPos(vec3Builder.finish(1.0, 2.0, 3.0))
    ..addPathOffset(path)
    ..addColor(myGame.Color.Red);

  final int orc = monster.finish();

  // -Or- using the ObjectBuilder API:
  // Set his hit points to 300 and his mana to 150.
  final int hp = 300;
  final int mana = 150;

  // Note that these parameters are optional - it is not necessary to set
  // all of them.
  // Also note that it is not necessary to `finish` the builder helpers above
  // - the generated code will automatically reuse offsets if the same object
  // is used in more than one place (e.g. the axe appearing in `weapons` and
  // `equipped`).
  final myGame.MonsterBuilder orcBuilder = new myGame.MonsterBuilder(
    name: name,
    inventory: treasure,
    weapons: weaps,
    equippedType: myGame.EquipmentTypeId.Weapon,
    equipped: axe,
    path: path,
    hp: hp,
    mana: mana,
    pos: new myGame.Vec3Builder(x: 1.0, y: 2.0, z: 3.0),
    color: myGame.Color.Red,
    path: [
        new myGame.Vec3ObjectBuilder(x: 1.0, y: 2.0, z: 3.0),
        new myGame.Vec3ObjectBuilder(x: 4.0, y: 5.0, z: 6.0)
    ]);

  final int orc = orcBuilder.finish(builder);
</code></pre>
</div>
<div class="language-lua">
~~~{.lua}
    -- Create our monster by using Start() andEnd()
    monster.Start(builder)
    monster.AddPos(builder, vec3.CreateVec3(builder, 1.0, 2.0, 3.0))
    monster.AddHp(builder, 300)
    monster.AddName(builder, name)
    monster.AddInventory(builder, inv)
    monster.AddColor(builder, color.Red)
    monster.AddWeapons(builder, weapons)
    monster.AddEquippedType(builder, equipment.Weapon)
    monster.AddEquipped(builder, axe)
    monster.AddPath(builder, path)
    local orc = monster.End(builder)
~~~
</div>
<div class="language-lobster">
~~~{.lobster}
  let orc = MyGame_Sample_MonsterBuilder { b }
      .start()
      .add_pos(b.MyGame_Sample_CreateVec3(1.0, 2.0, 3.0))
      .add_hp(300)
      .add_name(name)
      .add_inventory(inv)
      .add_color(MyGame_Sample_Color_Red)
      .add_weapons(weapons)
      .add_equipped_type(MyGame_Sample_Equipment_Weapon)
      .add_equipped(weapon_offsets[1])
      .add_path(path)
      .end()
~~~
</div>
<div class="language-rust">
~~~{.rs}
  // Create the monster using the `Monster::create` helper function. This
  // function accepts a `MonsterArgs` struct, which supplies all of the data
  // needed to build a `Monster`. To supply empty/default fields, just use the
  // Rust built-in `Default::default()` function, as demonstrated below.
  let orc = Monster::create(&mut builder, &MonsterArgs{
      pos: Some(&Vec3::new(1.0f32, 2.0f32, 3.0f32)),
      mana: 150,
      hp: 80,
      name: Some(name),
      inventory: Some(inventory),
      color: Color::Red,
      weapons: Some(weapons),
      equipped_type: Equipment::Weapon,
      equipped: Some(axe.as_union_value()),
      path: Some(path),
      ..Default::default()
  });
~~~
</div>
<div class="language-swift">
~~~{.swift}
  let orc = Monster.createMonster(
    &builder,
    pos: MyGame_Sample_Vec3(x: 1, y: 2, z: 3),
    hp: 300,
    nameOffset: name,
    inventoryVectorOffset: inventoryOffset,
    color: .red,
    weaponsVectorOffset: weaponsOffset,
    equippedType: .weapon,
    equippedOffset: axe)
~~~
</div>
<p>Note how we create <code>Vec3</code> struct in-line in the table. Unlike tables, structs
are simple combinations of scalars that are always stored inline, just like
scalars themselves.</p>
<p><strong>Important</strong>: Unlike structs, you should not nest tables or other objects,
which is why we created all the strings/vectors/tables that this monster refers
to before <code>start</code>. If you try to create any of them between <code>start</code> and <code>end</code>,
you will get an assert/exception/panic depending on your language.</p>
<p><em>Note: Since we are passing <code>150</code> as the <code>mana</code> field, which happens to be the
default value, the field will not actually be written to the buffer, since the
default value will be returned on query anyway. This is a nice space savings,
especially if default values are common in your data. It also means that you do
not need to be worried about adding a lot of fields that are only used in a small
number of instances, as it will not bloat the buffer if unused.</em></p>
<div class="language-cpp">
<br>
If you do not wish to set every field in a `table`, it may be more convenient to
manually set each field of your monster, instead of calling `CreateMonster()`.
The following snippet is functionally equivalent to the above code, but provides
a bit more flexibility.
<br>
~~~{.cpp}
  // You can use this code instead of `CreateMonster()`, to create our orc
  // manually.
  MonsterBuilder monster_builder(builder);
  monster_builder.add_pos(&position);
  monster_builder.add_hp(hp);
  monster_builder.add_name(name);
  monster_builder.add_inventory(inventory);
  monster_builder.add_color(Color_Red);
  monster_builder.add_weapons(weapons);
  monster_builder.add_equipped_type(Equipment_Weapon);
  monster_builder.add_equipped(axe.Union());
  auto orc = monster_builder.Finish();
~~~
</div>
<div class="language-c">
If you do not wish to set every field in a `table`, it may be more convenient to
manually set each field of your monster, instead of calling `create_monster_as_root()`.
The following snippet is functionally equivalent to the above code, but provides
a bit more flexibility.
<br>
~~~{.c}
  // It is important to pair `start_as_root` with `end_as_root`.
  ns(Monster_start_as_root(B));
  ns(Monster_pos_create(B, 1.0f, 2.0f, 3.0f));
  // or alternatively
  //ns(Monster_pos_add(&pos);
<p>ns(Monster_hp_add(B, hp));
// Notice that <code>Monser_name_add</code> adds a string reference unlike the
// add_str and add_strn variants.
ns(Monster_name_add(B, name));
ns(Monster_inventory_add(B, inventory));
ns(Monster_color_add(B, ns(Color_Red)));
ns(Monster_weapons_add(B, weapons));
ns(Monster_equipped_add(B, equipped));
// Complete the monster object and make it the buffer root object.
ns(Monster_end_as_root(B));</p>
<pre><code>&lt;/div&gt;

&lt;div class=&quot;language-swift&quot;&gt;
~~~{.swift}
  let start = Monster.startMonster(&amp;builder)
  Monster.add(pos: Vec3(x: 1, y: 2, z: 3), &amp;builder)
  Monster.add(hp: 300, &amp;builder)
  Monster.add(name: name, &amp;builder)
  Monster.addVectorOf(inventory: inventoryOffset, &amp;builder)
  Monster.add(color: .red, &amp;builder)
  Monster.addVectorOf(weapons: weaponsOffset, &amp;builder)
  Monster.add(equippedType: .weapon, &amp;builder)
  Monster.add(equipped: axe, &amp;builder)
  var orc = Monster.endMonster(&amp;builder, start: start)
</code></pre>
</div>
<p>Before finishing the serialization, let's take a quick look at FlatBuffer
<code>union Equipped</code>. There are two parts to each FlatBuffer <code>union</code>. The first is
a hidden field <code>_type</code> that is generated to hold the type of <code>table</code> referred
to by the <code>union</code>. This allows you to know which type to cast to at runtime.
Second is the <code>union</code>'s data.</p>
<p>In our example, the last two things we added to our <code>Monster</code> were the
<code>Equipped Type</code> and the <code>Equipped</code> union itself.</p>
<p>Here is a repetition of these lines, to help highlight them more clearly:</p>
<div class="language-cpp">
  ~~~{.cpp}
    monster_builder.add_equipped_type(Equipment_Weapon); // Union type
    monster_builder.add_equipped(axe.Union()); // Union data
  ~~~
</div>
<div class="language-java">
  ~~~{.java}
    Monster.addEquippedType(builder, Equipment.Weapon); // Union type
    Monster.addEquipped(axe); // Union data
  ~~~
</div>
<div class="language-kotlin">
  ~~~{.kt}
    Monster.addEquippedType(builder, Equipment.Weapon) // Union type
    Monster.addEquipped(axe) // Union data
  ~~~
</div>
<div class="language-csharp">
  ~~~{.cs}
    Monster.AddEquippedType(builder, Equipment.Weapon); // Union type
    Monster.AddEquipped(builder, axe.Value); // Union data
  ~~~
</div>
<div class="language-go">
  ~~~{.go}
    sample.MonsterAddEquippedType(builder, sample.EquipmentWeapon) // Union type
    sample.MonsterAddEquipped(builder, axe) // Union data
  ~~~
</div>
<div class="language-python">
  ~~~{.py}
    MyGame.Sample.Monster.AddEquippedType(            # Union type
        builder, MyGame.Sample.Equipment.Equipment().Weapon)
    MyGame.Sample.Monster.AddEquipped(builder, axe)   # Union data
  ~~~
</div>
<div class="language-javascript">
  ~~~{.js}
    MyGame.Sample.Monster.addEquippedType(builder, MyGame.Sample.Equipment.Weapon); // Union type
    MyGame.Sample.Monster.addEquipped(builder, axe); // Union data
  ~~~
</div>
<div class="language-typescript">
  ~~~{.ts}
    MyGame.Sample.Monster.addEquippedType(builder, MyGame.Sample.Equipment.Weapon); // Union type
    MyGame.Sample.Monster.addEquipped(builder, axe); // Union data
  ~~~
</div>
<div class="language-php">
  ~~~{.php}
    \MyGame\Sample\Monster::AddEquippedType($builder, \MyGame\Sample\Equipment::Weapon); // Union type
    \MyGame\Sample\Monster::AddEquipped($builder, $axe); // Union data
  ~~~
</div>
<div class="language-c">
~~~{.c}
  // Add union type and data simultaneously.
  ns(Monster_equipped_Weapon_add(B, axe));
~~~
</div>
<div class="language-dart">
~~~{.dart}
  // using the builder API:
  ..addEquippedType(myGame.EquipmentTypeId.Weapon)
  ..addEquippedOffset(axe)
<p>// in the ObjectBuilder API:
equippedTypeId: myGame.EquipmentTypeId.Weapon,  // Union type
equipped: axe,                                  // Union data</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-lua&quot;&gt;
~~~{.lua}
    monster.AddEquippedType(builder, equipment.Weapon) -- Union type
    monster.AddEquipped(builder, axe) -- Union data
</code></pre>
</div>
<div class="language-lobster">
~~~{.lobster}
    .add_equipped_type(MyGame_Sample_Equipment_Weapon)
    .add_equipped(axe)
~~~
</div>
<div class="language-rust">
  ~~~{.rs}
    // You need to call `as_union_value` to turn an object into a type that
    // can be used as a union value.
    monster_builder.add_equipped_type(Equipment::Weapon); // Union type
    monster_builder.add_equipped(axe.as_union_value()); // Union data
  ~~~
</div>
<div class="language-swift">
  ~~~{.swift}
    Monster.add(equippedType: .weapon, builder) // Type of union
    Monster.add(equipped: axe, builder) // Union data
  ~~~
</div>
<p>After you have created your buffer, you will have the offset to the root of the
data in the <code>orc</code> variable, so you can finish the buffer by calling the
appropriate <code>finish</code> method.</p>
<div class="language-cpp">
~~~{.cpp}
  // Call `Finish()` to instruct the builder that this monster is complete.
  // Note: Regardless of how you created the `orc`, you still need to call
  // `Finish()` on the `FlatBufferBuilder`.
  builder.Finish(orc); // You could also call `FinishMonsterBuffer(builder, orc);`.
~~~
</div>
<div class="language-java">
~~~{.java}
  // Call `finish()` to instruct the builder that this monster is complete.
  builder.finish(orc); // You could also call `Monster.finishMonsterBuffer(builder, orc);`.
~~~
</div>
<div class="language-kotlin">
~~~{.kt}
  // Call `finish()` to instruct the builder that this monster is complete.
  builder.finish(orc) // You could also call `Monster.finishMonsterBuffer(builder, orc);`.
~~~
</div>
<div class="language-csharp">
~~~{.cs}
  // Call `Finish()` to instruct the builder that this monster is complete.
  builder.Finish(orc.Value); // You could also call `Monster.FinishMonsterBuffer(builder, orc);`.
~~~
</div>
<div class="language-go">
~~~{.go}
  // Call `Finish()` to instruct the builder that this monster is complete.
  builder.Finish(orc)
~~~
</div>
<div class="language-python">
~~~{.py}
  # Call `Finish()` to instruct the builder that this monster is complete.
  builder.Finish(orc)
~~~
</div>
<div class="language-javascript">
~~~{.js}
  // Call `finish()` to instruct the builder that this monster is complete.
  builder.finish(orc); // You could also call `MyGame.Sample.Monster.finishMonsterBuffer(builder, orc);`.
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  // Call `finish()` to instruct the builder that this monster is complete.
  builder.finish(orc); // You could also call `MyGame.Sample.Monster.finishMonsterBuffer(builder, orc);`.
~~~
</div>
<div class="language-php">
~~~{.php}
  // Call `finish()` to instruct the builder that this monster is complete.
   $builder->finish($orc); // You may also call `\MyGame\Sample\Monster::FinishMonsterBuffer($builder, $orc);`.
~~~
</div>
<div class="language-c">
~~~{.c}
  // Because we used `Monster_create_as_root`, we do not need a `finish` call in C`.
~~~
</div>
<div class="language-dart">
~~~{.dart}
  // Call `finish()` to instruct the builder that this monster is complete.
  // See the next code section, as in Dart `finish` will also return the byte array.
~~~
</div>
<div class="language-lua">
~~~{.lua}
    -- Call 'Finish()' to instruct the builder that this monster is complete.
    builder:Finish(orc)
~~~
</div>
<div class="language-lobster">
~~~{.lobster}
  // Call `Finish()` to instruct the builder that this monster is complete.
  builder.Finish(orc)
~~~
</div>
<div class="language-rust">
~~~{.rs}
  // Call `finish()` to instruct the builder that this monster is complete.
  builder.finish(orc, None);
~~~
</div>
<div class="language-swift">
~~~{.swift}
  // Call `finish(offset:)` to instruct the builder that this monster is complete.
  builder.finish(offset: orc)
~~~
</div>
<p>The buffer is now ready to be stored somewhere, sent over the network, be
compressed, or whatever you'd like to do with it. You can access the buffer
like so:</p>
<div class="language-cpp">
~~~{.cpp}
  // This must be called after `Finish()`.
  uint8_t *buf = builder.GetBufferPointer();
  int size = builder.GetSize(); // Returns the size of the buffer that
                                // `GetBufferPointer()` points to.
~~~
</div>
<div class="language-java">
~~~{.java}
  // This must be called after `finish()`.
  java.nio.ByteBuffer buf = builder.dataBuffer();
  // The data in this ByteBuffer does NOT start at 0, but at buf.position().
  // The number of bytes is buf.remaining().
<p>// Alternatively this copies the above data out of the ByteBuffer for you:
byte[] buf = builder.sizedByteArray();</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-kotlin&quot;&gt;
~~~{.kt}
  // This must be called after `finish()`.
  val buf = builder.dataBuffer()
  // The data in this ByteBuffer does NOT start at 0, but at buf.position().
  // The number of bytes is buf.remaining().

  // Alternatively this copies the above data out of the ByteBuffer for you:
  val buf = builder.sizedByteArray()
</code></pre>
</div>
<div class="language-csharp">
~~~{.cs}
  // This must be called after `Finish()`.
  var buf = builder.DataBuffer; // Of type `FlatBuffers.ByteBuffer`.
  // The data in this ByteBuffer does NOT start at 0, but at buf.Position.
  // The end of the data is marked by buf.Length, so the size is
  // buf.Length - buf.Position.
<p>// Alternatively this copies the above data out of the ByteBuffer for you:
byte[] buf = builder.SizedByteArray();</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-go&quot;&gt;
~~~{.go}
  // This must be called after `Finish()`.
  buf := builder.FinishedBytes() // Of type `byte[]`.
</code></pre>
</div>
<div class="language-python">
~~~{.py}
  # This must be called after `Finish()`.
  buf = builder.Output() // Of type `bytearray`.
~~~
</div>
<div class="language-javascript">
~~~{.js}
  // This must be called after `finish()`.
  var buf = builder.asUint8Array(); // Of type `Uint8Array`.
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  // This must be called after `finish()`.
  let buf = builder.asUint8Array(); // Of type `Uint8Array`.
~~~
</div>
<div class="language-php">
~~~{.php}
  // This must be called after `finish()`.
  $buf = $builder->dataBuffer(); // Of type `Google\FlatBuffers\ByteBuffer`
  // The data in this ByteBuffer does NOT start at 0, but at buf->getPosition().
  // The end of the data is marked by buf->capacity(), so the size is
  // buf->capacity() - buf->getPosition().
~~~
</div>
<div class="language-c">
~~~{.c}
  uint8_t *buf;
  size_t size;
<p>// Allocate and extract a readable buffer from internal builder heap.
// The returned buffer must be deallocated using <code>free</code>.
// NOTE: Finalizing the buffer does NOT change the builder, it
// just creates a snapshot of the builder content.
buf = flatcc_builder_finalize_buffer(B, &amp;size);
// use buf
free(buf);</p>
<p>// Optionally reset builder to reuse builder without deallocating
// internal stack and heap.
flatcc_builder_reset(B);
// build next buffer.
// ...</p>
<p>// Cleanup.
flatcc_builder_clear(B);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-dart&quot;&gt;
~~~{.dart}
  final Uint8List buf = builder.finish(orc);
</code></pre>
</div>
<div class="language-lua">
~~~{.lua}
    -- Get the flatbuffer as a string containing the binary data
    local bufAsString = builder:Output()
~~~
</div>
<div class="language-lobster">
~~~{.lobster}
  // This must be called after `Finish()`.
  let buf = builder.SizedCopy() // Of type `string`.
~~~
</div>
<div class="language-rust">
~~~{.rs}
  // This must be called after `finish()`.
  // `finished_data` returns a byte slice.
  let buf = builder.finished_data(); // Of type `&[u8]`
~~~
</div>
<div class="language-swift">
~~~{.swift}
  // This must be called after `finish()`.
  // `sizedByteArray` returns the finished buf of type [UInt8].
  let buf = builder.sizedByteArray
  // or you can use to get an object of type Data
  let bufData = ByteBuffer(data: builder.data)
~~~
</div>
<p>Now you can write the bytes to a file or send them over the network.
<strong>Make sure your file mode (or transfer protocol) is set to BINARY, not text.</strong>
If you transfer a FlatBuffer in text mode, the buffer will be corrupted,
which will lead to hard to find problems when you read the buffer.</p>
<div class="language-javascript">
For example, in Node you can simply do:
~~~{.js}
  writeFileSync('monster.bin', buf, 'binary');
~~~
</div>
<div class="language-typescript">
For example, in Node you can simply do:
~~~{.ts}
  writeFileSync('monster.bin', buf, 'binary');
~~~
</div>
<h4 id="reading-orc-flatbuffers"><a class="header" href="#reading-orc-flatbuffers">Reading Orc FlatBuffers</a></h4>
<p>Now that we have successfully created an <code>Orc</code> FlatBuffer, the monster data can
be saved, sent over a network, etc. Let's now adventure into the inverse, and
access a FlatBuffer.</p>
<p>This section requires the same import/include, namespace, etc. requirements as
before:</p>
<div class="language-cpp">
~~~{.cpp}
  #include "monster_generated.h" // This was generated by `flatc`.
<p>using namespace MyGame::Sample; // Specified in the schema.</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-java&quot;&gt;
~~~{.java}
  import MyGame.Sample.*; //The `flatc` generated files. (Monster, Vec3, etc.)

  import com.google.flatbuffers.FlatBufferBuilder;
</code></pre>
</div>
<div class="language-kotlin">
~~~{.kt}
  import MyGame.Sample.* //The `flatc` generated files. (Monster, Vec3, etc.)
<p>import com.google.flatbuffers.FlatBufferBuilder</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-csharp&quot;&gt;
~~~{.cs}
  using FlatBuffers;
  using MyGame.Sample; // The `flatc` generated files. (Monster, Vec3, etc.)
</code></pre>
</div>
<div class="language-go">
~~~{.go}
  import (
          flatbuffers "github.com/google/flatbuffers/go"
          sample "MyGame/Sample"
  )
~~~
</div>
<div class="language-python">
~~~{.py}
  import flatbuffers
<h1 id="generated-by-flatc-1"><a class="header" href="#generated-by-flatc-1">Generated by <code>flatc</code>.</a></h1>
<p>import MyGame.Sample.Any
import MyGame.Sample.Color
import MyGame.Sample.Monster
import MyGame.Sample.Vec3</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-javascript&quot;&gt;
~~~{.js}
  // The following code is an example - use your desired module flavor by transpiling from TS. 
  var flatbuffers = require('/js/flatbuffers').flatbuffers;
  var MyGame = require('./monster_generated').MyGame; // Generated by `flatc`.

  //--------------------------------------------------------------------------//

  // The following code an example for browser-based HTML/JavaScript. Use the above code
  // for JavaScript module loaders (e.g. Node.js).
  &lt;script src=&quot;../js/flatbuffers.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;monster_generated.js&quot;&gt;&lt;/script&gt; // Generated by `flatc`.
</code></pre>
</div>
<div class="language-typescript">
~~~{.ts}
  // note: import flatbuffers with your desired import method
<p>// note: the <code>./monster_generated.ts</code> file was previously generated by <code>flatc</code> above using the <code>monster.fbs</code> schema
import { MyGame } from './monster_generated';</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-php&quot;&gt;
~~~{.php}
  // It is recommended that your use PSR autoload when using FlatBuffers in PHP.
  // Here is an example from `SampleBinary.php`:
  function __autoload($class_name) {
    // The last segment of the class name matches the file name.
    $class = substr($class_name, strrpos($class_name, &quot;\\&quot;) + 1);
    $root_dir = join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)))); // `flatbuffers` root.

    // Contains the `*.php` files for the FlatBuffers library and the `flatc` generated files.
    $paths = array(join(DIRECTORY_SEPARATOR, array($root_dir, &quot;php&quot;)),
                   join(DIRECTORY_SEPARATOR, array($root_dir, &quot;samples&quot;, &quot;MyGame&quot;, &quot;Sample&quot;)));
    foreach ($paths as $path) {
      $file = join(DIRECTORY_SEPARATOR, array($path, $class . &quot;.php&quot;));
      if (file_exists($file)) {
        require($file);
        break;
      }
    }
  }
</code></pre>
</div>
<div class="language-c">
~~~{.c}
  // Only needed if we don't have `#include "monster_builder.h"`.
  #include "monster_reader.h"
<p>#undef ns
#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(MyGame_Sample, x) // Specified in the schema.</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-dart&quot;&gt;
~~~{.dart}
import 'package:flat_buffers/flat_buffers.dart' as fb;
import './monster_my_game.sample_generated.dart' as myGame;
</code></pre>
</div>
<div class="language-lua">
~~~{.lua}
  -- require the flatbuffers module
  local flatbuffers = require("flatbuffers")
<p>-- require the generated files from <code>flatc</code>.
local color = require(&quot;MyGame.Sample.Color&quot;)
local equipment = require(&quot;MyGame.Sample.Equipment&quot;)
local monster = require(&quot;MyGame.Sample.Monster&quot;)
local vec3 = require(&quot;MyGame.Sample.Vec3&quot;)
local weapon = require(&quot;MyGame.Sample.Weapon&quot;)</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-lobster&quot;&gt;
~~~{.lobster}
  import from &quot;../lobster/&quot;  // Where to find flatbuffers.lobster
  import monster_generated
</code></pre>
</div>
<div class="language-rust">
~~~{.rs}
  // import the flatbuffers runtime library
  extern crate flatbuffers;
<p>// import the generated code
#[allow(dead_code, unused_imports)]
#[path = &quot;./monster_generated.rs&quot;]
mod monster_generated;
pub use monster_generated::my_game::sample::{get_root_as_monster,
Color, Equipment,
Monster, MonsterArgs,
Vec3,
Weapon, WeaponArgs};</p>
<pre><code>&lt;/div&gt;

Then, assuming you have a buffer of bytes received from disk,
network, etc., you can start accessing the buffer like so:

**Again, make sure you read the bytes in BINARY mode, otherwise the code below
won't work.**

&lt;div class=&quot;language-cpp&quot;&gt;
~~~{.cpp}
  uint8_t *buffer_pointer = /* the data you just read */;

  // Get a pointer to the root object inside the buffer.
  auto monster = GetMonster(buffer_pointer);

  // `monster` is of type `Monster *`.
  // Note: root object pointers are NOT the same as `buffer_pointer`.
  // `GetMonster` is a convenience function that calls `GetRoot&lt;Monster&gt;`,
  // the latter is also available for non-root types.
</code></pre>
</div>
<div class="language-java">
~~~{.java}
  byte[] bytes = /* the data you just read */
  java.nio.ByteBuffer buf = java.nio.ByteBuffer.wrap(bytes);
<p>// Get an accessor to the root object inside the buffer.
Monster monster = Monster.getRootAsMonster(buf);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-kotlin&quot;&gt;
~~~{.kt}
  val bytes = /* the data you just read */
  val buf = java.nio.ByteBuffer.wrap(bytes)

  // Get an accessor to the root object inside the buffer.
  Monster monster = Monster.getRootAsMonster(buf)
</code></pre>
</div>
<div class="language-csharp">
~~~{.cs}
  byte[] bytes = /* the data you just read */
  var buf = new ByteBuffer(bytes);
<p>// Get an accessor to the root object inside the buffer.
var monster = Monster.GetRootAsMonster(buf);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-go&quot;&gt;
~~~{.go}
  var buf []byte = /* the data you just read */

  // Get an accessor to the root object inside the buffer.
  monster := sample.GetRootAsMonster(buf, 0)

  // Note: We use `0` for the offset here, which is typical for most buffers
  // you would read. If you wanted to read from `builder.Bytes` directly, you
  // would need to pass in the offset of `builder.Head()`, as the builder
  // constructs the buffer backwards, so may not start at offset 0.
</code></pre>
</div>
<div class="language-python">
~~~{.py}
  buf = /* the data you just read, in an object of type "bytearray" */
<p>// Get an accessor to the root object inside the buffer.
monster = MyGame.Sample.Monster.Monster.GetRootAs(buf, 0)</p>
<h1 id="note-we-use-0-for-the-offset-here-which-is-typical-for-most-buffers"><a class="header" href="#note-we-use-0-for-the-offset-here-which-is-typical-for-most-buffers">Note: We use <code>0</code> for the offset here, which is typical for most buffers</a></h1>
<h1 id="you-would-read--if-you-wanted-to-read-from-the-builderbytes-directly"><a class="header" href="#you-would-read--if-you-wanted-to-read-from-the-builderbytes-directly">you would read.  If you wanted to read from the <code>builder.Bytes</code> directly,</a></h1>
<h1 id="you-would-need-to-pass-in-the-offset-of-builderhead-as-the-builder"><a class="header" href="#you-would-need-to-pass-in-the-offset-of-builderhead-as-the-builder">you would need to pass in the offset of <code>builder.Head()</code>, as the builder</a></h1>
<h1 id="constructs-the-buffer-backwards-so-may-not-start-at-offset-0"><a class="header" href="#constructs-the-buffer-backwards-so-may-not-start-at-offset-0">constructs the buffer backwards, so may not start at offset 0.</a></h1>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-javascript&quot;&gt;
~~~{.js}
  // the data you just read, as a `Uint8Array`
  // Note that the example here uses `readFileSync` from the built-in `fs` module,
  // but other methods for accessing the file contents will also work.
  var bytes = new Uint8Array(readFileSync('./monsterdata.bin'));

  var buf = new flatbuffers.ByteBuffer(bytes);

  // Get an accessor to the root object inside the buffer.
  var monster = MyGame.Sample.Monster.getRootAsMonster(buf);
</code></pre>
</div>
<div class="language-typescript">
~~~{.ts}
  // the data you just read, as a `Uint8Array`.
  // Note that the example here uses `readFileSync` from the built-in `fs` module,
  // but other methods for accessing the file contents will also work.
  let bytes = new Uint8Array(readFileSync('./monsterdata.bin'));
<p>let buf = new flatbuffers.ByteBuffer(bytes);</p>
<p>// Get an accessor to the root object inside the buffer.
let monster = MyGame.Sample.Monster.getRootAsMonster(buf);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-php&quot;&gt;
~~~{.php}
  $bytes = /* the data you just read, in a string */
  $buf = Google\FlatBuffers\ByteBuffer::wrap($bytes);

  // Get an accessor to the root object inside the buffer.
  $monster = \MyGame\Sample\Monster::GetRootAsMonster($buf);
</code></pre>
</div>
<div class="language-c">
~~~{.c}
  // Note that we use the `table_t` suffix when reading a table object
  // as opposed to the `ref_t` suffix used during the construction of
  // the buffer.
  ns(Monster_table_t) monster = ns(Monster_as_root(buffer));
<p>// Note: root object pointers are NOT the same as the <code>buffer</code> pointer.</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-dart&quot;&gt;
~~~{.dart}
List&lt;int&gt; data = ... // the data, e.g. from file or network
// A generated factory constructor that will read the data.
myGame.Monster monster = new myGame.Monster(data);
</code></pre>
</div>
<div class="language-lua">
~~~{.lua}
    local bufAsString =   -- The data you just read in
<pre><code>-- Convert the string representation into binary array Lua structure
local buf = flatbuffers.binaryArray.New(bufAsString)

-- Get an accessor to the root object insert the buffer
local mon = monster.GetRootAsMonster(buf, 0)
</code></pre>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-lobster&quot;&gt;
~~~{.lobster}
  buf = /* the data you just read, in a string */

  // Get an accessor to the root object inside the buffer.
  let monster = MyGame_Sample_GetRootAsMonster(buf)
</code></pre>
</div>
<div class="language-rust">
~~~{.rs}
  let buf = /* the data you just read, in a &[u8] */
<p>// Get an accessor to the root object inside the buffer.
let monster = get_root_as_monster(buf);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-swift&quot;&gt;
~~~{.swift}
  // create a ByteBuffer(:) from an [UInt8] or Data()
  let buf = // Get your data

  // Get an accessor to the root object inside the buffer.
  let monster = Monster.getRootAsMonster(bb: ByteBuffer(bytes: buf))
</code></pre>
</div>
<p>If you look in the generated files from the schema compiler, you will see it generated
accessors for all non-<code>deprecated</code> fields. For example:</p>
<div class="language-cpp">
~~~{.cpp}
  auto hp = monster->hp();
  auto mana = monster->mana();
  auto name = monster->name()->c_str();
~~~
</div>
<div class="language-java">
~~~{.java}
  short hp = monster.hp();
  short mana = monster.mana();
  String name = monster.name();
~~~
</div>
<div class="language-kotlin">
~~~{.kt}
  val hp = monster.hp
  val mana = monster.mana
  val name = monster.name
~~~
</div>
<div class="language-csharp">
~~~{.cs}
  // For C#, unlike most other languages support by FlatBuffers, most values (except for
  // vectors and unions) are available as properties instead of accessor methods.
  var hp = monster.Hp
  var mana = monster.Mana
  var name = monster.Name
~~~
</div>
<div class="language-go">
~~~{.go}
  hp := monster.Hp()
  mana := monster.Mana()
  name := string(monster.Name()) // Note: `monster.Name()` returns a byte[].
~~~
</div>
<div class="language-python">
~~~{.py}
  hp = monster.Hp()
  mana = monster.Mana()
  name = monster.Name()
~~~
</div>
<div class="language-javascript">
~~~{.js}
  var hp = monster.hp();
  var mana = monster.mana();
  var name = monster.name();
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  let hp = monster.hp();
  let mana = monster.mana();
  let name = monster.name();
~~~
</div>
<div class="language-php">
~~~{.php}
  $hp = $monster->getHp();
  $mana = $monster->getMana();
  $name = monster->getName();
~~~
</div>
<div class="language-c">
~~~{.c}
  uint16_t hp = ns(Monster_hp(monster));
  uint16_t mana = ns(Monster_mana(monster));
  flatbuffers_string_t name = ns(Monster_name(monster));
~~~
</div>
<div class="language-dart">
~~~{.dart}
  // For Dart, unlike other languages support by FlatBuffers, most values
  // are available as properties instead of accessor methods.
  var hp = monster.hp;
  var mana = monster.mana;
  var name = monster.name;
~~~
</div>
<div class="language-lua">
~~~{.lua}
  local hp = mon:Hp()
  local mana = mon:Mana()
  local name = mon:Name()
~~~
</div>
<div class="language-lobster">
~~~{.lobster}
  let hp = monster.hp
  let mana = monster.mana
  let name = monster.name
~~~
</div>
<div class="language-rust">
~~~{.rs}
  // Get and test some scalar types from the FlatBuffer.
  let hp = monster.hp();
  let mana = monster.mana();
  let name = monster.name();
~~~
</div>
<div class="language-swift">
~~~{.swift}
  let hp = monster.hp
  let mana = monster.mana
  let name = monster.name // returns an optional string
~~~
</div>
<p>These should hold <code>300</code>, <code>150</code>, and <code>&quot;Orc&quot;</code> respectively.</p>
<p><em>Note: The default value <code>150</code> wasn't stored in <code>mana</code>, but we are still able to retrieve it.</em></p>
<p>To access sub-objects, in the case of our <code>pos</code>, which is a <code>Vec3</code>:</p>
<div class="language-cpp">
~~~{.cpp}
  auto pos = monster->pos();
  auto x = pos->x();
  auto y = pos->y();
  auto z = pos->z();
~~~
</div>
<div class="language-java">
~~~{.java}
  Vec3 pos = monster.pos();
  float x = pos.x();
  float y = pos.y();
  float z = pos.z();
~~~
</div>
<div class="language-kotlin">
~~~{.kt}
  val pos = monster.pos!!
  val x = pos.x
  val y = pos.y
  val z = pos.z
~~~
</div>
<div class="language-csharp">
~~~{.cs}
  var pos = monster.Pos.Value;
  var x = pos.X;
  var y = pos.Y;
  var z = pos.Z;
~~~
</div>
<div class="language-go">
~~~{.go}
  pos := monster.Pos(nil)
  x := pos.X()
  y := pos.Y()
  z := pos.Z()
<p>// Note: Whenever you access a new object, like in <code>Pos()</code>, a new temporary
// accessor object gets created. If your code is very performance sensitive,
// you can pass in a pointer to an existing <code>Vec3</code> instead of <code>nil</code>. This
// allows you to reuse it across many calls to reduce the amount of object
// allocation/garbage collection.</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-python&quot;&gt;
~~~{.py}
  pos = monster.Pos()
  x = pos.X()
  y = pos.Y()
  z = pos.Z()
</code></pre>
</div>
<div class="language-javascript">
~~~{.js}
  var pos = monster.pos();
  var x = pos.x();
  var y = pos.y();
  var z = pos.z();
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  let pos = monster.pos();
  let x = pos.x();
  let y = pos.y();
  let z = pos.z();
~~~
</div>
<div class="language-php">
~~~{.php}
  $pos = $monster->getPos();
  $x = $pos->getX();
  $y = $pos->getY();
  $z = $pos->getZ();
~~~
</div>
<div class="language-c">
~~~{.c}
  ns(Vec3_struct_t) pos = ns(Monster_pos(monster));
  float x = ns(Vec3_x(pos));
  float y = ns(Vec3_y(pos));
  float z = ns(Vec3_z(pos));
~~~
</div>
<div class="language-dart">
~~~{.dart}
  myGame.Vec3 pos = monster.pos;
  double x = pos.x;
  double y = pos.y;
  double z = pos.z;
~~~
</div>
<div class="language-lua">
~~~{.lua}
  local pos = mon:Pos()
  local x = pos:X()
  local y = pos:Y()
  local z = pos:Z()
~~~
</div>
<div class="language-lobster">
~~~{.lobster}
  let pos = monster.pos
  let x = pos.x
  let y = pos.y
  let z = pos.z
~~~
</div>
<div class="language-rust">
~~~{.rs}
  let pos = monster.pos().unwrap();
  let x = pos.x();
  let y = pos.y();
  let z = pos.z();
~~~
</div>
<div class="language-swift">
~~~{.swift}
  let pos = monster.pos
  let x = pos.x
  let y = pos.y
  let z = pos.z
~~~
</div>
<p><code>x</code>, <code>y</code>, and <code>z</code> will contain <code>1.0</code>, <code>2.0</code>, and <code>3.0</code>, respectively.</p>
<p><em>Note: Had we not set <code>pos</code> during serialization, it would be a <code>null</code>-value.</em></p>
<p>Similarly, we can access elements of the inventory <code>vector</code> by indexing it. You
can also iterate over the length of the array/vector representing the
FlatBuffers <code>vector</code>.</p>
<div class="language-cpp">
~~~{.cpp}
  auto inv = monster->inventory(); // A pointer to a `flatbuffers::Vector<>`.
  auto inv_len = inv->size();
  auto third_item = inv->Get(2);
~~~
</div>
<div class="language-java">
~~~{.java}
  int invLength = monster.inventoryLength();
  byte thirdItem = monster.inventory(2);
~~~
</div>
<div class="language-kotlin">
~~~{.kotlin}
  val invLength = monster.inventoryLength
  val thirdItem = monster.inventory(2)!!
~~~
</div>
<div class="language-csharp">
~~~{.cs}
  int invLength = monster.InventoryLength;
  var thirdItem = monster.Inventory(2);
~~~
</div>
<div class="language-go">
~~~{.go}
  invLength := monster.InventoryLength()
  thirdItem := monster.Inventory(2)
~~~
</div>
<div class="language-python">
~~~{.py}
  inv_len = monster.InventoryLength()
  third_item = monster.Inventory(2)
~~~
</div>
<div class="language-javascript">
~~~{.js}
  var invLength = monster.inventoryLength();
  var thirdItem = monster.inventory(2);
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  let invLength = monster.inventoryLength();
  let thirdItem = monster.inventory(2);
~~~
</div>
<div class="language-php">
~~~{.php}
  $inv_len = $monster->getInventoryLength();
  $third_item = $monster->getInventory(2);
~~~
</div>
<div class="language-c">
~~~{.c}
    // If `inv` hasn't been set, it will be null. It is valid get
    // the length of null which will be 0, useful for iteration.
    flatbuffers_uint8_vec_t inv = ns(Monster_inventory(monster));
    size_t inv_len = flatbuffers_uint8_vec_len(inv);
~~~
</div>
<div class="language-dart">
~~~{.dart}
  int invLength = monster.inventory.length;
  var thirdItem = monster.inventory[2];
~~~
</div>
<div class="language-lua">
~~~{.lua}
  local invLength = mon:InventoryLength()
  local thirdItem = mon:Inventory(3) -- Lua is 1-based
~~~
</div>
<div class="language-lobster">
~~~{.lobster}
  let inv_len = monster.inventory_length
  let third_item = monster.inventory(2)
~~~
</div>
<div class="language-rust">
~~~{.rs}
  // Get and test an element from the `inventory` FlatBuffer's `vector`.
  let inv = monster.inventory().unwrap();
<p>// Note that this vector is returned as a slice, because direct access for
// this type, a <code>u8</code> vector, is safe on all platforms:
let third_item = inv[2];</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-swift&quot;&gt;
~~~{.swift}
  // Get a the count of objects in the vector
  let count = monster.inventoryCount

  // get item at index 4
  let object = monster.inventory(at: 4)

  // or you can fetch the entire array
  let inv = monster.inventory
  // inv[4] should equal object
</code></pre>
</div>
<p>For <code>vector</code>s of <code>table</code>s, you can access the elements like any other vector,
except you need to handle the result as a FlatBuffer <code>table</code>:</p>
<div class="language-cpp">
~~~{.cpp}
  auto weapons = monster->weapons(); // A pointer to a `flatbuffers::Vector<>`.
  auto weapon_len = weapons->size();
  auto second_weapon_name = weapons->Get(1)->name()->str();
  auto second_weapon_damage = weapons->Get(1)->damage()
~~~
</div>
<div class="language-java">
~~~{.java}
  int weaponsLength = monster.weaponsLength();
  String secondWeaponName = monster.weapons(1).name();
  short secondWeaponDamage = monster.weapons(1).damage();
~~~
</div>
<div class="language-kotlin">
~~~{.kt}
  val weaponsLength = monster.weaponsLength
  val secondWeaponName = monster.weapons(1)!!.name
  val secondWeaponDamage = monster.weapons(1)!!.damage
~~~
</div>
<div class="language-csharp">
~~~{.cs}
  int weaponsLength = monster.WeaponsLength;
  var secondWeaponName = monster.Weapons(1).Name;
  var secondWeaponDamage = monster.Weapons(1).Damage;
~~~
</div>
<div class="language-go">
~~~{.go}
  weaponLength := monster.WeaponsLength()
  weapon := new(sample.Weapon) // We need a `sample.Weapon` to pass into `monster.Weapons()`
                               // to capture the output of the function.
  if monster.Weapons(weapon, 1) {
          secondWeaponName := weapon.Name()
          secondWeaponDamage := weapon.Damage()
  }
~~~
</div>
<div class="language-python">
~~~{.py}
  weapons_length = monster.WeaponsLength()
  second_weapon_name = monster.Weapons(1).Name()
  second_weapon_damage = monster.Weapons(1).Damage()
~~~
</div>
<div class="language-javascript">
~~~{.js}
  var weaponsLength = monster.weaponsLength();
  var secondWeaponName = monster.weapons(1).name();
  var secondWeaponDamage = monster.weapons(1).damage();
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  let weaponsLength = monster.weaponsLength();
  let secondWeaponName = monster.weapons(1).name();
  let secondWeaponDamage = monster.weapons(1).damage();
~~~
</div>
<div class="language-php">
~~~{.php}
  $weapons_len = $monster->getWeaponsLength();
  $second_weapon_name = $monster->getWeapons(1)->getName();
  $second_weapon_damage = $monster->getWeapons(1)->getDamage();
~~~
</div>
<div class="language-c">
~~~{.c}
  ns(Weapon_vec_t) weapons = ns(Monster_weapons(monster));
  size_t weapons_len = ns(Weapon_vec_len(weapons));
  // We can use `const char *` instead of `flatbuffers_string_t`.
  const char *second_weapon_name = ns(Weapon_name(ns(Weapon_vec_at(weapons, 1))));
  uint16_t second_weapon_damage =  ns(Weapon_damage(ns(Weapon_vec_at(weapons, 1))));
~~~
</div>
<div class="language-dart">
~~~{.dart}
  int weaponsLength = monster.weapons.length;
  var secondWeaponName = monster.weapons[1].name;
  var secondWeaponDamage = monster.Weapons[1].damage;
~~~
</div>
<div class="language-lua">
~~~{.lua}
  local weaponsLength = mon:WeaponsLength()
  local secondWeaponName = mon:Weapon(2):Name()
  local secondWeaponDamage = mon:Weapon(2):Damage()
~~~
</div>
<div class="language-lobster">
~~~{.lobster}
  let weapons_length = monster.weapons_length
  let second_weapon_name = monster.weapons(1).name
  let second_weapon_damage = monster.weapons(1).damage
~~~
</div>
<div class="language-rust">
~~~{.rs}
  // Get and test the `weapons` FlatBuffers's `vector`.
  let weps = monster.weapons().unwrap();
  let weps_len = weps.len();
<p>let wep2 = weps.get(1);
let second_weapon_name = wep2.name();
let second_weapon_damage = wep2.damage();</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-swift&quot;&gt;
~~~{.swift}
  // Get the count of weapon objects
  let wepsCount = monster.weaponsCount

  let weapon2 = monster.weapons(at: 1)
  let weaponName = weapon2.name
  let weaponDmg = weapon2.damage
</code></pre>
</div>
<p>Last, we can access our <code>Equipped</code> FlatBuffer <code>union</code>. Just like when we created
the <code>union</code>, we need to get both parts of the <code>union</code>: the type and the data.</p>
<p>We can access the type to dynamically cast the data as needed (since the
<code>union</code> only stores a FlatBuffer <code>table</code>).</p>
<div class="language-cpp">
~~~{.cpp}
  auto union_type = monster->equipped_type();
<p>if (union_type == Equipment_Weapon) {
auto weapon = static_cast&lt;const Weapon*&gt;(monster-&gt;equipped()); // Requires <code>static_cast</code>
// to type <code>const Weapon*</code>.</p>
<pre><code>auto weapon_name = weapon-&gt;name()-&gt;str(); // &quot;Axe&quot;
auto weapon_damage = weapon-&gt;damage();    // 5
</code></pre>
<p>}</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-java&quot;&gt;
~~~{.java}
  int unionType = monster.EquippedType();

  if (unionType == Equipment.Weapon) {
    Weapon weapon = (Weapon)monster.equipped(new Weapon()); // Requires explicit cast
                                                            // to `Weapon`.

    String weaponName = weapon.name();    // &quot;Axe&quot;
    short weaponDamage = weapon.damage(); // 5
  }
</code></pre>
</div>
<div class="language-kotlin">
~~~{.kt}
  val unionType = monster.EquippedType
<p>if (unionType == Equipment.Weapon) {
val weapon = monster.equipped(Weapon()) as Weapon // Requires explicit cast
// to <code>Weapon</code>.</p>
<pre><code>val weaponName = weapon.name   // &quot;Axe&quot;
val weaponDamage = weapon.damage // 5
</code></pre>
<p>}</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-csharp&quot;&gt;
~~~{.cs}
  var unionType = monster.EquippedType;

  if (unionType == Equipment.Weapon) {
    var weapon = monster.Equipped&lt;Weapon&gt;().Value;

    var weaponName = weapon.Name;     // &quot;Axe&quot;
    var weaponDamage = weapon.Damage; // 5
  }
</code></pre>
</div>
<div class="language-go">
~~~{.go}
  // We need a `flatbuffers.Table` to capture the output of the
  // `monster.Equipped()` function.
  unionTable := new(flatbuffers.Table)
<p>if monster.Equipped(unionTable) {
unionType := monster.EquippedType()</p>
<pre><code>      if unionType == sample.EquipmentWeapon {
              // Create a `sample.Weapon` object that can be initialized with the contents
              // of the `flatbuffers.Table` (`unionTable`), which was populated by
              // `monster.Equipped()`.
              unionWeapon = new(sample.Weapon)
              unionWeapon.Init(unionTable.Bytes, unionTable.Pos)

              weaponName = unionWeapon.Name()
              weaponDamage = unionWeapon.Damage()
      }
</code></pre>
<p>}</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-python&quot;&gt;
~~~{.py}
  union_type = monster.EquippedType()

  if union_type == MyGame.Sample.Equipment.Equipment().Weapon:
    # `monster.Equipped()` returns a `flatbuffers.Table`, which can be used to
    # initialize a `MyGame.Sample.Weapon.Weapon()`.
    union_weapon = MyGame.Sample.Weapon.Weapon()
    union_weapon.Init(monster.Equipped().Bytes, monster.Equipped().Pos)

    weapon_name = union_weapon.Name()     // 'Axe'
    weapon_damage = union_weapon.Damage() // 5
</code></pre>
</div>
<div class="language-javascript">
~~~{.js}
  var unionType = monster.equippedType();
<p>if (unionType == MyGame.Sample.Equipment.Weapon) {
var weaponName = monster.equipped(new MyGame.Sample.Weapon()).name();     // 'Axe'
var weaponDamage = monster.equipped(new MyGame.Sample.Weapon()).damage(); // 5
}</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-typescript&quot;&gt;
~~~{.ts}
  let unionType = monster.equippedType();

  if (unionType == MyGame.Sample.Equipment.Weapon) {
    let weaponName = monster.equipped(new MyGame.Sample.Weapon()).name();     // 'Axe'
    let weaponDamage = monster.equipped(new MyGame.Sample.Weapon()).damage(); // 5
  }
</code></pre>
</div>
<div class="language-php">
~~~{.php}
  $union_type = $monster->getEquippedType();
<p>if ($union_type == \MyGame\Sample\Equipment::Weapon) {
$weapon_name = $monster-&gt;getEquipped(new \MyGame\Sample\Weapon())-&gt;getName();     // &quot;Axe&quot;
$weapon_damage = $monster-&gt;getEquipped(new \MyGame\Sample\Weapon())-&gt;getDamage(); // 5
}</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-c&quot;&gt;
~~~{.c}
  // Access union type field.
  if (ns(Monster_equipped_type(monster)) == ns(Equipment_Weapon)) {
      // Cast to appropriate type:
      // C allows for silent void pointer assignment, so we need no explicit cast.
      ns(Weapon_table_t) weapon = ns(Monster_equipped(monster));
      const char *weapon_name = ns(Weapon_name(weapon)); // &quot;Axe&quot;
      uint16_t weapon_damage = ns(Weapon_damage(weapon)); // 5
  }
</code></pre>
</div>
<div class="language-dart">
~~~{.dart}
  var unionType = monster.equippedType.value;
<p>if (unionType == myGame.EquipmentTypeId.Weapon.value) {
myGame.Weapon weapon = mon.equipped as myGame.Weapon;</p>
<pre><code>var weaponName = weapon.name;     // &quot;Axe&quot;
var weaponDamage = weapon.damage; // 5
</code></pre>
<p>}</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-lua&quot;&gt;
~~~{.lua}
  local unionType = mon:EquippedType()

  if unionType == equipment.Weapon then
    local unionWeapon = weapon.New()
    unionWeapon:Init(mon:Equipped().bytes, mon:Equipped().pos)

    local weaponName = unionWeapon:Name()     -- 'Axe'
    local weaponDamage = unionWeapon:Damage() -- 5
  end
</code></pre>
</div>
<div class="language-lobster">
~~~{.lobster}
  union_type = monster.equipped_type
<p>if union_type == MyGame_Sample_Equipment_Weapon:
// <code>monster.equipped_as_Weapon</code> returns a FlatBuffer handle much like normal table fields,
// but this is only valid to call if we already know it is the correct type.
let union_weapon = monster.equipped_as_Weapon</p>
<pre><code>  let weapon_name = union_weapon.name     // &quot;Axe&quot;
  let weapon_damage = union_weapon.damage // 5
</code></pre>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-rust&quot;&gt;
~~~{.rs}
  // Get and test the `Equipment` union (`equipped` field).
  // `equipped_as_weapon` returns a FlatBuffer handle much like normal table
  // fields, but this will return `None` if the union is not actually of that
  // type.
  if monster.equipped_type() == Equipment::Weapon {
    let equipped = monster.equipped_as_weapon().unwrap();
    let weapon_name = equipped.name();
    let weapon_damage = equipped.damage();
</code></pre>
</div>
<div class="language-swift">
~~~{.swift}
  // Get and check if the monster has an equipped item
  if monster.equippedType == .weapon {
    let _weapon = monster.equipped(type: Weapon.self)
    let name = _weapon.name // should return "Axe"
    let dmg = _weapon.damage // should return 5
  }
~~~
</div>
<h2 id="mutating-flatbuffers"><a class="header" href="#mutating-flatbuffers">Mutating FlatBuffers</a></h2>
<p>As you saw above, typically once you have created a FlatBuffer, it is read-only
from that moment on. There are, however, cases where you have just received a
FlatBuffer, and you'd like to modify something about it before sending it on to
another recipient. With the above functionality, you'd have to generate an
entirely new FlatBuffer, while tracking what you modified in your own data
structures. This is inconvenient.</p>
<p>For this reason FlatBuffers can also be mutated in-place. While this is great
for making small fixes to an existing buffer, you generally want to create
buffers from scratch whenever possible, since it is much more efficient and the
API is much more general purpose.</p>
<p>To get non-const accessors, invoke <code>flatc</code> with <code>--gen-mutable</code>.</p>
<p>Similar to how we read fields using the accessors above, we can now use the
mutators like so:</p>
<div class="language-cpp">
~~~{.cpp}
  auto monster = GetMutableMonster(buffer_pointer);  // non-const
  monster->mutate_hp(10);                      // Set the table `hp` field.
  monster->mutable_pos()->mutate_z(4);         // Set struct field.
  monster->mutable_inventory()->Mutate(0, 1);  // Set vector element.
~~~
</div>
<div class="language-java">
~~~{.java}
  Monster monster = Monster.getRootAsMonster(buf);
  monster.mutateHp(10);            // Set table field.
  monster.pos().mutateZ(4);        // Set struct field.
  monster.mutateInventory(0, 1);   // Set vector element.
~~~
</div>
<div class="language-kotlin">
~~~{.kt}
  val monster = Monster.getRootAsMonster(buf)
  monster.mutateHp(10)            // Set table field.
  monster.pos!!.mutateZ(4)        // Set struct field.
  monster.mutateInventory(0, 1)   // Set vector element.
~~~
</div>
<div class="language-csharp">
~~~{.cs}
  var monster = Monster.GetRootAsMonster(buf);
  monster.MutateHp(10);            // Set table field.
  monster.Pos.MutateZ(4);          // Set struct field.
  monster.MutateInventory(0, 1);   // Set vector element.
~~~
</div>
<div class="language-go">
~~~{.go}
  <API for mutating FlatBuffers is not yet available in Go.>
~~~
</div>
<div class="language-python">
~~~{.py}
  <API for mutating FlatBuffers is not yet available in Python.>
~~~
</div>
<div class="language-javascript">
~~~{.js}
  <API for mutating FlatBuffers is not yet supported in JavaScript.>
~~~
</div>
<div class="language-typescript">
~~~{.ts}
  <API for mutating FlatBuffers is not yet supported in TypeScript.>
~~~
</div>
<div class="language-php">
~~~{.php}
  <API for mutating FlatBuffers is not yet supported in PHP.>
~~~
</div>
<div class="language-c">
~~~{.c}
  <API for in-place mutating FlatBuffers will not be supported in C
  (except in-place vector sorting is possible).>
~~~
</div>
<div class="language-dart">
~~~{.dart}
  <API for mutating FlatBuffers not yet available in Dart.>
~~~
</div>
<div class="language-lua">
~~~{.lua}
  <API for mutating FlatBuffers is not yet available in Lua.>
~~~
</div>
<div class="language-lobster">
~~~{.lobster}
  <API for mutating FlatBuffers is not yet available in Lobster.>
~~~
</div>
<div class="language-rust">
~~~{.rs}
  <API for mutating FlatBuffers is not yet available in Rust.>
~~~
</div>
<div class="language-swift">
~~~{.swift}
  let monster = Monster.getRootAsMonster(bb: ByteBuffer(bytes: buf))
  monster.mutate(hp: 10) // mutates a value in a table
  /// to mutate structs in swift you have to use the mutable accessors
  monster.mutablePos.mutate(z: 4) // mutates a value in a struct
  monster.mutate(inventory: 6, at index: 0) // mutates a value in an Scalar array
~~~
</div>
<p>We use the somewhat verbose term <code>mutate</code> instead of <code>set</code> to indicate that this
is a special use case, not to be confused with the default way of constructing
FlatBuffer data.</p>
<p>After the above mutations, you can send on the FlatBuffer to a new recipient
without any further work!</p>
<p>Note that any <code>mutate</code> functions on a table will return a boolean, which is
<code>false</code> if the field we're trying to set is not present in the buffer. Fields
are not present if they weren't set, or even if they happen to be equal to
the default value. For example, in the creation code above, the <code>mana</code>
field is equal to <code>150</code>, which is the default value, so it was never stored in
the buffer. Trying to call the corresponding <code>mutate</code> method for <code>mana</code> on such
data will return <code>false</code>, and the value won't actually be modified!</p>
<p>One way to solve this is to call <code>ForceDefaults</code> on a FlatBufferBuilder to
force all fields you set to actually be written. This, of course, increases the
size of the buffer somewhat, but this may be acceptable for a mutable buffer.</p>
<p>If this is not sufficient, other ways of mutating FlatBuffers may be supported
in your language through an object based API (<code>--gen-object-api</code>) or reflection.
See the individual language documents for support.</p>
<h2 id="using-flatc-as-a-json-conversion-tool"><a class="header" href="#using-flatc-as-a-json-conversion-tool">Using <code>flatc</code> as a JSON Conversion Tool</a></h2>
<p>If you are working with C, C++, or Lobster, you can parse JSON at runtime.
If your language does not support JSON at the moment, <code>flatc</code> may provide an
alternative. Using <code>flatc</code> is often the preferred method, as it doesn't require you to
add any new code to your program. It is also efficient, since you can ship with
the binary data. The drawback is that it requires an extra step for your
users/developers to perform (although it may be able to be automated
as part of your compilation).</p>
<h4 id="json-to-binary-representation"><a class="header" href="#json-to-binary-representation">JSON to binary representation</a></h4>
<p>Let's say you have a JSON file that describes your monster. In this example,
we will use the file <code>flatbuffers/samples/monsterdata.json</code>.</p>
<p>Here are the contents of the file:</p>
<pre><code class="language-{.json}">{
  &quot;pos&quot;: {
    &quot;x&quot;: 1.0,
    &quot;y&quot;: 2.0,
    &quot;z&quot;: 3.0
  },
  &quot;hp&quot;: 300,
  &quot;name&quot;: &quot;Orc&quot;,
  &quot;weapons&quot;: [
    {
      &quot;name&quot;: &quot;axe&quot;,
      &quot;damage&quot;: 100
    },
    {
      &quot;name&quot;: &quot;bow&quot;,
      &quot;damage&quot;: 90
    }
  ],
  &quot;equipped_type&quot;: &quot;Weapon&quot;,
  &quot;equipped&quot;: {
    &quot;name&quot;: &quot;bow&quot;,
    &quot;damage&quot;: 90
  }
}
</code></pre>
<p>You can run this file through the <code>flatc</code> compiler with the <code>-b</code> flag and
our <code>monster.fbs</code> schema to produce a FlatBuffer binary file.</p>
<pre><code class="language-{.sh}">./../flatc --binary monster.fbs monsterdata.json
</code></pre>
<p>The output of this will be a file <code>monsterdata.bin</code>, which will contain the
FlatBuffer binary representation of the contents from our <code>.json</code> file.</p>
<div class="language-cpp">
*Note: If you're working in C++, you can also parse JSON at runtime. See the
[Use in C++](@ref flatbuffers_guide_use_cpp) section of the Programmer's
Guide for more information.*
</div>
<div class="language-c">
*Note: If you're working in C, the `flatcc --json` (not `flatc`)
compiler will generate schema specific high performance json parsers and
printers that you can compile and use at runtime. The `flatc` compiler (not
`flatcc`) on the other hand, is still useful for general offline json to
flatbuffer conversion from a given schema. There are no current plans
for `flatcc` to support this.*
</div>
<div class="language-lobster">
*Note: If you're working in Lobster, you can also parse JSON at runtime. See the
[Use in Lobster](@ref flatbuffers_guide_use_lobster) section of the Programmer's
Guide for more information.*
</div>
<h4 id="flatbuffer-binary-to-json"><a class="header" href="#flatbuffer-binary-to-json">FlatBuffer binary to JSON</a></h4>
<p>Converting from a FlatBuffer binary representation to JSON is supported as well:</p>
<pre><code class="language-{.sh}">./../flatc --json --raw-binary monster.fbs -- monsterdata.bin
</code></pre>
<p>This will convert <code>monsterdata.bin</code> back to its original JSON representation.
You need to pass the corresponding FlatBuffers schema so that flatc knows how to
interpret the binary buffer. Since <code>monster.fbs</code> does not specify an explicit
<code>file_identifier</code> for binary buffers, <code>flatc</code> needs to be forced into reading
the <code>.bin</code> file using the <code>--raw-binary</code> option.</p>
<p>The FlatBuffer binary representation does not explicitly encode default values,
therefore they are not present in the resulting JSON unless you specify
<code>--defaults-json</code>.</p>
<p>If you intend to process the JSON with other tools, you may consider switching
on <code>--strict-json</code> so that identifiers are quoted properly.</p>
<p><em>Note: The resulting JSON file is not necessarily identical with the original JSON.
If the binary representation contains floating point numbers, floats and doubles
are rounded to 6 and 12 digits, respectively, in order to represent them as
decimals in the JSON document.</em></p>
<h2 id="advanced-features-for-each-language"><a class="header" href="#advanced-features-for-each-language">Advanced Features for Each Language</a></h2>
<h3 id="vector-of-unions"><a class="header" href="#vector-of-unions">Vector of Unions</a></h3>
<p>Some languages support storing unions directly in a vector.</p>
<pre><code>// File found in tests/union_vector/union_vector.fbs
namespace Example.VectorOfUnions;

// Demonstrates the ability to have vectors of unions, and also to
// store structs and strings in unions.

table Attacker {
  sword_attack_damage: int;
}

struct Rapunzel {
  hair_length: int;
}

struct BookReader {
  books_read: int;
}

union Character {
  MuLan: Attacker,  // Can have name be different from type.
  Rapunzel,         // Or just both the same, as before.
  Belle: BookReader,
  BookFan: BookReader,
  Other: string,
  Unused: string
}

table Movie {
  main_character: Character;
  characters: [Character];
}
</code></pre>
<h4 id="creating"><a class="header" href="#creating">Creating</a></h4>
<p>Analagously to how a union adds two fields to a table a vector of unions creates two different vectors:
one for the union data and one for the data types.</p>
<div class="language-cpp">
C++ supports vectors of unions, but it isn't currently documented.
</div>
<div class="language-typescript">
Typescript supports vectors of unions, but it isn't currently documented.
</div>
<div class="language-php">
PHP supports vectors of unions, but it isn't currently documented.
</div>
<div class="language-java">
Java supports vectors of unions, but it isn't currently documented.
</div>
<div class="language-csharp">
~~~{.cs}
using FlatBuffers;
using Example.VectorOfUnions;
<p>var fbb = new FlatBufferBuilder(100);</p>
<p>var characterTypes = new[]
{
Character.MuLan,
Character.Belle,
Character.Other,
};
var characterTypesOffset = Movie.CreateCharactersTypeVector(fbb, characterTypes);</p>
<p>var characters = new[]
{
Attacker.CreateAttacker(fbb, 10).Value,
BookReader.CreateBookReader(fbb, 20).Value,
fbb.CreateSharedString(&quot;Chip&quot;).Value,
};
var charactersOffset = Movie.CreateCharactersVector(fbb, characters);</p>
<p>var movieOffset = Movie.CreateMovie(
fbb,
Character.Rapunzel,
rapunzel,
characterTypesOffset,
charactersOffset);
Movie.FinishMovieBuffer(fbb, movieOffset);</p>
<pre><code>&lt;/div&gt;
&lt;div class=&quot;language-kotlin&quot;&gt;
Kotlin supports vectors of unions, but it isn't currently documented.
&lt;/div&gt;
&lt;div class=&quot;language-swift&quot;&gt;
Swift supports vectors of unions, but it isn't currently documented.
&lt;/div&gt;

#### Reading
&lt;div class=&quot;language-csharp&quot;&gt;
~~~{.cs}
var movie = Movie.GetRootAsMovie(fbb.DataBuffer);

for (var i = 0; i &lt;= movie.CharactersLength; i++)
{
  if (movie.CharactersType(i) == Character.MuLan)
  {
    var mulanSwordDamage = movie.Characters&lt;Attacker&gt;(i).Value.SwordAttackDamage;
  }
  else if (movie.CharactersType(i) == Character.Belle)
  {
    var belleBooksRead = movie.Characters&lt;BookReader&gt;(i).Value.BooksRead;
  }
  else if (movie.CharactersType(i) == Character.Other)
  {
    var otherStr = movie.CharactersAsString(i);
  }
}
</code></pre>
</div>
<h3 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h3>
<p>Each language has a dedicated <code>Use in XXX</code> page in the Programmer's Guide
to cover the nuances of FlatBuffers in that language.</p>
<p>For your chosen language, see:</p>
<div class="language-cpp">
[Use in C++](@ref flatbuffers_guide_use_cpp)
</div>
<div class="language-java">
[Use in Java](@ref flatbuffers_guide_use_java)
</div>
<div class="language-kotlin">
[Use in Kotlin](@ref flatbuffers_guide_use_kotlin)
</div>
<div class="language-csharp">
[Use in C#](@ref flatbuffers_guide_use_c-sharp)
</div>
<div class="language-go">
[Use in Go](@ref flatbuffers_guide_use_go)
</div>
<div class="language-python">
[Use in Python](@ref flatbuffers_guide_use_python)
</div>
<div class="language-javascript">
[Use in JavaScript](@ref flatbuffers_guide_use_javascript)
</div>
<div class="language-typescript">
[Use in TypeScript](@ref flatbuffers_guide_use_typescript)
</div>
<div class="language-php">
[Use in PHP](@ref flatbuffers_guide_use_php)
</div>
<div class="language-c">
[Use in C](@ref flatbuffers_guide_use_c)
</div>
<div class="language-dart">
[Use in Dart](@ref flatbuffers_guide_use_dart)
</div>
<div class="language-lua">
[Use in Lua](@ref flatbuffers_guide_use_lua)
</div>
<div class="language-lobster">
[Use in Lobster](@ref flatbuffers_guide_use_lobster)
</div>
<div class="language-rust">
[Use in Rust](@ref flatbuffers_guide_use_rust)
</div>
<div class="language-swift">
[Use in Swift](@ref flatbuffers_guide_use_swift)
</div>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flatbuffers-white-paper----flatbuffers_white_paper"><a class="header" href="#flatbuffers-white-paper----flatbuffers_white_paper">FlatBuffers white paper    {#flatbuffers_white_paper}</a></h1>
<p>This document tries to shed some light on to the &quot;why&quot; of FlatBuffers, a
new serialization library.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Back in the good old days, performance was all about instructions and
cycles. Nowadays, processing units have run so far ahead of the memory
subsystem, that making an efficient application should start and finish
with thinking about memory. How much you use of it. How you lay it out
and access it. How you allocate it. When you copy it.</p>
<p>Serialization is a pervasive activity in a lot programs, and a common
source of memory inefficiency, with lots of temporary data structures
needed to parse and represent data, and inefficient allocation patterns
and locality.</p>
<p>If it would be possible to do serialization with no temporary objects,
no additional allocation, no copying, and good locality, this could be
of great value. The reason serialization systems usually don't manage
this is because it goes counter to forwards/backwards compatibility, and
platform specifics like endianness and alignment.</p>
<p>FlatBuffers is what you get if you try anyway.</p>
<p>In particular, FlatBuffers focus is on mobile hardware (where memory
size and memory bandwidth is even more constrained than on desktop
hardware), and applications that have the highest performance needs:
games.</p>
<h2 id="flatbuffers-1"><a class="header" href="#flatbuffers-1">FlatBuffers</a></h2>
<p><em>This is a summary of FlatBuffers functionality, with some rationale.
A more detailed description can be found in the FlatBuffers
documentation.</em></p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>A FlatBuffer is a binary buffer containing nested objects (structs,
tables, vectors,..) organized using offsets so that the data can be
traversed in-place just like any pointer-based data structure. Unlike
most in-memory data structures however, it uses strict rules of
alignment and endianness (always little) to ensure these buffers are
cross platform. Additionally, for objects that are tables, FlatBuffers
provides forwards/backwards compatibility and general optionality of
fields, to support most forms of format evolution.</p>
<p>You define your object types in a schema, which can then be compiled to
C++ or Java for low to zero overhead reading &amp; writing.
Optionally, JSON data can be dynamically parsed into buffers.</p>
<h3 id="tables-2"><a class="header" href="#tables-2">Tables</a></h3>
<p>Tables are the cornerstone of FlatBuffers, since format evolution is
essential for most applications of serialization. Typically, dealing
with format changes is something that can be done transparently during
the parsing process of most serialization solutions out there.
But a FlatBuffer isn't parsed before it is accessed.</p>
<p>Tables get around this by using an extra indirection to access fields,
through a <em>vtable</em>. Each table comes with a vtable (which may be shared
between multiple tables with the same layout), and contains information
where fields for this particular kind of instance of vtable are stored.
The vtable may also indicate that the field is not present (because this
FlatBuffer was written with an older version of the software, or simply
because the information was not necessary for this instance, or deemed
deprecated), in which case a default value is returned.</p>
<p>Tables have a low overhead in memory (since vtables are small and
shared) and in access cost (an extra indirection), but provide great
flexibility. Tables may even cost less memory than the equivalent
struct, since fields do not need to be stored when they are equal to
their default.</p>
<p>FlatBuffers additionally offers &quot;naked&quot; structs, which do not offer
forwards/backwards compatibility, but can be even smaller (useful for
very small objects that are unlikely to change, like e.g. a coordinate
pair or a RGBA color).</p>
<h3 id="schemas"><a class="header" href="#schemas">Schemas</a></h3>
<p>While schemas reduce some generality (you can't just read any data
without having its schema), they have a lot of upsides:</p>
<ul>
<li>
<p>Most information about the format can be factored into the generated
code, reducing memory needed to store data, and time to access it.</p>
</li>
<li>
<p>The strong typing of the data definitions means less error
checking/handling at runtime (less can go wrong).</p>
</li>
<li>
<p>A schema enables us to access a buffer without parsing.</p>
</li>
</ul>
<p>FlatBuffer schemas are fairly similar to those of the incumbent,
Protocol Buffers, and generally should be readable to those familiar
with the C family of languages. We chose to improve upon the features
offered by .proto files in the following ways:</p>
<ul>
<li>
<p>Deprecation of fields instead of manual field id assignment.
Extending an object in a .proto means hunting for a free slot among
the numbers (preferring lower numbers since they have a more compact
representation). Besides being inconvenient, it also makes removing
fields problematic: you either have to keep them, not making it
obvious that this field shouldn't be read/written anymore, and still
generating accessors. Or you remove it, but now you risk that
there's still old data around that uses that field by the time
someone reuses that field id, with nasty consequences.</p>
</li>
<li>
<p>Differentiating between tables and structs (see above). Effectively
all table fields are <code>optional</code>, and all struct fields are
<code>required</code>.</p>
</li>
<li>
<p>Having a native vector type instead of <code>repeated</code>. This gives you a
length without having to collect all items, and in the case of
scalars provides for a more compact representation, and one that
guarantees adjacency.</p>
</li>
<li>
<p>Having a native <code>union</code> type instead of using a series of <code>optional</code>
fields, all of which must be checked individually.</p>
</li>
<li>
<p>Being able to define defaults for all scalars, instead of having to
deal with their optionality at each access.</p>
</li>
<li>
<p>A parser that can deal with both schemas and data definitions (JSON
compatible) uniformly.</p>
</li>
</ul>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-c----flatbuffers_guide_use_cpp"><a class="header" href="#use-in-c----flatbuffers_guide_use_cpp">Use in C++    {#flatbuffers_guide_use_cpp}</a></h1>
<h2 id="before-you-get-started"><a class="header" href="#before-you-get-started">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in C++, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide
to general FlatBuffers usage in all of the supported languages (including C++).
This page is designed to cover the nuances of FlatBuffers usage, specific to
C++.</p>
<h4 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h4>
<p>This page assumes you have written a FlatBuffers schema and compiled it
with the Schema Compiler. If you have not, please see
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler)
and [Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<p>Assuming you wrote a schema, say <code>mygame.fbs</code> (though the extension doesn't
matter), you've generated a C++ header called <code>mygame_generated.h</code> using the
compiler (e.g. <code>flatc -c mygame.fbs</code>), you can now start using this in
your program by including the header. As noted, this header relies on
<code>flatbuffers/flatbuffers.h</code>, which should be in your include path.</p>
<h2 id="flatbuffers-c-library-code-location"><a class="header" href="#flatbuffers-c-library-code-location">FlatBuffers C++ library code location</a></h2>
<p>The code for the FlatBuffers C++ library can be found at
<code>flatbuffers/include/flatbuffers</code>. You can browse the library code on the
<a href="https://github.com/google/flatbuffers/tree/master/include/flatbuffers">FlatBuffers GitHub page</a>.</p>
<h2 id="testing-the-flatbuffers-c-library"><a class="header" href="#testing-the-flatbuffers-c-library">Testing the FlatBuffers C++ library</a></h2>
<p>The code to test the C++ library can be found at <code>flatbuffers/tests</code>.
The test code itself is located in
<a href="https://github.com/google/flatbuffers/blob/master/tests/test.cpp">test.cpp</a>.</p>
<p>This test file is built alongside <code>flatc</code>. To review how to build the project,
please read the [Building](@ref flatbuffers_guide_building) documentation.</p>
<p>To run the tests, execute <code>flattests</code> from the root <code>flatbuffers/</code> directory.
For example, on <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, you would simply
run: <code>./flattests</code>.</p>
<h2 id="using-the-flatbuffers-c-library"><a class="header" href="#using-the-flatbuffers-c-library">Using the FlatBuffers C++ library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in C++.</em></p>
<p>FlatBuffers supports both reading and writing FlatBuffers in C++.</p>
<p>To use FlatBuffers in your code, first generate the C++ classes from your
schema with the <code>--cpp</code> option to <code>flatc</code>. Then you can include both FlatBuffers
and the generated code to read or write FlatBuffers.</p>
<p>For example, here is how you would read a FlatBuffer binary file in C++:
First, include the library and generated code. Then read the file into
a <code>char *</code> array, which you pass to <code>GetMonster()</code>.</p>
<pre><code class="language-cpp">    #include &quot;flatbuffers/flatbuffers.h&quot;
    #include &quot;monster_test_generate.h&quot;
    #include &lt;iostream&gt; // C++ header file for printing
    #include &lt;fstream&gt; // C++ header file for file access


    std::ifstream infile;
    infile.open(&quot;monsterdata_test.mon&quot;, std::ios::binary | std::ios::in);
    infile.seekg(0,std::ios::end);
    int length = infile.tellg();
    infile.seekg(0,std::ios::beg);
    char *data = new char[length];
    infile.read(data, length);
    infile.close();

    auto monster = GetMonster(data);
</code></pre>
<p><code>monster</code> is of type <code>Monster *</code>, and points to somewhere <em>inside</em> your
buffer (root object pointers are not the same as <code>buffer_pointer</code> !).
If you look in your generated header, you'll see it has
convenient accessors for all fields, e.g. <code>hp()</code>, <code>mana()</code>, etc:</p>
<pre><code class="language-cpp">    std::cout &lt;&lt; &quot;hp : &quot; &lt;&lt; monster-&gt;hp() &lt;&lt; std::endl;              // '80'
    std::cout &lt;&lt; &quot;mana : &quot; &lt;&lt; monster-&gt;mana() &lt;&lt; std::endl;          // default value of '150'
    std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; monster-&gt;name()-&gt;c_str() &lt;&lt; std::endl; // &quot;MyMonster&quot;
</code></pre>
<p><em>Note: That we never stored a <code>mana</code> value, so it will return the default.</em></p>
<p>The following attributes are supported:</p>
<ul>
<li>
<p><code>shared</code> (on a field): For string fields, this enables the usage of string
pooling (i.e. <code>CreateSharedString</code>) as default serialization behavior.</p>
<p>Specifically, <code>CreateXxxDirect</code> functions and <code>Pack</code> functions for object
based API (see below) will use <code>CreateSharedString</code> to create strings.</p>
</li>
</ul>
<h2 id="object-based-api--flatbuffers_cpp_object_based_api"><a class="header" href="#object-based-api--flatbuffers_cpp_object_based_api">Object based API  {#flatbuffers_cpp_object_based_api}</a></h2>
<p>FlatBuffers is all about memory efficiency, which is why its base API is written
around using as little as possible of it. This does make the API clumsier
(requiring pre-order construction of all data, and making mutation harder).</p>
<p>For times when efficiency is less important a more convenient object based API
can be used (through <code>--gen-object-api</code>) that is able to unpack &amp; pack a
FlatBuffer into objects and standard STL containers, allowing for convenient
construction, access and mutation.</p>
<p>To use:</p>
<pre><code class="language-cpp">    // Autogenerated class from table Monster.
    MonsterT monsterobj;

    // Deserialize from buffer into object.
    GetMonster(flatbuffer)-&gt;UnPackTo(&amp;monsterobj);

    // Update object directly like a C++ class instance.
    cout &lt;&lt; monsterobj.name;  // This is now a std::string!
    monsterobj.name = &quot;Bob&quot;;  // Change the name.

    // Serialize into new flatbuffer.
    FlatBufferBuilder fbb;
    fbb.Finish(Monster::Pack(fbb, &amp;monsterobj));
</code></pre>
<p>The following attributes are specific to the object-based API code generation:</p>
<ul>
<li>
<p><code>native_inline</code> (on a field): Because FlatBuffer tables and structs are
optionally present in a given buffer, they are best represented as pointers
(specifically std::unique_ptrs) in the native class since they can be null.
This attribute changes the member declaration to use the type directly
rather than wrapped in a unique_ptr.</p>
</li>
<li>
<p><code>native_default(&quot;value&quot;)</code> (on a field): For members that are declared
&quot;native_inline&quot;, the value specified with this attribute will be included
verbatim in the class constructor initializer list for this member.</p>
</li>
<li>
<p><code>native_custom_alloc(&quot;custom_allocator&quot;)</code> (on a table or struct): When using the
object-based API all generated NativeTables that  are allocated when unpacking
your  flatbuffer will use &quot;custom allocator&quot;. The allocator is also used by
any std::vector that appears in a table defined with <code>native_custom_alloc</code>.
This can be  used to provide allocation from a pool for example, for faster
unpacking when using the object-based API.</p>
</li>
</ul>
<p>Minimal Example:</p>
<p>schema:</p>
<pre><code class="language-cpp">    table mytable(native_custom_alloc:&quot;custom_allocator&quot;) {
      ...
    }
</code></pre>
<p>with <code>custom_allocator</code> defined before <code>flatbuffers.h</code> is included, as:</p>
<pre><code class="language-cpp">    template &lt;typename T&gt; struct custom_allocator : public std::allocator&lt;T&gt; {

      typedef T *pointer;

      template &lt;class U&gt;
      struct rebind {
        typedef custom_allocator&lt;U&gt; other;
      };

      pointer allocate(const std::size_t n) {
        return std::allocator&lt;T&gt;::allocate(n);
      }

      void deallocate(T* ptr, std::size_t n) {
        return std::allocator&lt;T&gt;::deallocate(ptr,n);
      }

      custom_allocator() throw() {}

      template &lt;class U&gt;
      custom_allocator(const custom_allocator&lt;U&gt;&amp;) throw() {}
    };
</code></pre>
<ul>
<li><code>native_type(&quot;type&quot;)</code> (on a struct): In some cases, a more optimal C++ data
type exists for a given struct.  For example, the following schema:</li>
</ul>
<pre><code class="language-cpp">    struct Vec2 {
      x: float;
      y: float;
    }
</code></pre>
<p>generates the following Object-Based API class:</p>
<pre><code class="language-cpp">    struct Vec2T : flatbuffers::NativeTable {
      float x;
      float y;
    };
</code></pre>
<p>However, it can be useful to instead use a user-defined C++ type since it
can provide more functionality, eg.</p>
<pre><code class="language-cpp">    struct vector2 {
      float x = 0, y = 0;
      vector2 operator+(vector2 rhs) const { ... }
      vector2 operator-(vector2 rhs) const { ... }
      float length() const { ... }
      // etc.
    };
</code></pre>
<p>The <code>native_type</code> attribute will replace the usage of the generated class
with the given type.  So, continuing with the example, the generated
code would use <code>vector2</code> in place of <code>Vec2T</code> for all generated code of
the Object-Based API.</p>
<p>However, because the <code>native_type</code> is unknown to flatbuffers, the user must
provide the following functions to aide in the serialization process:</p>
<pre><code class="language-cpp">    namespace flatbuffers {
      Vec2 Pack(const vector2&amp; obj);
      vector2 UnPack(const Vec2&amp; obj);
    }
</code></pre>
<ul>
<li><code>native_type_pack_name(&quot;name&quot;)</code> (on a struct when <code>native_type</code> is
specified, too): when you want to use the same <code>native_type</code> multiple times
(e. g. with different precision) you must make the names of the Pack/UnPack
functions unique, otherwise you will run into compile errors. This attribute
appends a name to the expected Pack/UnPack functions. So when you
specify <code>native_type_pack_name(&quot;Vec2&quot;)</code> in the above example you now need to
implement these serialization functions instead:</li>
</ul>
<pre><code class="language-cpp">    namespace flatbuffers {
      Vec2 PackVec2(const vector2&amp; obj);
      vector2 UnPackVec2(const Vec2&amp; obj);
    }
</code></pre>
<p>Finally, the following top-level attributes:</p>
<ul>
<li>
<p><code>native_include(&quot;path&quot;)</code> (at file level): Because the <code>native_type</code> attribute
can be used to introduce types that are unknown to flatbuffers, it may be
necessary to include &quot;external&quot; header files in the generated code.  This
attribute can be used to directly add an #include directive to the top of
the generated code that includes the specified path directly.</p>
</li>
<li>
<p><code>force_align</code>: this attribute may not be respected in the object API,
depending on the aligned of the allocator used with <code>new</code>.</p>
</li>
</ul>
<h1 id="external-references"><a class="header" href="#external-references">External references</a></h1>
<p>An additional feature of the object API is the ability to allow you to load
multiple independent FlatBuffers, and have them refer to eachothers objects
using hashes which are then represented as typed pointers in the object API.</p>
<p>To make this work have a field in the objects you want to referred to which is
using the string hashing feature (see <code>hash</code> attribute in the
[schema](@ref flatbuffers_guide_writing_schema) documentation). Then you have
a similar hash in the field referring to it, along with a <code>cpp_type</code>
attribute specifying the C++ type this will refer to (this can be any C++
type, and will get a <code>*</code> added).</p>
<p>Then, in JSON or however you create these buffers, make sure they use the
same string (or hash).</p>
<p>When you call <code>UnPack</code> (or <code>Create</code>), you'll need a function that maps from
hash to the object (see <code>resolver_function_t</code> for details).</p>
<h1 id="using-different-pointer-types"><a class="header" href="#using-different-pointer-types">Using different pointer types</a></h1>
<p>By default the object tree is built out of <code>std::unique_ptr</code>, but you can
influence this either globally (using the <code>--cpp-ptr-type</code> argument to
<code>flatc</code>) or per field (using the <code>cpp_ptr_type</code> attribute) to by any smart
pointer type (<code>my_ptr&lt;T&gt;</code>), or by specifying <code>naked</code> as the type to get <code>T *</code>
pointers. Unlike the smart pointers, naked pointers do not manage memory for
you, so you'll have to manage their lifecycles manually.  To reference the
pointer type specified by the <code>--cpp-ptr-type</code> argument to <code>flatc</code> from a
flatbuffer field set the <code>cpp_ptr_type</code> attribute to <code>default_ptr_type</code>.</p>
<h1 id="using-different-string-type"><a class="header" href="#using-different-string-type">Using different string type</a></h1>
<p>By default the object tree is built out of <code>std::string</code>, but you can
influence this either globally (using the <code>--cpp-str-type</code> argument to
<code>flatc</code>) or per field using the <code>cpp_str_type</code> attribute.</p>
<p>The type must support <code>T::c_str()</code>, <code>T::length()</code> and <code>T::empty()</code> as member functions.</p>
<p>Further, the type must be constructible from std::string, as by default a
std::string instance is constructed and then used to initialize the custom
string type. This behavior impedes efficient and zero-copy construction of
custom string types; the <code>--cpp-str-flex-ctor</code> argument to <code>flatc</code> or the
per field attribute <code>cpp_str_flex_ctor</code> can be used to change this behavior,
so that the custom string type is constructed by passing the pointer and
length of the FlatBuffers String. The custom string class will require a
constructor in the following format: <code>custom_str_class(const char *, size_t)</code>.
Please note that the character array is not guaranteed to be NULL terminated,
you should always use the provided size to determine end of string.</p>
<h2 id="reflection--resizing"><a class="header" href="#reflection--resizing">Reflection (&amp; Resizing)</a></h2>
<p>There is experimental support for reflection in FlatBuffers, allowing you to
read and write data even if you don't know the exact format of a buffer, and
even allows you to change sizes of strings and vectors in-place.</p>
<p>The way this works is very elegant; there is actually a FlatBuffer schema that
describes schemas (!) which you can find in <code>reflection/reflection.fbs</code>.
The compiler, <code>flatc</code>, can write out any schemas it has just parsed as a binary
FlatBuffer, corresponding to this meta-schema.</p>
<p>Loading in one of these binary schemas at runtime allows you traverse any
FlatBuffer data that corresponds to it without knowing the exact format. You
can query what fields are present, and then read/write them after.</p>
<p>For convenient field manipulation, you can include the header
<code>flatbuffers/reflection.h</code> which includes both the generated code from the meta
schema, as well as a lot of helper functions.</p>
<p>And example of usage, for the time being, can be found in
<code>test.cpp/ReflectionTest()</code>.</p>
<h2 id="mini-reflection"><a class="header" href="#mini-reflection">Mini Reflection</a></h2>
<p>A more limited form of reflection is available for direct inclusion in
generated code, which doesn't do any (binary) schema access at all. It was designed
to keep the overhead of reflection as low as possible (on the order of 2-6
bytes per field added to your executable), but doesn't contain all the
information the (binary) schema contains.</p>
<p>You add this information to your generated code by specifying <code>--reflect-types</code>
(or instead <code>--reflect-names</code> if you also want field / enum names).</p>
<p>You can now use this information, for example to print a FlatBuffer to text:</p>
<pre><code>auto s = flatbuffers::FlatBufferToString(flatbuf, MonsterTypeTable());
</code></pre>
<p><code>MonsterTypeTable()</code> is declared in the generated code for each type. The
string produced is very similar to the JSON produced by the <code>Parser</code> based
text generator.</p>
<p>You'll need <code>flatbuffers/minireflect.h</code> for this functionality. In there is also
a convenient visitor/iterator so you can write your own output / functionality
based on the mini reflection tables without having to know the FlatBuffers or
reflection encoding.</p>
<h2 id="storing-maps--dictionaries-in-a-flatbuffer"><a class="header" href="#storing-maps--dictionaries-in-a-flatbuffer">Storing maps / dictionaries in a FlatBuffer</a></h2>
<p>FlatBuffers doesn't support maps natively, but there is support to
emulate their behavior with vectors and binary search, which means you
can have fast lookups directly from a FlatBuffer without having to unpack
your data into a <code>std::map</code> or similar.</p>
<p>To use it:</p>
<ul>
<li>Designate one of the fields in a table as they &quot;key&quot; field. You do this
by setting the <code>key</code> attribute on this field, e.g.
<code>name:string (key)</code>.
You may only have one key field, and it must be of string or scalar type.</li>
<li>Write out tables of this type as usual, collect their offsets in an
array or vector.</li>
<li>Instead of <code>CreateVector</code>, call <code>CreateVectorOfSortedTables</code>,
which will first sort all offsets such that the tables they refer to
are sorted by the key field, then serialize it.</li>
<li>Now when you're accessing the FlatBuffer, you can use <code>Vector::LookupByKey</code>
instead of just <code>Vector::Get</code> to access elements of the vector, e.g.:
<code>myvector-&gt;LookupByKey(&quot;Fred&quot;)</code>, which returns a pointer to the
corresponding table type, or <code>nullptr</code> if not found.
<code>LookupByKey</code> performs a binary search, so should have a similar speed to
<code>std::map</code>, though may be faster because of better caching. <code>LookupByKey</code>
only works if the vector has been sorted, it will likely not find elements
if it hasn't been sorted.</li>
</ul>
<h2 id="direct-memory-access"><a class="header" href="#direct-memory-access">Direct memory access</a></h2>
<p>As you can see from the above examples, all elements in a buffer are
accessed through generated accessors. This is because everything is
stored in little endian format on all platforms (the accessor
performs a swap operation on big endian machines), and also because
the layout of things is generally not known to the user.</p>
<p>For structs, layout is deterministic and guaranteed to be the same
across platforms (scalars are aligned to their
own size, and structs themselves to their largest member), and you
are allowed to access this memory directly by using <code>sizeof()</code> and
<code>memcpy</code> on the pointer to a struct, or even an array of structs.</p>
<p>To compute offsets to sub-elements of a struct, make sure they
are a structs themselves, as then you can use the pointers to
figure out the offset without having to hardcode it. This is
handy for use of arrays of structs with calls like <code>glVertexAttribPointer</code>
in OpenGL or similar APIs.</p>
<p>It is important to note is that structs are still little endian on all
machines, so only use tricks like this if you can guarantee you're not
shipping on a big endian machine (an <code>assert(FLATBUFFERS_LITTLEENDIAN)</code>
would be wise).</p>
<h2 id="access-of-untrusted-buffers"><a class="header" href="#access-of-untrusted-buffers">Access of untrusted buffers</a></h2>
<p>The generated accessor functions access fields over offsets, which is
very quick. These offsets are not verified at run-time, so a malformed
buffer could cause a program to crash by accessing random memory.</p>
<p>When you're processing large amounts of data from a source you know (e.g.
your own generated data on disk), this is acceptable, but when reading
data from the network that can potentially have been modified by an
attacker, this is undesirable.</p>
<p>For this reason, you can optionally use a buffer verifier before you
access the data. This verifier will check all offsets, all sizes of
fields, and null termination of strings to ensure that when a buffer
is accessed, all reads will end up inside the buffer.</p>
<p>Each root type will have a verification function generated for it,
e.g. for <code>Monster</code>, you can call:</p>
<pre><code class="language-cpp">	bool ok = VerifyMonsterBuffer(Verifier(buf, len));
</code></pre>
<p>if <code>ok</code> is true, the buffer is safe to read.</p>
<p>Besides untrusted data, this function may be useful to call in debug
mode, as extra insurance against data being corrupted somewhere along
the way.</p>
<p>While verifying a buffer isn't &quot;free&quot;, it is typically faster than
a full traversal (since any scalar data is not actually touched),
and since it may cause the buffer to be brought into cache before
reading, the actual overhead may be even lower than expected.</p>
<p>In specialized cases where a denial of service attack is possible,
the verifier has two additional constructor arguments that allow
you to limit the nesting depth and total amount of tables the
verifier may encounter before declaring the buffer malformed. The default is
<code>Verifier(buf, len, 64 /* max depth */, 1000000, /* max tables */)</code> which
should be sufficient for most uses.</p>
<h2 id="text--schema-parsing"><a class="header" href="#text--schema-parsing">Text &amp; schema parsing</a></h2>
<p>Using binary buffers with the generated header provides a super low
overhead use of FlatBuffer data. There are, however, times when you want
to use text formats, for example because it interacts better with source
control, or you want to give your users easy access to data.</p>
<p>Another reason might be that you already have a lot of data in JSON
format, or a tool that generates JSON, and if you can write a schema for
it, this will provide you an easy way to use that data directly.</p>
<p>(see the schema documentation for some specifics on the JSON format
accepted).</p>
<p>Schema evolution compatibility for the JSON format follows the same rules as the binary format (JSON formatted data will be forwards/backwards compatible with schemas that evolve in a compatible way).</p>
<p>There are two ways to use text formats:</p>
<h4 id="using-the-compiler-as-a-conversion-tool"><a class="header" href="#using-the-compiler-as-a-conversion-tool">Using the compiler as a conversion tool</a></h4>
<p>This is the preferred path, as it doesn't require you to add any new
code to your program, and is maximally efficient since you can ship with
binary data. The disadvantage is that it is an extra step for your
users/developers to perform, though you might be able to automate it.</p>
<pre><code>flatc -b myschema.fbs mydata.json
</code></pre>
<p>This will generate the binary file <code>mydata_wire.bin</code> which can be loaded
as before.</p>
<h4 id="making-your-program-capable-of-loading-text-directly"><a class="header" href="#making-your-program-capable-of-loading-text-directly">Making your program capable of loading text directly</a></h4>
<p>This gives you maximum flexibility. You could even opt to support both,
i.e. check for both files, and regenerate the binary from text when
required, otherwise just load the binary.</p>
<p>This option is currently only available for C++, or Java through JNI.</p>
<p>As mentioned in the section &quot;Building&quot; above, this technique requires
you to link a few more files into your program, and you'll want to include
<code>flatbuffers/idl.h</code>.</p>
<p>Load text (either a schema or json) into an in-memory buffer (there is a
convenient <code>LoadFile()</code> utility function in <code>flatbuffers/util.h</code> if you
wish). Construct a parser:</p>
<pre><code class="language-cpp">    flatbuffers::Parser parser;
</code></pre>
<p>Now you can parse any number of text files in sequence:</p>
<pre><code class="language-cpp">    parser.Parse(text_file.c_str());
</code></pre>
<p>This works similarly to how the command-line compiler works: a sequence
of files parsed by the same <code>Parser</code> object allow later files to
reference definitions in earlier files. Typically this means you first
load a schema file (which populates <code>Parser</code> with definitions), followed
by one or more JSON files.</p>
<p>As optional argument to <code>Parse</code>, you may specify a null-terminated list of
include paths. If not specified, any include statements try to resolve from
the current directory.</p>
<p>If there were any parsing errors, <code>Parse</code> will return <code>false</code>, and
<code>Parser::error_</code> contains a human readable error string with a line number
etc, which you should present to the creator of that file.</p>
<p>After each JSON file, the <code>Parser::fbb</code> member variable is the
<code>FlatBufferBuilder</code> that contains the binary buffer version of that
file, that you can access as described above.</p>
<p><code>samples/sample_text.cpp</code> is a code sample showing the above operations.</p>
<h2 id="threading"><a class="header" href="#threading">Threading</a></h2>
<p>Reading a FlatBuffer does not touch any memory outside the original buffer,
and is entirely read-only (all const), so is safe to access from multiple
threads even without synchronisation primitives.</p>
<p>Creating a FlatBuffer is not thread safe. All state related to building
a FlatBuffer is contained in a FlatBufferBuilder instance, and no memory
outside of it is touched. To make this thread safe, either do not
share instances of FlatBufferBuilder between threads (recommended), or
manually wrap it in synchronisation primitives. There's no automatic way to
accomplish this, by design, as we feel multithreaded construction
of a single buffer will be rare, and synchronisation overhead would be costly.</p>
<h2 id="advanced-union-features"><a class="header" href="#advanced-union-features">Advanced union features</a></h2>
<p>The C++ implementation currently supports vectors of unions (i.e. you can
declare a field as <code>[T]</code> where <code>T</code> is a union type instead of a table type). It
also supports structs and strings in unions, besides tables.</p>
<p>For an example of these features, see <code>tests/union_vector</code>, and
<code>UnionVectorTest</code> in <code>test.cpp</code>.</p>
<p>Since these features haven't been ported to other languages yet, if you
choose to use them, you won't be able to use these buffers in other languages
(<code>flatc</code> will refuse to compile a schema that uses these features).</p>
<p>These features reduce the amount of &quot;table wrapping&quot; that was previously
needed to use unions.</p>
<p>To use scalars, simply wrap them in a struct.</p>
<h2 id="depth-limit-of-nested-objects-and-stack-overflow-control"><a class="header" href="#depth-limit-of-nested-objects-and-stack-overflow-control">Depth limit of nested objects and stack-overflow control</a></h2>
<p>The parser of Flatbuffers schema or json-files is kind of recursive parser.
To avoid stack-overflow problem the parser has a built-in limiter of
recursion depth. Number of nested declarations in a schema or number of
nested json-objects is limited. By default, this depth limit set to <code>64</code>.
It is possible to override this limit with <code>FLATBUFFERS_MAX_PARSING_DEPTH</code>
definition. This definition can be helpful for testing purposes or embedded
applications. For details see [build](@ref flatbuffers_guide_building) of
CMake-based projects.</p>
<h2 id="dependence-from-c-locale-flatbuffers_locale_cpp"><a class="header" href="#dependence-from-c-locale-flatbuffers_locale_cpp">Dependence from C-locale {#flatbuffers_locale_cpp}</a></h2>
<p>The Flatbuffers [grammar](@ref flatbuffers grammar) uses ASCII
character set for identifiers, alphanumeric literals, reserved words.</p>
<p>Internal implementation of the Flatbuffers depends from functions which
depend from C-locale: <code>strtod()</code> or <code>strtof()</code>, for example.
The library expects the dot <code>.</code> symbol as the separator of an integer
part from the fractional part of a float number.
Another separator symbols (<code>,</code> for example) will break the compatibility
and may lead to an error while parsing a Flatbuffers schema or a json file.</p>
<p>The Standard C locale is a global resource, there is only one locale for
the entire application. Some modern compilers and platforms have
locale-independent or locale-narrow functions <code>strtof_l</code>, <code>strtod_l</code>,
<code>strtoll_l</code>, <code>strtoull_l</code> to resolve this dependency.
These functions use specified locale rather than the global or per-thread
locale instead. They are part of POSIX-2008 but not part of the C/C++
standard library, therefore, may be missing on some platforms.
The Flatbuffers library try to detect these functions at configuration and
compile time:</p>
<ul>
<li>CMake <code>&quot;CMakeLists.txt&quot;</code>:
<ul>
<li>Check existence of <code>strtol_l</code> and <code>strtod_l</code> in the <code>&lt;stdlib.h&gt;</code>.</li>
</ul>
</li>
<li>Compile-time <code>&quot;/include/base.h&quot;</code>:
<ul>
<li><code>_MSC_VER &gt;= 1900</code>: MSVC2012 or higher if build with MSVC.</li>
<li><code>_XOPEN_SOURCE&gt;=700</code>: POSIX-2008 if build with GCC/Clang.</li>
</ul>
</li>
</ul>
<p>After detection, the definition <code>FLATBUFFERS_LOCALE_INDEPENDENT</code> will be
set to <code>0</code> or <code>1</code>.
To override or stop this detection use CMake <code>-DFLATBUFFERS_LOCALE_INDEPENDENT={0|1}</code>
or predefine <code>FLATBUFFERS_LOCALE_INDEPENDENT</code> symbol.</p>
<p>To test the compatibility of the Flatbuffers library with
a specific locale use the environment variable <code>FLATBUFFERS_TEST_LOCALE</code>:</p>
<pre><code class="language-sh">&gt;FLATBUFFERS_TEST_LOCALE=&quot;&quot; ./flattests
&gt;FLATBUFFERS_TEST_LOCALE=&quot;ru_RU.CP1251&quot; ./flattests
</code></pre>
<h2 id="support-of-floating-point-numbers"><a class="header" href="#support-of-floating-point-numbers">Support of floating-point numbers</a></h2>
<p>The Flatbuffers library assumes that a C++ compiler and a CPU are
compatible with the <code>IEEE-754</code> floating-point standard.
The schema and json parser may fail if <code>fast-math</code> or <code>/fp:fast</code> mode is active.</p>
<h3 id="support-of-hexadecimal-and-special-floating-point-numbers"><a class="header" href="#support-of-hexadecimal-and-special-floating-point-numbers">Support of hexadecimal and special floating-point numbers</a></h3>
<p>According to the [grammar](@ref flatbuffers_grammar) <code>fbs</code> and <code>json</code> files
may use hexadecimal and special (<code>NaN</code>, <code>Inf</code>) floating-point literals.
The Flatbuffers uses <code>strtof</code> and <code>strtod</code> functions to parse floating-point
literals. The Flatbuffers library has a code to detect a compiler compatibility
with the literals. If necessary conditions are met the preprocessor constant
<code>FLATBUFFERS_HAS_NEW_STRTOD</code> will be set to <code>1</code>.
The support of floating-point literals will be limited at compile time
if <code>FLATBUFFERS_HAS_NEW_STRTOD</code> constant is less than <code>1</code>.
In this case, schemas with hexadecimal or special literals cannot be used.</p>
<h3 id="comparison-of-floating-point-nan-values"><a class="header" href="#comparison-of-floating-point-nan-values">Comparison of floating-point NaN values</a></h3>
<p>The floating-point <code>NaN</code> (<code>not a number</code>) is special value which
representing an undefined or unrepresentable value.
<code>NaN</code> may be explicitly assigned to variables, typically as a representation
for missing values or may be a result of a mathematical operation.
The <code>IEEE-754</code> defines two kind of <code>NaNs</code>:</p>
<ul>
<li>Quiet NaNs, or <code>qNaNs</code>.</li>
<li>Signaling NaNs, or <code>sNaNs</code>.</li>
</ul>
<p>According to the <code>IEEE-754</code>, a comparison with <code>NaN</code> always returns
an unordered result even when compared with itself. As a result, a whole
Flatbuffers object will be not equal to itself if has one or more <code>NaN</code>.
Flatbuffers scalar fields that have the default value are not actually stored
in the serialized data but are generated in code (see [Writing a schema](@ref flatbuffers_guide_writing_schema)).
Scalar fields with <code>NaN</code> defaults break this behavior.
If a schema has a lot of <code>NaN</code> defaults the Flatbuffers can override
the unordered comparison by the ordered: <code>(NaN==NaN)-&gt;true</code>.
This ordered comparison is enabled when compiling a program with the symbol
<code>FLATBUFFERS_NAN_DEFAULTS</code> defined.
Additional computations added by <code>FLATBUFFERS_NAN_DEFAULTS</code> are very cheap
if GCC or Clang used. These compilers have a compile-time implementation
of <code>isnan</code> checking which MSVC does not.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-c----flatbuffers_guide_use_c-sharp"><a class="header" href="#use-in-c----flatbuffers_guide_use_c-sharp">Use in C#    {#flatbuffers_guide_use_c-sharp}</a></h1>
<h2 id="before-you-get-started-1"><a class="header" href="#before-you-get-started-1">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in C#, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide to
general FlatBuffers usage in all of the supported languages (including C#).
This page is designed to cover the nuances of FlatBuffers usage,
specific to C#.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-c-code-location"><a class="header" href="#flatbuffers-c-code-location">FlatBuffers C# code location</a></h2>
<p>The code for the FlatBuffers C# library can be found at
<code>flatbuffers/net/FlatBuffers</code>. You can browse the library on the
[FlatBuffers GitHub page](https://github.com/google/flatbuffers/tree/master/net/
FlatBuffers).</p>
<h2 id="building-the-flatbuffers-c-library"><a class="header" href="#building-the-flatbuffers-c-library">Building the FlatBuffers C# library</a></h2>
<p>The <code>FlatBuffers.csproj</code> project contains multitargeting for .NET Standard 2.1,
.NET Standard 2.0, and .NET Framework 4.6 (Unity 2017). Support for .NET
Framework 3.5 (Unity 5) is provided by the <code>FlatBuffers.net35.csproj</code> project.
In most cases (including Unity 2018 and newer), .NET Standard 2.0 is
recommended.</p>
<p>You can build for a specific framework target when using the cross-platform
<a href="https://dotnet.microsoft.com/download">.NET Core SDK</a> by adding the <code>-f</code>
command line option:</p>
<pre><code class="language-{.sh}">    dotnet build -f netstandard2.0 &quot;FlatBuffers.csproj&quot;
</code></pre>
<p>The <code>FlatBuffers.csproj</code> project also provides support for defining various
conditional compilation symbols (see &quot;Conditional compilation symbols&quot; section
below) using the <code>-p</code> command line option:</p>
<pre><code class="language-{.sh}">    dotnet build -f netstandard2.1 -p:ENABLE_SPAN_T=true -p:UNSAFE_BYTEBUFFER=true &quot;FlatBuffers.csproj&quot;
</code></pre>
<h2 id="testing-the-flatbuffers-c-library-1"><a class="header" href="#testing-the-flatbuffers-c-library-1">Testing the FlatBuffers C# library</a></h2>
<p>The code to test the libraries can be found at <code>flatbuffers/tests</code>.</p>
<p>The test code for C# is located in the [FlatBuffers.Test](https://github.com/
google/flatbuffers/tree/master/tests/FlatBuffers.Test) subfolder. To run the
tests, open <code>FlatBuffers.Test.csproj</code> in <a href="https://www.visualstudio.com">Visual Studio</a>, and compile/run the project.</p>
<p>Optionally, you can run this using <a href="http://www.mono-project.com/">Mono</a> instead.
Once you have installed Mono, you can run the tests from the command line
by running the following commands from inside the <code>FlatBuffers.Test</code> folder:</p>
<pre><code class="language-{.sh}">    mcs *.cs ../MyGame/Example/*.cs ../../net/FlatBuffers/*.cs
    mono Assert.exe
</code></pre>
<h2 id="using-the-flatbuffers-c-library-1"><a class="header" href="#using-the-flatbuffers-c-library-1">Using the FlatBuffers C# library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in C#.</em></p>
<p>FlatBuffers supports reading and writing binary FlatBuffers in C#.</p>
<p>To use FlatBuffers in your own code, first generate C# classes from your
schema with the <code>--csharp</code> option to <code>flatc</code>.
Then you can include both FlatBuffers and the generated code to read
or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in C#:
First, import the library and generated code. Then, you read a FlatBuffer binary
file into a <code>byte[]</code>.  You then turn the <code>byte[]</code> into a <code>ByteBuffer</code>, which you
pass to the <code>GetRootAsMyRootType</code> function:</p>
<pre><code class="language-{.cs}">    using MyGame.Example;
    using FlatBuffers;

    // This snippet ignores exceptions for brevity.
    byte[] data = File.ReadAllBytes(&quot;monsterdata_test.mon&quot;);

    ByteBuffer bb = new ByteBuffer(data);
    Monster monster = Monster.GetRootAsMonster(bb);
</code></pre>
<p>Now you can access the data from the <code>Monster monster</code>:</p>
<pre><code class="language-{.cs}">    short hp = monster.Hp;
    Vec3 pos = monster.Pos;
</code></pre>
<p>C# code naming follows standard C# style with PascalCasing identifiers,
e.g. <code>GetRootAsMyRootType</code>. Also, values (except vectors and unions) are
available as properties instead of parameterless accessor methods.
The performance-enhancing methods to which you can pass an already created
object are prefixed with <code>Get</code>, e.g.:</p>
<pre><code class="language-{.cs}">    // property
    var pos = monster.Pos;

    // method filling a preconstructed object
    var preconstructedPos = new Vec3();
    monster.GetPos(preconstructedPos);
</code></pre>
<h2 id="storing-dictionaries-in-a-flatbuffer"><a class="header" href="#storing-dictionaries-in-a-flatbuffer">Storing dictionaries in a FlatBuffer</a></h2>
<p>FlatBuffers doesn't support dictionaries natively, but there is support to
emulate their behavior with vectors and binary search, which means you
can have fast lookups directly from a FlatBuffer without having to unpack
your data into a <code>Dictionary</code> or similar.</p>
<p>To use it:</p>
<ul>
<li>Designate one of the fields in a table as the &quot;key&quot; field. You do this
by setting the <code>key</code> attribute on this field, e.g.
<code>name:string (key)</code>.
You may only have one key field, and it must be of string or scalar type.</li>
<li>Write out tables of this type as usual, collect their offsets in an
array.</li>
<li>Instead of calling standard generated method,
e.g.: <code>Monster.createTestarrayoftablesVector</code>,
call <code>CreateSortedVectorOfMonster</code> in C#
which will first sort all offsets such that the tables they refer to
are sorted by the key field, then serialize it.</li>
<li>Now when you're accessing the FlatBuffer, you can use
the <code>ByKey</code> accessor to access elements of the vector, e.g.:
<code>monster.TestarrayoftablesByKey(&quot;Frodo&quot;)</code> in C#,
which returns an object of the corresponding table type,
or <code>null</code> if not found.
<code>ByKey</code> performs a binary search, so should have a similar
speed to <code>Dictionary</code>, though may be faster because of better caching.
<code>ByKey</code> only works if the vector has been sorted, it will
likely not find elements if it hasn't been sorted.</li>
</ul>
<h2 id="text-parsing"><a class="header" href="#text-parsing">Text parsing</a></h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly
from C#, though you could use the C++ parser through native call
interfaces available to each language. Please see the
C++ documentation for more on text parsing.</p>
<h2 id="object-based-api"><a class="header" href="#object-based-api">Object based API</a></h2>
<p>FlatBuffers is all about memory efficiency, which is why its base API is written
around using as little as possible of it. This does make the API clumsier
(requiring pre-order construction of all data, and making mutation harder).</p>
<p>For times when efficiency is less important a more convenient object based API
can be used (through <code>--gen-object-api</code>) that is able to unpack &amp; pack a
FlatBuffer into objects and standard <code>System.Collections.Generic</code> containers,
allowing for convenient construction, access and mutation.</p>
<p>To use:</p>
<pre><code class="language-{.cs}">    // Deserialize from buffer into object.
    MonsterT monsterobj = GetMonster(flatbuffer).UnPack();

    // Update object directly like a C# class instance.
    Console.WriteLine(monsterobj.Name);
    monsterobj.Name = &quot;Bob&quot;;  // Change the name.

    // Serialize into new flatbuffer.
    FlatBufferBuilder fbb = new FlatBufferBuilder(1);
    fbb.Finish(Monster.Pack(fbb, monsterobj).Value);
</code></pre>
<h3 id="json-serialization"><a class="header" href="#json-serialization">Json Serialization</a></h3>
<p>An additional feature of the object API is the ability to allow you to
serialize &amp; deserialize a JSON text.
To use Json Serialization, add <code>--cs-gen-json-serializer</code> option to <code>flatc</code> and
add <code>Newtonsoft.Json</code> nuget package to csproj. This requires explicitly setting
the <code>--gen-object-api</code> option as well.</p>
<pre><code class="language-{.cs}">    // Deserialize MonsterT from json
    string jsonText = File.ReadAllText(@&quot;Resources/monsterdata_test.json&quot;);
    MonsterT mon = MonsterT.DeserializeFromJson(jsonText);

    // Serialize MonsterT to json
    string jsonText2 = mon.SerializeToJson();
</code></pre>
<ul>
<li>Limitation
<ul>
<li><code>hash</code> attribute currently not supported.</li>
</ul>
</li>
<li>NuGet package Dependency
<ul>
<li><a href="https://github.com/JamesNK/Newtonsoft.Json">Newtonsoft.Json</a></li>
</ul>
</li>
</ul>
<h2 id="conditional-compilation-symbols"><a class="header" href="#conditional-compilation-symbols">Conditional compilation symbols</a></h2>
<p>There are three conditional compilation symbols that have an impact on
performance/features of the C# <code>ByteBuffer</code> implementation.</p>
<ul>
<li>
<p><code>UNSAFE_BYTEBUFFER</code></p>
<p>This will use unsafe code to manipulate the underlying byte array. This can
yield a reasonable performance increase.</p>
</li>
<li>
<p><code>BYTEBUFFER_NO_BOUNDS_CHECK</code></p>
<p>This will disable the bounds check asserts to the byte array. This can yield a
small performance gain in normal code.</p>
</li>
<li>
<p><code>ENABLE_SPAN_T</code></p>
<p>This will enable reading and writing blocks of memory with a <code>Span&lt;T&gt;</code> instead
of just <code>T[]</code>. You can also enable writing directly to shared memory or other
types of memory by providing a custom implementation of <code>ByteBufferAllocator</code>.
<code>ENABLE_SPAN_T</code> also requires <code>UNSAFE_BYTEBUFFER</code> to be defined, or .NET
Standard 2.1.</p>
</li>
</ul>
<p>Using <code>UNSAFE_BYTEBUFFER</code> and <code>BYTEBUFFER_NO_BOUNDS_CHECK</code> together can yield a
performance gain of ~15% for some operations, however doing so is potentially
dangerous. Do so at your own risk!</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-c----flatbuffers_guide_use_c"><a class="header" href="#use-in-c----flatbuffers_guide_use_c">Use in C    {#flatbuffers_guide_use_c}</a></h1>
<p>The C language binding exists in a separate project named <a href="https://github.com/dvidelabs/flatcc">FlatCC</a>.</p>
<p>The <code>flatcc</code> C schema compiler can generate code offline as well as
online via a C library. It can also generate buffer verifiers and fast
JSON parsers, printers.</p>
<p>Great care has been taken to ensure compatibility with the main <code>flatc</code>
project.</p>
<h2 id="general-documention"><a class="header" href="#general-documention">General Documention</a></h2>
<ul>
<li>[Tutorial](@ref flatbuffers_guide_tutorial) - select C as language
when scrolling down</li>
<li><a href="https://github.com/dvidelabs/flatcc#flatcc-flatbuffers-in-c-for-c">FlatCC Guide</a></li>
<li><a href="https://github.com/dvidelabs/flatcc/blob/master/doc/builder.md#the-builder-interface">The C Builder Interface</a></li>
<li><a href="https://github.com/dvidelabs/flatcc/blob/master/samples/monster/monster.c">The Monster Sample in C</a></li>
<li><a href="https://github.com/dvidelabs/flatcc">GitHub</a></li>
</ul>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h2>
<ul>
<li>Ubuntu (clang / gcc, ninja / gnu make)</li>
<li>OS-X (clang / gcc, ninja / gnu make)</li>
<li>Windows MSVC 2010, 2013, 2015</li>
</ul>
<p>CI builds recent versions of gcc, clang and MSVC on OS-X, Ubuntu, and
Windows, and occasionally older compiler versions. See main project <a href="https://github.com/dvidelabs/flatcc#status">Status</a>.</p>
<p>Other platforms may well work, including Centos, but are not tested
regularly.</p>
<p>The monster sample project was specifically written for C99 in order to
follow the C++ version and for that reason it will not work with MSVC
2010.</p>
<h2 id="modular-object-creation"><a class="header" href="#modular-object-creation">Modular Object Creation</a></h2>
<p>In the tutorial we used the call <code>Monster_create_as_root</code> to create the
root buffer object since this is easier in simple use cases. Sometimes
we need more modularity so we can reuse a function to create nested
tables and root tables the same way. For this we need the
<code>flatcc_builder_buffer_create_call</code>. It is best to keep <code>flatcc_builder</code>
calls isolated at the top driver level, so we get:</p>
<div class="language-c">
~~~{.c}
  ns(Monster_ref_t) create_orc(flatcc_builder_t *B)
  {
    // ... same as in the tutorial.
    return s(Monster_create(B, ...));
  }
<p>void create_monster_buffer()
{
uint8_t *buf;
size_t size;
flatcc_builder_t builder, *B;</p>
<pre><code>  // Initialize the builder object.
  B = &amp;builder;
  flatcc_builder_init(B);
  // Only use `buffer_create` without `create/start/end_as_root`.
  flatcc_builder_buffer_create(create_orc(B));
  // Allocate and copy buffer to user memory.
  buf = flatcc_builder_finalize_buffer(B, &amp;size);
  // ... write the buffer to disk or network, or something.

  free(buf);
  flatcc_builder_clear(B);
</code></pre>
<p>}</p>
<pre><code>&lt;/div&gt;

The same principle applies with `start/end` vs `start/end_as_root` in
the top-down approach.


## Top Down Example

The tutorial uses a bottom up approach. In C it is also possible to use
a top-down approach by starting and ending objects nested within each
other. In the tutorial there is no deep nesting, so the difference is
limited, but it shows the idea:

&lt;div class=&quot;language-c&quot;&gt;
&lt;br&gt;
~~~{.c}
  uint8_t treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  size_t treasure_count = c_vec_len(treasure);
  ns(Weapon_ref_t) axe;

  // NOTE: if we use end_as_root, we MUST also start as root.
  ns(Monster_start_as_root(B));
  ns(Monster_pos_create(B, 1.0f, 2.0f, 3.0f));
  ns(Monster_hp_add(B, 300));
  ns(Monster_mana_add(B, 150));
  // We use create_str instead of add because we have no existing string reference.
  ns(Monster_name_create_str(B, &quot;Orc&quot;));
  // Again we use create because we no existing vector object, only a C-array.
  ns(Monster_inventory_create(B, treasure, treasure_count));
  ns(Monster_color_add(B, ns(Color_Red)));
  if (1) {
      ns(Monster_weapons_start(B));
      ns(Monster_weapons_push_create(B, flatbuffers_string_create_str(B, &quot;Sword&quot;), 3));
      // We reuse the axe object later. Note that we dereference a pointer
      // because push always returns a short-term pointer to the stored element.
      // We could also have created the axe object first and simply pushed it.
      axe = *ns(Monster_weapons_push_create(B, flatbuffers_string_create_str(B, &quot;Axe&quot;), 5));
      ns(Monster_weapons_end(B));
  } else {
      // We can have more control with the table elements added to a vector:
      //
      ns(Monster_weapons_start(B));
      ns(Monster_weapons_push_start(B));
      ns(Weapon_name_create_str(B, &quot;Sword&quot;));
      ns(Weapon_damage_add(B, 3));
      ns(Monster_weapons_push_end(B));
      ns(Monster_weapons_push_start(B));
      ns(Monster_weapons_push_start(B));
      ns(Weapon_name_create_str(B, &quot;Axe&quot;));
      ns(Weapon_damage_add(B, 5));
      axe = *ns(Monster_weapons_push_end(B));
      ns(Monster_weapons_end(B));
  }
  // Unions can get their type by using a type-specific add/create/start method.
  ns(Monster_equipped_Weapon_add(B, axe));

  ns(Monster_end_as_root(B));
</code></pre>
</div>
<h2 id="basic-reflection"><a class="header" href="#basic-reflection">Basic Reflection</a></h2>
<p>The C-API does support reading binary schema (.bfbs)
files via code generated from the <code>reflection.fbs</code> schema, and an
<a href="https://github.com/dvidelabs/flatcc/tree/master/samples/reflection">example usage</a>
shows how to use this. The reflection schema files are pre-generated
in the <a href="https://github.com/dvidelabs/flatcc/tree/master/include/flatcc/reflection">runtime distribution</a>.</p>
<h2 id="mutations-and-reflection"><a class="header" href="#mutations-and-reflection">Mutations and Reflection</a></h2>
<p>The C-API does not support mutating reflection like C++ does, nor does
the reader interface support mutating scalars (and it is generally
unsafe to do so even after verification).</p>
<p>The generated reader interface supports sorting vectors in-place after
casting them to a mutating type because it is not practical to do so
while building a buffer. This is covered in the builder documentation.<br />
The reflection example makes use of this feature to look up objects by
name.</p>
<p>It is possible to build new buffers using complex objects from existing
buffers as source. This can be very efficient due to direct copy
semantics without endian conversion or temporary stack allocation.</p>
<p>Scalars, structs and strings can be used as source, as well vectors of
these.</p>
<p>It is currently not possible to use an existing table or vector of table
as source, but it would be possible to add support for this at some
point.</p>
<h2 id="namespaces-1"><a class="header" href="#namespaces-1">Namespaces</a></h2>
<p>The <code>FLATBUFFERS_WRAP_NAMESPACE</code> approach used in the tutorial is convenient
when each function has a very long namespace prefix. But it isn't always
the best approach. If the namespace is absent, or simple and
informative, we might as well use the prefix directly. The
<a href="https://github.com/dvidelabs/flatcc/blob/master/samples/reflection/bfbs2json.c">reflection example</a>
mentioned above uses this approach.</p>
<h2 id="checking-for-present-members"><a class="header" href="#checking-for-present-members">Checking for Present Members</a></h2>
<p>Not all languages support testing if a field is present, but in C we can
elaborate the reader section of the tutorial with tests for this. Recall
that <code>mana</code> was set to the default value <code>150</code> and therefore shouldn't
be present.</p>
<div class="language-c">
~~~{.c}
  int hp_present = ns(Monster_hp_is_present(monster)); // 1
  int mana_present = ns(Monster_mana_is_present(monster)); // 0
~~~
</div>
<h2 id="alternative-ways-to-add-a-union"><a class="header" href="#alternative-ways-to-add-a-union">Alternative ways to add a Union</a></h2>
<p>In the tutorial we used a single call to add a union.  Here we show
different ways to accomplish the same thing. The last form is rarely
used, but is the low-level way to do it. It can be used to group small
values together in the table by adding type and data at different
points in time.</p>
<div class="language-c">
~~~{.c}
   ns(Equipment_union_ref_t) equipped = ns(Equipment_as_Weapon(axe));
   ns(Monster_equipped_add(B, equipped));
   // or alternatively
   ns(Monster_equipped_Weapon_add(B, axe);
   // or alternatively
   ns(Monster_equipped_add_type(B, ns(Equipment_Weapon));
   ns(Monster_equipped_add_member(B, axe));
~~~
</div>
<h2 id="why-not-integrate-with-the-flatc-tool"><a class="header" href="#why-not-integrate-with-the-flatc-tool">Why not integrate with the <code>flatc</code> tool?</a></h2>
<p><a href="https://github.com/dvidelabs/flatcc/issues/1">It was considered how the C code generator could be integrated into the
<code>flatc</code> tool</a>, but it
would either require that the standalone C implementation of the schema
compiler was dropped, or it would lead to excessive code duplication, or
a complicated intermediate representation would have to be invented.
Neither of these alternatives are very attractive, and it isn't a big
deal to use the <code>flatcc</code> tool instead of <code>flatc</code> given that the
FlatBuffers C runtime library needs to be made available regardless.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-dart----flatbuffers_guide_use_dart"><a class="header" href="#use-in-dart----flatbuffers_guide_use_dart">Use in Dart    {#flatbuffers_guide_use_dart}</a></h1>
<h2 id="before-you-get-started-2"><a class="header" href="#before-you-get-started-2">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in Dart, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide
to general FlatBuffers usage in all of the supported languages (including Dart).
This page is designed to cover the nuances of FlatBuffers usage, specific to
Dart.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-dart-library-code-location"><a class="header" href="#flatbuffers-dart-library-code-location">FlatBuffers Dart library code location</a></h2>
<p>The code for the FlatBuffers Dart library can be found at
<code>flatbuffers/dart</code>. You can browse the library code on the <a href="https://github.com/google/flatbuffers/tree/master/dart">FlatBuffers
GitHub page</a>.</p>
<h2 id="testing-the-flatbuffers-dart-library"><a class="header" href="#testing-the-flatbuffers-dart-library">Testing the FlatBuffers Dart library</a></h2>
<p>The code to test the Dart library can be found at <code>flatbuffers/tests</code>.
The test code itself is located in [dart_test.dart](https://github.com/google/
flatbuffers/blob/master/tests/dart_test.dart).</p>
<p>To run the tests, use the [DartTest.sh](https://github.com/google/flatbuffers/
blob/master/tests/DartTest.sh) shell script.</p>
<p><em>Note: The shell script requires the <a href="https://www.dartlang.org/tools/sdk">Dart SDK</a>
to be installed.</em></p>
<h2 id="using-the-flatbuffers-dart-library"><a class="header" href="#using-the-flatbuffers-dart-library">Using the FlatBuffers Dart library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in Dart.</em></p>
<p>FlatBuffers supports reading and writing binary FlatBuffers in Dart.</p>
<p>To use FlatBuffers in your own code, first generate Dart classes from your
schema with the <code>--dart</code> option to <code>flatc</code>. Then you can include both FlatBuffers
and the generated code to read or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Dart: First,
include the library and generated code. Then read a FlatBuffer binary file into
a <code>List&lt;int&gt;</code>, which you pass to the factory constructor for <code>Monster</code>:</p>
<pre><code class="language-{.dart}">import 'dart:io' as io;

import 'package:flat_buffers/flat_buffers.dart' as fb;
import './monster_my_game.sample_generated.dart' as myGame;

List&lt;int&gt; data = await new io.File('monster.dat').readAsBytes();
var monster = new myGame.Monster(data);
</code></pre>
<p>Now you can access values like this:</p>
<pre><code class="language-{.dart}">var hp = monster.hp;
var pos = monster.pos;
</code></pre>
<h2 id="differences-from-the-dart-sdk-front-end-flat_buffers"><a class="header" href="#differences-from-the-dart-sdk-front-end-flat_buffers">Differences from the Dart SDK Front End flat_buffers</a></h2>
<p>The work in this repository is signfiicantly based on the implementation used
internally by the Dart SDK in the front end/analyzer package. Several
significant changes have been made.</p>
<ol>
<li>Support for packed boolean lists has been removed.  This is not standard
in other implementations and is not compatible with them.  Do note that,
like in the JavaScript implementation, <strong>null values in boolean lists
will be treated as false</strong>.  It is also still entirely possible to pack data
in a single scalar field, but that would have to be done on the application
side.</li>
<li>The SDK implementation supports enums with regular Dart enums, which
works if enums are always indexed at 1; however, FlatBuffers does not
require that.  This implementation uses specialized enum-like classes to
ensure proper mapping from FlatBuffers to Dart and other platforms.</li>
<li>The SDK implementation does not appear to support FlatBuffer structs or
vectors of structs - it treated everything as a built-in scalar or a table.
This implementation treats structs in a way that is compatible with other
non-Dart implementations, and properly handles vectors of structs.  Many of
the methods prefixed with 'low' have been prepurposed to support this.</li>
<li>The SDK implementation treats int64 and uint64 as float64s. This
implementation does not.  This may cause problems with JavaScript
compatibility - however, it should be possible to use the JavaScript
implementation, or to do a customized implementation that treats all 64 bit
numbers as floats.  Supporting the Dart VM and Flutter was a more important
goal of this implementation.  Support for 16 bit integers was also added.</li>
<li>The code generation in this offers an &quot;ObjectBuilder&quot;, which generates code
very similar to the SDK classes that consume FlatBuffers, as well as Builder
classes, which produces code which more closely resembles the builders in 
other languages. The ObjectBuilder classes are easier to use, at the cost of
additional references allocated.</li>
</ol>
<h2 id="text-parsing-1"><a class="header" href="#text-parsing-1">Text Parsing</a></h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly
from Dart, though you could use the C++ parser through Dart Native Extensions.
Please see the C++ documentation for more on text parsing (note that this is
not currently an option in Flutter - follow <a href="https://github.com/flutter/flutter/issues/7053">this issue</a>
for the latest).</p>
<h2 id="object-based-api-1"><a class="header" href="#object-based-api-1">Object based API</a></h2>
<p>FlatBuffers is all about memory efficiency, which is why its base API is written
around using as little as possible of it. This does make the API clumsier
(requiring pre-order construction of all data, and making mutation harder).</p>
<p>For times when efficiency is less important a more convenient object based API
can be used (through <code>--gen-object-api</code>) that is able to unpack &amp; pack a FlatBuffer
into objects and lists, allowing for convenient construction, access and mutation.</p>
<p>To use:</p>
<pre><code class="language-{.dart}">    // Deserialize from buffer into object.
    MonsterT monster = Monster(flatbuffer).unpack();

    // Update object directly like a Dart class instance.
    print(monster.Name);
    monster.Name = &quot;Bob&quot;;  // Change the name.

    // Serialize into new flatbuffer.
    final fbb = Builder();
    fbb.Finish(monster.pack(fbb));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-go----flatbuffers_guide_use_go"><a class="header" href="#use-in-go----flatbuffers_guide_use_go">Use in Go    {#flatbuffers_guide_use_go}</a></h1>
<h2 id="before-you-get-started-3"><a class="header" href="#before-you-get-started-3">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in Go, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide
to general FlatBuffers usage in all of the supported languages (including Go).
This page is designed to cover the nuances of FlatBuffers usage, specific to
Go.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-go-library-code-location"><a class="header" href="#flatbuffers-go-library-code-location">FlatBuffers Go library code location</a></h2>
<p>The code for the FlatBuffers Go library can be found at
<code>flatbuffers/go</code>. You can browse the library code on the <a href="https://github.com/google/flatbuffers/tree/master/go">FlatBuffers
GitHub page</a>.</p>
<h2 id="testing-the-flatbuffers-go-library"><a class="header" href="#testing-the-flatbuffers-go-library">Testing the FlatBuffers Go library</a></h2>
<p>The code to test the Go library can be found at <code>flatbuffers/tests</code>.
The test code itself is located in [go_test.go](https://github.com/google/
flatbuffers/blob/master/tests/go_test.go).</p>
<p>To run the tests, use the [GoTest.sh](https://github.com/google/flatbuffers/
blob/master/tests/GoTest.sh) shell script.</p>
<p><em>Note: The shell script requires <a href="https://golang.org/doc/install">Go</a> to
be installed.</em></p>
<h2 id="using-the-flatbuffers-go-library"><a class="header" href="#using-the-flatbuffers-go-library">Using the FlatBuffers Go library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in Go.</em></p>
<p>FlatBuffers supports reading and writing binary FlatBuffers in Go.</p>
<p>To use FlatBuffers in your own code, first generate Go classes from your
schema with the <code>--go</code> option to <code>flatc</code>. Then you can include both FlatBuffers
and the generated code to read or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Go: First,
include the library and generated code. Then read a FlatBuffer binary file into
a <code>[]byte</code>, which you pass to the <code>GetRootAsMonster</code> function:</p>
<pre><code class="language-{.go}">    import (
       example &quot;MyGame/Example&quot;
       flatbuffers &quot;github.com/google/flatbuffers/go&quot;

       &quot;os&quot;
    )

    buf, err := os.ReadFile(&quot;monster.dat&quot;)
    // handle err
    monster := example.GetRootAsMonster(buf, 0)
</code></pre>
<p>Now you can access values like this:</p>
<pre><code class="language-{.go}">    hp := monster.Hp()
    pos := monster.Pos(nil)
</code></pre>
<p>In some cases it's necessary to modify values in an existing FlatBuffer in place (without creating a copy). For this reason, scalar fields of a Flatbuffer table or struct can be mutated.</p>
<pre><code class="language-{.go}">    monster := example.GetRootAsMonster(buf, 0)

    // Set table field.
    if ok := monster.MutateHp(10); !ok {
      panic(&quot;failed to mutate Hp&quot;)
    }

    // Set struct field.
    monster.Pos().MutateZ(4)

    // This mutation will fail because the mana field is not available in
    // the buffer. It should be set when creating the buffer.
    if ok := monster.MutateMana(20); !ok {
      panic(&quot;failed to mutate Hp&quot;)
    }
</code></pre>
<p>The term <code>mutate</code> is used instead of <code>set</code> to indicate that this is a special use case. All mutate functions return a boolean value which is false if the field we're trying to mutate is not available in the buffer.</p>
<h2 id="text-parsing-2"><a class="header" href="#text-parsing-2">Text Parsing</a></h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly
from Go, though you could use the C++ parser through cgo. Please see the
C++ documentation for more on text parsing.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-javascript----flatbuffers_guide_use_javascript"><a class="header" href="#use-in-javascript----flatbuffers_guide_use_javascript">Use in JavaScript    {#flatbuffers_guide_use_javascript}</a></h1>
<h2 id="before-you-get-started-4"><a class="header" href="#before-you-get-started-4">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in JavaScript, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide to
general FlatBuffers usage in all of the supported languages
(including JavaScript). This page is specifically designed to cover the nuances
of FlatBuffers usage in JavaScript.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-javascript-library-code-location"><a class="header" href="#flatbuffers-javascript-library-code-location">FlatBuffers JavaScript library code location</a></h2>
<p>The generated code for the FlatBuffers JavaScript library can be found at 
https://www.npmjs.com/package/flatbuffers. To use it from sources:</p>
<ol>
<li>Run <code>npm run compile</code> from the main folder to generate JS files from TS.</li>
<li>In your project, install it as a normal dependency, using the flatbuffers
folder as the source.</li>
</ol>
<h2 id="using-the-flatbuffers-javascript-library"><a class="header" href="#using-the-flatbuffers-javascript-library">Using the FlatBuffers JavaScript library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers.</em></p>
<p>Due to the complexity related with large amounts of JS flavors and module types,
native JS support has been replaced in 2.0 by transpilation from TypeScript.</p>
<p>Please look at [TypeScript usage](@ref flatbuffers_guide_use_typescript) and
transpile your sources to desired JS flavor. The minimal steps to get up and
running with JS are:</p>
<ol>
<li>Generate TS files from <code>*.fbs</code> by using the <code>--ts</code> option.</li>
<li>Transpile resulting TS files to desired JS flavor using <code>tsc</code> (see 
https://www.typescriptlang.org/download for installation instructions).</li>
</ol>
<pre><code class="language-{.js}">  // Note: These require functions are an example - use your desired module flavor.
  var fs = require('fs');

  var flatbuffers = require('../flatbuffers').flatbuffers;
  var MyGame = require('./monster_generated').MyGame;

  var data = new Uint8Array(fs.readFileSync('monster.dat'));
  var buf = new flatbuffers.ByteBuffer(data);

  var monster = MyGame.Example.Monster.getRootAsMonster(buf);

  //--------------------------------------------------------------------------//

  // Note: This code is an example of browser-based HTML/JavaScript. See above
  //       for the code using JavaScript module loaders (e.g. Node.js).
  &lt;script src=&quot;../js/flatbuffers.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;monster_generated.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    function readFile() {
      var reader = new FileReader(); // This example uses the HTML5 FileReader.
      var file = document.getElementById(
          'file_input').files[0]; // &quot;monster.dat&quot; from the HTML &lt;input&gt; field.

      reader.onload = function() { // Executes after the file is read.
        var data = new Uint8Array(reader.result);

        var buf = new flatbuffers.ByteBuffer(data);

        var monster = MyGame.Example.Monster.getRootAsMonster(buf);
      }

      reader.readAsArrayBuffer(file);
    }
  &lt;/script&gt;

  // Open the HTML file in a browser and select &quot;monster.dat&quot; from with the
  // &lt;input&gt; field.
  &lt;input type=&quot;file&quot; id=&quot;file_input&quot; onchange=&quot;readFile();&quot;&gt;
</code></pre>
<p>Now you can access values like this:</p>
<pre><code class="language-{.js}">  var hp = monster.hp();
  var pos = monster.pos();
</code></pre>
<h2 id="text-parsing-flatbuffers-in-javascript"><a class="header" href="#text-parsing-flatbuffers-in-javascript">Text parsing FlatBuffers in JavaScript</a></h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly
from JavaScript.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-java----flatbuffers_guide_use_java"><a class="header" href="#use-in-java----flatbuffers_guide_use_java">Use in Java    {#flatbuffers_guide_use_java}</a></h1>
<h2 id="before-you-get-started-5"><a class="header" href="#before-you-get-started-5">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in Java, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide to
general FlatBuffers usage in all of the supported languages (including Java).
This page is designed to cover the nuances of FlatBuffers usage,
specific to Java.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-java-code-location"><a class="header" href="#flatbuffers-java-code-location">FlatBuffers Java code location</a></h2>
<p>The code for the FlatBuffers Java library can be found at
<code>flatbuffers/java/com/google/flatbuffers</code>. You can browse the library on the
[FlatBuffers GitHub page](https://github.com/google/flatbuffers/tree/master/
java/com/google/flatbuffers).</p>
<h2 id="testing-the-flatbuffers-java-libraries"><a class="header" href="#testing-the-flatbuffers-java-libraries">Testing the FlatBuffers Java libraries</a></h2>
<p>The code to test the libraries can be found at <code>flatbuffers/tests</code>.</p>
<p>The test code for Java is located in [JavaTest.java](https://github.com/google
/flatbuffers/blob/master/tests/JavaTest.java).</p>
<p>To run the tests, use either [JavaTest.sh](https://github.com/google/
flatbuffers/blob/master/tests/JavaTest.sh) or [JavaTest.bat](https://github.com/
google/flatbuffers/blob/master/tests/JavaTest.bat), depending on your operating
system.</p>
<p><em>Note: These scripts require that <a href="https://www.oracle.com/java/index.html">Java</a>
is installed.</em></p>
<h2 id="using-the-flatbuffers-java-library"><a class="header" href="#using-the-flatbuffers-java-library">Using the FlatBuffers Java library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in Java.</em></p>
<p>FlatBuffers supports reading and writing binary FlatBuffers in Java.</p>
<p>To use FlatBuffers in your own code, first generate Java classes from your
schema with the <code>--java</code> option to <code>flatc</code>.
Then you can include both FlatBuffers and the generated code to read
or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Java:
First, import the library and generated code. Then, you read a FlatBuffer binary
file into a <code>byte[]</code>.  You then turn the <code>byte[]</code> into a <code>ByteBuffer</code>, which you
pass to the <code>getRootAsMyRootType</code> function:</p>
<pre><code class="language-{.java}">    import MyGame.Example.*;
    import com.google.flatbuffers.FlatBufferBuilder;

    // This snippet ignores exceptions for brevity.
    File file = new File(&quot;monsterdata_test.mon&quot;);
    RandomAccessFile f = new RandomAccessFile(file, &quot;r&quot;);
    byte[] data = new byte[(int)f.length()];
    f.readFully(data);
    f.close();

    ByteBuffer bb = ByteBuffer.wrap(data);
    Monster monster = Monster.getRootAsMonster(bb);
</code></pre>
<p>Now you can access the data from the <code>Monster monster</code>:</p>
<pre><code class="language-{.java}">    short hp = monster.hp();
    Vec3 pos = monster.pos();
</code></pre>
<h2 id="storing-dictionaries-in-a-flatbuffer-1"><a class="header" href="#storing-dictionaries-in-a-flatbuffer-1">Storing dictionaries in a FlatBuffer</a></h2>
<p>FlatBuffers doesn't support dictionaries natively, but there is support to
emulate their behavior with vectors and binary search, which means you
can have fast lookups directly from a FlatBuffer without having to unpack
your data into a <code>Dictionary</code> or similar.</p>
<p>To use it:</p>
<ul>
<li>Designate one of the fields in a table as the &quot;key&quot; field. You do this
by setting the <code>key</code> attribute on this field, e.g.
<code>name:string (key)</code>.
You may only have one key field, and it must be of string or scalar type.</li>
<li>Write out tables of this type as usual, collect their offsets in an
array.</li>
<li>Instead of calling standard generated method,
e.g.: <code>Monster.createTestarrayoftablesVector</code>,
call <code>createSortedVectorOfTables</code> (from the <code>FlatBufferBuilder</code> object).
which will first sort all offsets such that the tables they refer to
are sorted by the key field, then serialize it.</li>
<li>Now when you're accessing the FlatBuffer, you can use
the <code>ByKey</code> accessor to access elements of the vector, e.g.:
<code>monster.testarrayoftablesByKey(&quot;Frodo&quot;)</code>.
which returns an object of the corresponding table type,
or <code>null</code> if not found.
<code>ByKey</code> performs a binary search, so should have a similar
speed to <code>Dictionary</code>, though may be faster because of better caching.
<code>ByKey</code> only works if the vector has been sorted, it will
likely not find elements if it hasn't been sorted.</li>
</ul>
<h2 id="text-parsing-3"><a class="header" href="#text-parsing-3">Text parsing</a></h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly
from Java, though you could use the C++ parser through native call
interfaces available to each language. Please see the
C++ documentation for more on text parsing.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-kotlin----flatbuffers_guide_use_kotlin"><a class="header" href="#use-in-kotlin----flatbuffers_guide_use_kotlin">Use in Kotlin    {#flatbuffers_guide_use_kotlin}</a></h1>
<h2 id="before-you-get-started-6"><a class="header" href="#before-you-get-started-6">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in Kotlin, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide to
general FlatBuffers usage in all of the supported languages (including K).</p>
<p>This page is designed to cover the nuances of FlatBuffers usage, specific to Kotlin.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="kotlin-and-flatbuffers-java-code-location"><a class="header" href="#kotlin-and-flatbuffers-java-code-location">Kotlin and FlatBuffers Java code location</a></h2>
<p>Code generated for Kotlin currently uses the flatbuffers java runtime library. That means that Kotlin generated code can only have Java virtual machine as target architecture (which includes Android). Kotlin Native and Kotlin.js are currently not supported.</p>
<p>The code for the FlatBuffers Java library can be found at
<code>flatbuffers/java/com/google/flatbuffers</code>. You can browse the library on the
[FlatBuffers GitHub page](https://github.com/google/flatbuffers/tree/master/
java/com/google/flatbuffers).</p>
<h2 id="testing-flatbuffers-kotlin"><a class="header" href="#testing-flatbuffers-kotlin">Testing FlatBuffers Kotlin</a></h2>
<p>The test code for Java is located in [KotlinTest.java](https://github.com/google
/flatbuffers/blob/master/tests/KotlinTest.kt).</p>
<p>To run the tests, use  [KotlinTest.sh](https://github.com/google/
flatbuffers/blob/master/tests/KotlinTest.sh) shell script.</p>
<p><em>Note: These scripts require that <a href="https://kotlinlang.org/">Kotlin</a> is installed.</em></p>
<h2 id="using-the-flatbuffers-kotlin-library"><a class="header" href="#using-the-flatbuffers-kotlin-library">Using the FlatBuffers Kotlin library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in Kotlin.</em></p>
<p>FlatBuffers supports reading and writing binary FlatBuffers in Kotlin.</p>
<p>To use FlatBuffers in your own code, first generate Java classes from your
schema with the <code>--kotlin</code> option to <code>flatc</code>.
Then you can include both FlatBuffers and the generated code to read
or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Kotlin:
First, import the library and generated code. Then, you read a FlatBuffer binary
file into a <code>ByteArray</code>.  You then turn the <code>ByteArray</code> into a <code>ByteBuffer</code>, which you
pass to the <code>getRootAsMyRootType</code> function:</p>
<pre><code class="language-{.kt}">    import MyGame.Example.*
    import com.google.flatbuffers.FlatBufferBuilder

    // This snippet ignores exceptions for brevity.
    val data = RandomAccessFile(File(&quot;monsterdata_test.mon&quot;), &quot;r&quot;).use {
        val temp = ByteArray(it.length().toInt())
        it.readFully(temp)
        temp
    }

    val bb = ByteBuffer.wrap(data)
    val monster = Monster.getRootAsMonster(bb)
</code></pre>
<p>Now you can access the data from the <code>Monster monster</code>:</p>
<pre><code class="language-{.kt}">    val hp = monster.hp
    val pos = monster.pos!!;
</code></pre>
<h2 id="differences-between-kotlin-and-java-code"><a class="header" href="#differences-between-kotlin-and-java-code">Differences between Kotlin and Java code</a></h2>
<p>Kotlin generated code was designed to be as close as possible to the java counterpart, as for now, we only support kotlin on java virtual machine. So the differences in implementation and usage are basically the ones introduced by the Kotlin language itself. You can find more in-depth information <a href="https://kotlinlang.org/docs/reference/comparison-to-java.html">here</a>.</p>
<p>The most obvious ones are:</p>
<ul>
<li>Fields as accessed as Kotlin <a href="https://kotlinlang.org/docs/reference/properties.html">properties</a></li>
<li>Static methods are accessed in <a href="https://kotlinlang.org/docs/reference/classes.html#companion-objects">companion object</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-lobster----flatbuffers_guide_use_lobster"><a class="header" href="#use-in-lobster----flatbuffers_guide_use_lobster">Use in Lobster    {#flatbuffers_guide_use_lobster}</a></h1>
<h2 id="before-you-get-started-7"><a class="header" href="#before-you-get-started-7">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in Lobster, it should be noted that the
[Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide to general
FlatBuffers usage in all of the supported languages (including Lobster). This
page is designed to cover the nuances of FlatBuffers usage, specific to
Lobster.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-lobster-library-code-location"><a class="header" href="#flatbuffers-lobster-library-code-location">FlatBuffers Lobster library code location</a></h2>
<p>The code for the FlatBuffers Lobster library can be found at
<code>flatbuffers/lobster</code>. You can browse the library code on the
[FlatBuffers GitHub page](https://github.com/google/flatbuffers/tree/master/
lobster).</p>
<h2 id="testing-the-flatbuffers-lobster-library"><a class="header" href="#testing-the-flatbuffers-lobster-library">Testing the FlatBuffers Lobster library</a></h2>
<p>The code to test the Lobster library can be found at <code>flatbuffers/tests</code>.
The test code itself is located in [lobstertest.lobster](https://github.com/google/
flatbuffers/blob/master/tests/lobstertest.lobster).</p>
<p>To run the tests, run <code>lobster lobstertest.lobster</code>. To obtain Lobster itself,
go to the <a href="http://strlen.com/lobster">Lobster homepage</a> or
<a href="https://github.com/aardappel/lobster">github</a> to learn how to build it for your
platform.</p>
<h2 id="using-the-flatbuffers-lobster-library"><a class="header" href="#using-the-flatbuffers-lobster-library">Using the FlatBuffers Lobster library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in Lobster.</em></p>
<p>There is support for both reading and writing FlatBuffers in Lobster.</p>
<p>To use FlatBuffers in your own code, first generate Lobster classes from your
schema with the <code>--lobster</code> option to <code>flatc</code>. Then you can include both
FlatBuffers and the generated code to read or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Lobster:
First, import the library and the generated code. Then read a FlatBuffer binary
file into a string, which you pass to the <code>GetRootAsMonster</code> function:</p>
<pre><code class="language-{.lobster}">    include &quot;monster_generated.lobster&quot;

    let fb = read_file(&quot;monsterdata_test.mon&quot;)
    assert fb
    let monster = MyGame_Example_GetRootAsMonster(fb)
</code></pre>
<p>Now you can access values like this:</p>
<pre><code class="language-{.lobster}">    let hp = monster.hp
    let pos = monster.pos
</code></pre>
<p>As you can see, even though <code>hp</code> and <code>pos</code> are functions that access FlatBuffer
data in-place in the string buffer, they appear as field accesses.</p>
<h2 id="speed"><a class="header" href="#speed">Speed</a></h2>
<p>Using FlatBuffers in Lobster should be relatively fast, as the implementation
makes use of native support for writing binary values, and access of vtables.
Both generated code and the runtime library are therefore small and fast.</p>
<p>Actual speed will depend on whether you use Lobster as bytecode VM or compiled to
C++.</p>
<h2 id="text-parsing-4"><a class="header" href="#text-parsing-4">Text Parsing</a></h2>
<p>Lobster has full support for parsing JSON into FlatBuffers, or generating
JSON from FlatBuffers. See <code>samples/sample_test.lobster</code> for an example.</p>
<p>This uses the C++ parser and generator underneath, so should be both fast and
conformant.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-lua----flatbuffers_guide_use_lua"><a class="header" href="#use-in-lua----flatbuffers_guide_use_lua">Use in Lua    {#flatbuffers_guide_use_lua}</a></h1>
<h2 id="before-you-get-started-8"><a class="header" href="#before-you-get-started-8">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in Lua, it should be noted that the
[Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide to general
FlatBuffers usage in all of the supported languages (including Lua). This
page is designed to cover the nuances of FlatBuffers usage, specific to
Lua.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-lua-library-code-location"><a class="header" href="#flatbuffers-lua-library-code-location">FlatBuffers Lua library code location</a></h2>
<p>The code for the FlatBuffers Lua library can be found at
<code>flatbuffers/lua</code>. You can browse the library code on the
<a href="https://github.com/google/flatbuffers/tree/master/lua">FlatBuffers GitHub page</a>.</p>
<h2 id="testing-the-flatbuffers-lua-library"><a class="header" href="#testing-the-flatbuffers-lua-library">Testing the FlatBuffers Lua library</a></h2>
<p>The code to test the Lua library can be found at <code>flatbuffers/tests</code>.
The test code itself is located in [luatest.lua](https://github.com/google/
flatbuffers/blob/master/tests/luatest.lua).</p>
<p>To run the tests, use the [LuaTest.sh](https://github.com/google/flatbuffers/
blob/master/tests/LuaTest.sh) shell script.</p>
<p><em>Note: This script requires <a href="https://www.lua.org/">Lua 5.3</a> and
<a href="http://luajit.org/">LuaJIT</a> to be installed.</em></p>
<h2 id="using-the-flatbuffers-lua-library"><a class="header" href="#using-the-flatbuffers-lua-library">Using the FlatBuffers Lua library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in Lua.</em></p>
<p>There is support for both reading and writing FlatBuffers in Lua.</p>
<p>To use FlatBuffers in your own code, first generate Lua classes from your
schema with the <code>--lua</code> option to <code>flatc</code>. Then you can include both
FlatBuffers and the generated code to read or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Lua:
First, require the module and the generated code. Then read a FlatBuffer binary
file into a <code>string</code>, which you pass to the <code>GetRootAsMonster</code> function:</p>
<pre><code class="language-{.lua}">    -- require the library
    local flatbuffers = require(&quot;flatbuffers&quot;)
    
    -- require the generated code
    local monster = require(&quot;MyGame.Sample.Monster&quot;)

    -- read the flatbuffer from a file into a string
    local f = io.open('monster.dat', 'rb')
    local buf = f:read('*a')
    f:close()

    -- parse the flatbuffer to get an instance to the root monster
    local monster1 = monster.GetRootAsMonster(buf, 0)
</code></pre>
<p>Now you can access values like this:</p>
<pre><code class="language-{.lua}">    -- use the : notation to access member data
    local hp = monster1:Hp()
    local pos = monster1:Pos()
</code></pre>
<h2 id="text-parsing-5"><a class="header" href="#text-parsing-5">Text Parsing</a></h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly
from Lua, though you could use the C++ parser through SWIG or ctypes. Please
see the C++ documentation for more on text parsing.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-php----flatbuffers_guide_use_php"><a class="header" href="#use-in-php----flatbuffers_guide_use_php">Use in PHP    {#flatbuffers_guide_use_php}</a></h1>
<h2 id="before-you-get-started-9"><a class="header" href="#before-you-get-started-9">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in PHP, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide to
general FlatBuffers usage in all of the supported languages
(including PHP). This page is specifically designed to cover the nuances of
FlatBuffers usage in PHP.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-php-library-code-location"><a class="header" href="#flatbuffers-php-library-code-location">FlatBuffers PHP library code location</a></h2>
<p>The code for FlatBuffers PHP library can be found at <code>flatbuffers/php</code>. You
can browse the library code on the <a href="https://github.com/google/flatbuffers/tree/master/php">FlatBuffers
GitHub page</a>.</p>
<h2 id="testing-the-flatbuffers-javascript-library"><a class="header" href="#testing-the-flatbuffers-javascript-library">Testing the FlatBuffers JavaScript library</a></h2>
<p>The code to test the PHP library can be found at <code>flatbuffers/tests</code>.
The test code itself is located in [phpTest.php](https://github.com/google/
flatbuffers/blob/master/tests/phpTest.php).</p>
<p>You can run the test with <code>php phpTest.php</code> from the command line.</p>
<p><em>Note: The PHP test file requires
<a href="http://php.net/manual/en/install.php">PHP</a> to be installed.</em></p>
<h2 id="using-theflatbuffers-php-library"><a class="header" href="#using-theflatbuffers-php-library">Using theFlatBuffers PHP library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in PHP.</em></p>
<p>FlatBuffers supports both reading and writing FlatBuffers in PHP.</p>
<p>To use FlatBuffers in your own code, first generate PHP classes from your schema
with the <code>--php</code> option to <code>flatc</code>. Then you can include both FlatBuffers and
the generated code to read or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in PHP:
First, include the library and generated code (using the PSR <code>autoload</code>
function). Then you can read a FlatBuffer binary file, which you
pass the contents of to the <code>GetRootAsMonster</code> function:</p>
<pre><code class="language-{.php}">  // It is recommended that your use PSR autoload when using FlatBuffers in PHP.
  // Here is an example:
  function __autoload($class_name) {
    // The last segment of the class name matches the file name.
    $class = substr($class_name, strrpos($class_name, &quot;\\&quot;) + 1);
    $root_dir = join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)))); // `flatbuffers` root.

    // Contains the `*.php` files for the FlatBuffers library and the `flatc` generated files.
    $paths = array(join(DIRECTORY_SEPARATOR, array($root_dir, &quot;php&quot;)),
                   join(DIRECTORY_SEPARATOR, array($root_dir, &quot;tests&quot;, &quot;MyGame&quot;, &quot;Example&quot;)));
    foreach ($paths as $path) {
      $file = join(DIRECTORY_SEPARATOR, array($path, $class . &quot;.php&quot;));
      if (file_exists($file)) {
        require($file);
        break;
    }
  }

  // Read the contents of the FlatBuffer binary file.
  $filename = &quot;monster.dat&quot;;
  $handle = fopen($filename, &quot;rb&quot;);
  $contents = $fread($handle, filesize($filename));
  fclose($handle);

  // Pass the contents to `GetRootAsMonster`.
  $monster = \MyGame\Example\Monster::GetRootAsMonster($contents);
</code></pre>
<p>Now you can access values like this:</p>
<pre><code class="language-{.php}">  $hp = $monster-&gt;GetHp();
  $pos = $monster-&gt;GetPos();
</code></pre>
<h2 id="text-parsing-6"><a class="header" href="#text-parsing-6">Text Parsing</a></h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly
from PHP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-python----flatbuffers_guide_use_python"><a class="header" href="#use-in-python----flatbuffers_guide_use_python">Use in Python    {#flatbuffers_guide_use_python}</a></h1>
<h2 id="before-you-get-started-10"><a class="header" href="#before-you-get-started-10">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in Python, it should be noted that the
[Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide to general
FlatBuffers usage in all of the supported languages (including Python). This
page is designed to cover the nuances of FlatBuffers usage, specific to
Python.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-python-library-code-location"><a class="header" href="#flatbuffers-python-library-code-location">FlatBuffers Python library code location</a></h2>
<p>The code for the FlatBuffers Python library can be found at
<code>flatbuffers/python/flatbuffers</code>. You can browse the library code on the
[FlatBuffers GitHub page](https://github.com/google/flatbuffers/tree/master/
python).</p>
<h2 id="testing-the-flatbuffers-python-library"><a class="header" href="#testing-the-flatbuffers-python-library">Testing the FlatBuffers Python library</a></h2>
<p>The code to test the Python library can be found at <code>flatbuffers/tests</code>.
The test code itself is located in [py_test.py](https://github.com/google/
flatbuffers/blob/master/tests/py_test.py).</p>
<p>To run the tests, use the [PythonTest.sh](https://github.com/google/flatbuffers/
blob/master/tests/PythonTest.sh) shell script.</p>
<p><em>Note: This script requires <a href="https://www.python.org/">python</a> to be
installed.</em></p>
<h2 id="using-the-flatbuffers-python-library"><a class="header" href="#using-the-flatbuffers-python-library">Using the FlatBuffers Python library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in Python.</em></p>
<p>There is support for both reading and writing FlatBuffers in Python.</p>
<p>To use FlatBuffers in your own code, first generate Python classes from your
schema with the <code>--python</code> option to <code>flatc</code>. Then you can include both
FlatBuffers and the generated code to read or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Python:
First, import the library and the generated code. Then read a FlatBuffer binary
file into a <code>bytearray</code>, which you pass to the <code>GetRootAsMonster</code> function:</p>
<pre><code class="language-{.py}">    import MyGame.Example as example
    import flatbuffers

    buf = open('monster.dat', 'rb').read()
    buf = bytearray(buf)
    monster = example.GetRootAsMonster(buf, 0)
</code></pre>
<p>Now you can access values like this:</p>
<pre><code class="language-{.py}">    hp = monster.Hp()
    pos = monster.Pos()
</code></pre>
<h2 id="support-for-numpy-arrays"><a class="header" href="#support-for-numpy-arrays">Support for Numpy arrays</a></h2>
<p>The Flatbuffers python library also has support for accessing scalar
vectors as numpy arrays. This can be orders of magnitude faster than
iterating over the vector one element at a time, and is particularly
useful when unpacking large nested flatbuffers. The generated code for
a scalar vector will have a method <code>&lt;vector name&gt;AsNumpy()</code>. In the
case of the Monster example, you could access the inventory vector
like this:</p>
<pre><code class="language-{.py}">    inventory = monster.InventoryAsNumpy()
    # inventory is a numpy array of type np.dtype('uint8')
</code></pre>
<p>instead of</p>
<pre><code class="language-{.py}">    inventory = []
    for i in range(monster.InventoryLength()):
        inventory.append(int(monster.Inventory(i)))
</code></pre>
<p>Numpy is not a requirement. If numpy is not installed on your system,
then attempting to access one of the <code>*asNumpy()</code> methods will result
in a <code>NumpyRequiredForThisFeature</code> exception.</p>
<h2 id="text-parsing-7"><a class="header" href="#text-parsing-7">Text Parsing</a></h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly
from Python, though you could use the C++ parser through SWIG or ctypes. Please
see the C++ documentation for more on text parsing.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-rust----flatbuffers_guide_use_rust"><a class="header" href="#use-in-rust----flatbuffers_guide_use_rust">Use in Rust    {#flatbuffers_guide_use_rust}</a></h1>
<h2 id="before-you-get-started-11"><a class="header" href="#before-you-get-started-11">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in Rust, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide
to general FlatBuffers usage in all of the supported languages (including Rust).
This page is designed to cover the nuances of FlatBuffers usage, specific to
Rust.</p>
<h4 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h4>
<p>This page assumes you have written a FlatBuffers schema and compiled it
with the Schema Compiler. If you have not, please see
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler)
and [Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<p>Assuming you wrote a schema, say <code>mygame.fbs</code> (though the extension doesn't
matter), you've generated a Rust file called <code>mygame_generated.rs</code> using the
compiler (e.g. <code>flatc --rust mygame.fbs</code> or via helpers listed in &quot;Useful
tools created by others&quot; section bellow), you can now start using this in
your program by including the file. As noted, this header relies on the crate
<code>flatbuffers</code>, which should be in your include <code>Cargo.toml</code>.</p>
<h2 id="flatbuffers-rust-library-code-location"><a class="header" href="#flatbuffers-rust-library-code-location">FlatBuffers Rust library code location</a></h2>
<p>The code for the FlatBuffers Rust library can be found at
<code>flatbuffers/rust</code>. You can browse the library code on the
<a href="https://github.com/google/flatbuffers/tree/master/rust">FlatBuffers GitHub page</a>.</p>
<h2 id="testing-the-flatbuffers-rust-library"><a class="header" href="#testing-the-flatbuffers-rust-library">Testing the FlatBuffers Rust library</a></h2>
<p>The code to test the Rust library can be found at <code>flatbuffers/tests/rust_usage_test</code>.
The test code itself is located in
<a href="https://github.com/google/flatbuffers/blob/master/tests/rust_usage_test/tests/integration_test.rs">integration_test.rs</a></p>
<p>This test file requires <code>flatc</code> to be present. To review how to build the project,
please read the [Building](@ref flatbuffers_guide_building) documentation.</p>
<p>To run the tests, execute <code>RustTest.sh</code> from the <code>flatbuffers/tests</code> directory.
For example, on <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, you would simply
run: <code>cd tests &amp;&amp; ./RustTest.sh</code>.</p>
<p><em>Note: The shell script requires <a href="https://www.rust-lang.org">Rust</a> to
be installed.</em></p>
<h2 id="using-the-flatbuffers-rust-library"><a class="header" href="#using-the-flatbuffers-rust-library">Using the FlatBuffers Rust library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in Rust.</em></p>
<p>FlatBuffers supports both reading and writing FlatBuffers in Rust.</p>
<p>To use FlatBuffers in your code, first generate the Rust modules from your
schema with the <code>--rust</code> option to <code>flatc</code>. Then you can import both FlatBuffers
and the generated code to read or write FlatBuffers.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Rust:
First, include the library and generated code. Then read the file into
a <code>u8</code> vector, which you pass, as a byte slice, to <code>root_as_monster()</code>.</p>
<p>This full example program is available in the Rust test suite:
<a href="https://github.com/google/flatbuffers/blob/master/tests/rust_usage_test/bin/monster_example.rs">monster_example.rs</a></p>
<p>It can be run by <code>cd</code>ing to the <code>rust_usage_test</code> directory and executing: <code>cargo run monster_example</code>.</p>
<pre><code class="language-{.rs}">    extern crate flatbuffers;

    #[allow(dead_code, unused_imports)]
    #[path = &quot;../../monster_test_generated.rs&quot;]
    mod monster_test_generated;
    pub use monster_test_generated::my_game;

    use std::io::Read;

    fn main() {
        let mut f = std::fs::File::open(&quot;../monsterdata_test.mon&quot;).unwrap();
        let mut buf = Vec::new();
        f.read_to_end(&amp;mut buf).expect(&quot;file reading failed&quot;);

        let monster = my_game::example::root_as_monster(&amp;buf[..]);
</code></pre>
<p><code>monster</code> is of type <code>Monster</code>, and points to somewhere <em>inside</em> your
buffer (root object pointers are not the same as <code>buffer_pointer</code> !).
If you look in your generated header, you'll see it has
convenient accessors for all fields, e.g. <code>hp()</code>, <code>mana()</code>, etc:</p>
<pre><code class="language-{.rs}">        println!(&quot;{}&quot;, monster.hp());     // `80`
        println!(&quot;{}&quot;, monster.mana());   // default value of `150`
        println!(&quot;{:?}&quot;, monster.name()); // Some(&quot;MyMonster&quot;)
    }
</code></pre>
<p><em>Note: That we never stored a <code>mana</code> value, so it will return the default.</em></p>
<h2 id="direct-memory-access-1"><a class="header" href="#direct-memory-access-1">Direct memory access</a></h2>
<p>As you can see from the above examples, all elements in a buffer are
accessed through generated accessors. This is because everything is
stored in little endian format on all platforms (the accessor
performs a swap operation on big endian machines), and also because
the layout of things is generally not known to the user.</p>
<p>For structs, layout is deterministic and guaranteed to be the same
across platforms (scalars are aligned to their
own size, and structs themselves to their largest member), and you
are allowed to access this memory directly by using <code>safe_slice</code>
on the reference to a struct, or even an array of structs.</p>
<p>To compute offsets to sub-elements of a struct, make sure they
are structs themselves, as then you can use the pointers to
figure out the offset without having to hardcode it. This is
handy for use of arrays of structs with calls like <code>glVertexAttribPointer</code>
in OpenGL or similar APIs.</p>
<p>It is important to note is that structs are still little endian on all
machines, so the functions to enable tricks like this are only exposed on little
endian machines. If you also ship on big endian machines, using an
<code>#[cfg(target_endian = &quot;little&quot;)]</code> attribute would be wise or your code will not
compile.</p>
<p>The special function <code>safe_slice</code> is implemented on Vector objects that are
represented in memory the same way as they are represented on the wire. This
function is always available on vectors of struct, bool, u8, and i8. It is
conditionally-compiled on little-endian systems for all the remaining scalar
types.</p>
<p>The FlatBufferBuilder function <code>create_vector_direct</code> is implemented for all
types that are endian-safe to write with a <code>memcpy</code>. It is the write-equivalent
of <code>safe_slice</code>.</p>
<h2 id="access-of-untrusted-buffers-1"><a class="header" href="#access-of-untrusted-buffers-1">Access of untrusted buffers</a></h2>
<p>The safe Rust functions to interpret a slice as a table (<code>root</code>,
<code>size_prefixed_root</code>, <code>root_with_opts</code>, and <code>size_prefixed_root_with_opts</code>)
verify the data first. This has some performance cost, but is intended to be
safe for use on flatbuffers from untrusted sources. There are corresponding
<code>unsafe</code> versions with names ending in <code>_unchecked</code> which skip this
verification, and may access arbitrary memory.</p>
<p>The generated accessor functions access fields over offsets, which is
very quick. The current implementation uses these to access memory without any
further bounds checking. All of the safe Rust APIs ensure the verifier is run
over these flatbuffers before accessing them.</p>
<p>When you're processing large amounts of data from a source you know (e.g.
your own generated data on disk), the <code>_unchecked</code> versions are acceptable, but
when reading data from the network that can potentially have been modified by an
attacker, it is desirable to use the safe versions which use the verifier.</p>
<h2 id="threading-1"><a class="header" href="#threading-1">Threading</a></h2>
<p>Reading a FlatBuffer does not touch any memory outside the original buffer,
and is entirely read-only (all immutable), so is safe to access from multiple
threads even without synchronisation primitives.</p>
<p>Creating a FlatBuffer is not thread safe. All state related to building
a FlatBuffer is contained in a FlatBufferBuilder instance, and no memory
outside of it is touched. To make this thread safe, either do not
share instances of FlatBufferBuilder between threads (recommended), or
manually wrap it in synchronisation primitives. There's no automatic way to
accomplish this, by design, as we feel multithreaded construction
of a single buffer will be rare, and synchronisation overhead would be costly.</p>
<p>Unlike most other languages, in Rust these properties are exposed to and
enforced by the type system. <code>flatbuffers::Table</code> and the generated table types
are <code>Send + Sync</code>, indicating they may be freely shared across threads and data
may be accessed from any thread which receives a const (aka shared) reference.
There are no functions which require a mutable (aka exclusive) reference, which
means all the available functions may be called like this.
<code>flatbuffers::FlatBufferBuilder</code> is also <code>Send + Sync</code>, but all of the mutating
functions require a mutable (aka exclusive) reference which can only be created
when no other references to the <code>FlatBufferBuilder</code> exist, and may not be copied
within the same thread, let alone to a second thread.</p>
<h2 id="useful-tools-created-by-others"><a class="header" href="#useful-tools-created-by-others">Useful tools created by others</a></h2>
<ul>
<li><a href="https://github.com/frol/flatc-rust">flatc-rust</a> - FlatBuffers compiler
(flatc) as API for transparent <code>.fbs</code> to <code>.rs</code> code-generation via Cargo
build scripts integration.</li>
</ul>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-swift-flatbuffers_guide_use_swift"><a class="header" href="#use-in-swift-flatbuffers_guide_use_swift">Use in Swift {#flatbuffers_guide_use_swift}</a></h1>
<h2 id="before-you-get-started-12"><a class="header" href="#before-you-get-started-12">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in Swift, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide
to general FlatBuffers usage in all of the supported languages (including Swift).
This page is designed to cover the nuances of FlatBuffers usage, specific to
Swift.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-swift-library-code-location"><a class="header" href="#flatbuffers-swift-library-code-location">FlatBuffers Swift library code location</a></h2>
<p>The code for the FlatBuffers Swift library can be found at
<code>flatbuffers/swift</code>. You can browse the library code on the <a href="https://github.com/google/flatbuffers/tree/master/swift">FlatBuffers
GitHub page</a>.</p>
<h2 id="testing-the-flatbuffers-swift-library"><a class="header" href="#testing-the-flatbuffers-swift-library">Testing the FlatBuffers Swift library</a></h2>
<p>The code to test the Swift library can be found at <code>flatbuffers/tests/swift/tests</code>.
The test code itself is located in <a href="https://github.com/google/flatbuffers/blob/master/tests/swift/tests">flatbuffers/tests/swift/tests</a>.</p>
<p>To run the tests, use the <a href="https://github.com/google/flatbuffers/blob/master/tests/swift/tests/SwiftTest.sh">SwiftTest.sh</a> shell script.</p>
<p><em>Note: The shell script requires <a href="https://swift.org">Swift</a> to
be installed.</em></p>
<h2 id="using-the-flatbuffers-swift-library"><a class="header" href="#using-the-flatbuffers-swift-library">Using the FlatBuffers Swift library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in Swift.</em></p>
<p>FlatBuffers supports reading and writing binary FlatBuffers in Swift.</p>
<p>To use FlatBuffers in your own code, first generate Swift structs from your
schema with the <code>--swift</code> option to <code>flatc</code>. Then include FlatBuffers using <code>SPM</code> in
by adding the path to <code>FlatBuffers/swift</code> into it. The generated code should also be
added to xcode or the path of the package you will be using. Note: sometimes xcode cant
and wont see the generated files, so it's better that you copy them to xcode.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Swift: First,
include the library and copy thegenerated code. Then read a FlatBuffer binary file or
a data object from the server, which you can pass into the <code>GetRootAsMonster</code> function.</p>
<pre><code class="language-{.swift}">    import FlatBuffers

    typealias Monster1 = MyGame.Sample.Monster
    typealias Vec3 = MyGame.Sample.Vec3

    let path = FileManager.default.currentDirectoryPath
    let url = URL(fileURLWithPath: path, isDirectory: true).appendingPathComponent(&quot;monsterdata_test&quot;).appendingPathExtension(&quot;mon&quot;)
    guard let data = try? Data(contentsOf: url) else { return }

    let monster = Monster.getRootAsMonster(bb: ByteBuffer(data: data))
</code></pre>
<p>Now you can access values like this:</p>
<pre><code class="language-{.swift}">    let hp = monster.hp
    let pos = monster.pos // uses native swift structs
    let pos = monster.mutablePos // uses flatbuffers structs
</code></pre>
<p>In some cases it's necessary to modify values in an existing FlatBuffer in place (without creating a copy). For this reason, scalar fields of a Flatbuffer table or struct can be mutated.</p>
<pre><code class="language-{.swift}">    let monster = Monster.getRootAsMonster(bb: ByteBuffer(data: data))

    if !monster.mutate(hp: 10) {
      fatalError(&quot;couldn't mutate&quot;)
    }
    // mutate a struct field using flatbuffers struct
    // DONT use monster.pos to mutate since swift copy on write 
    // will not mutate the value in the buffer
    let vec = monster.mutablePos.mutate(z: 4)

    // This mutation will fail because the mana field is not available in
    // the buffer. It should be set when creating the buffer.
    if !monster.mutate(mana: 20) {
      fatalError(&quot;couldn't mutate&quot;)
    }
</code></pre>
<p>The term <code>mutate</code> is used instead of <code>set</code> to indicate that this is a special use case. All mutate functions return a boolean value which is false if the field we're trying to mutate is not available in the buffer.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-in-typescript----flatbuffers_guide_use_typescript"><a class="header" href="#use-in-typescript----flatbuffers_guide_use_typescript">Use in TypeScript    {#flatbuffers_guide_use_typescript}</a></h1>
<h2 id="before-you-get-started-13"><a class="header" href="#before-you-get-started-13">Before you get started</a></h2>
<p>Before diving into the FlatBuffers usage in TypeScript, it should be noted that
the [Tutorial](@ref flatbuffers_guide_tutorial) page has a complete guide to
general FlatBuffers usage in all of the supported languages
(including TypeScript). This page is specifically designed to cover the nuances
of FlatBuffers usage in TypeScript.</p>
<p>You should also have read the [Building](@ref flatbuffers_guide_building)
documentation to build <code>flatc</code> and should be familiar with
[Using the schema compiler](@ref flatbuffers_guide_using_schema_compiler) and
[Writing a schema](@ref flatbuffers_guide_writing_schema).</p>
<h2 id="flatbuffers-typescript-library-code-location"><a class="header" href="#flatbuffers-typescript-library-code-location">FlatBuffers TypeScript library code location</a></h2>
<p>The code for the FlatBuffers TypeScript library can be found at
https://www.npmjs.com/package/flatbuffers.</p>
<h2 id="testing-the-flatbuffers-typescript-library"><a class="header" href="#testing-the-flatbuffers-typescript-library">Testing the FlatBuffers TypeScript library</a></h2>
<p>To run the tests, use the [TypeScriptTest.py](https://github.com/google/
flatbuffers/blob/master/tests/TypeScriptTest.py) Python3 script.</p>
<p><em>Note: The TypeScript test file requires <a href="https://nodejs.org/en/">Node.js</a>.</em></p>
<h2 id="using-the-flatbuffers-typescript-library"><a class="header" href="#using-the-flatbuffers-typescript-library">Using the FlatBuffers TypeScript library</a></h2>
<p><em>Note: See [Tutorial](@ref flatbuffers_guide_tutorial) for a more in-depth
example of how to use FlatBuffers in TypeScript.</em></p>
<p>FlatBuffers supports both reading and writing FlatBuffers in TypeScript.</p>
<p>To use FlatBuffers in your own code, first generate TypeScript classes from your
schema with the <code>--ts</code> option to <code>flatc</code>. Then you can include both FlatBuffers
and the generated code to read or write a FlatBuffer.</p>
<p>For example, here is how you would read a FlatBuffer binary file in TypeScript:
First, include the library and generated code. Then read the file into an
<code>Uint8Array</code>. Make a <code>flatbuffers.ByteBuffer</code> out of the <code>Uint8Array</code>, and pass
the ByteBuffer to the <code>getRootAsMonster</code> function.</p>
<pre><code class="language-{.ts}">  import * as flatbuffers from 'flatbuffers';

  import { MyGame } from './monster_generated';

  let data = new Uint8Array(fs.readFileSync('monster.dat'));
  let buf = new flatbuffers.ByteBuffer(data);

  let monster = MyGame.Example.Monster.getRootAsMonster(buf);
</code></pre>
<p>Now you can access values like this:</p>
<pre><code class="language-{.ts}">  let hp = monster.hp();
  let pos = monster.pos();
</code></pre>
<h2 id="object-based-api-2"><a class="header" href="#object-based-api-2">Object based API</a></h2>
<p>FlatBuffers is all about memory efficiency, which is why its base API is written
around using as little as possible of it. This does make the API clumsier
(requiring pre-order construction of all data, and making mutation harder).</p>
<p>For times when efficiency is less important a more convenient object based API
can be used (through <code>--gen-object-api</code>) that is able to unpack &amp; pack a
FlatBuffer into objects and standard TS types.</p>
<p>To use:</p>
<pre><code class="language-{.ts}">    // Autogenerated class from table Monster.
    let monsterobj = new MonsterT();

    // Deserialize from buffer into object.
    Monster.getRootAsMonster(flatbuffer).unpackTo(monsterobj);
    // or
    let monsterobj = Monster.getRootAsMonster(flatbuffer).unpack();

    // Update object directly like a regular TS class instance.
    console.log(monsterobj.name);
    monsterobj.name = &quot;Bob&quot;;

    // Serialize into new flatbuffer.
    let fbb = new flatbuffers.Builder(1);
    Monster.finishMonsterBuffer(fbb, monsterobj.pack(fbb));
</code></pre>
<h2 id="text-parsing-flatbuffers-in-typescript"><a class="header" href="#text-parsing-flatbuffers-in-typescript">Text parsing FlatBuffers in TypeScript</a></h2>
<p>There currently is no support for parsing text (Schema's and JSON) directly
from TypeScript.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-with-cmake"><a class="header" href="#building-with-cmake">Building with CMake</a></h1>
<p>The distribution comes with a <code>cmake</code> file that should allow
you to build project/make files for any platform. For details on <code>cmake</code>, see
<a href="https://www.cmake.org">https://www.cmake.org</a>. In brief, depending on your platform, use one of
e.g.:</p>
<pre><code>cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release
cmake -G &quot;Visual Studio 10&quot; -DCMAKE_BUILD_TYPE=Release
cmake -G &quot;Xcode&quot; -DCMAKE_BUILD_TYPE=Release
</code></pre>
<p>Then, build as normal for your platform. This should result in a <code>flatc</code>
executable, essential for the next steps.
Note that to use clang instead of gcc, you may need to set up your environment
variables, e.g.
<code>CC=/usr/bin/clang CXX=/usr/bin/clang++ cmake -G &quot;Unix Makefiles&quot;</code>.</p>
<p>Optionally, run the <code>flattests</code> executable from the root <code>flatbuffers/</code>
directory to ensure everything is working correctly on your system. If this
fails, please contact us!</p>
<p>Building should also produce two sample executables, <code>flatsamplebinary</code> and
<code>flatsampletext</code>, see the corresponding <code>.cpp</code> files in the
<code>flatbuffers/samples</code> directory.</p>
<p><em>Note that you MUST be in the root of the FlatBuffers distribution when you
run 'flattests' or <code>flatsampletext</code>, or it will fail to load its files.</em></p>
<h3 id="make-all-warnings-into-errors"><a class="header" href="#make-all-warnings-into-errors">Make all warnings into errors</a></h3>
<p>By default all Flatbuffers <code>cmake</code> targets are <strong>not</strong> built with the <code>-Werror</code> 
(or <code>/WX</code> for MSVC) flag that treats any warning as an error. This allows more 
flexibility for users of Flatbuffers to use newer compilers and toolsets that
may add new warnings that would cause a build failure.</p>
<p>To enable a stricter build that does treat warnings as errors, set the
<code>FLATBUFFERS_STRICT_MODE</code> <code>cmake</code> compliation flag to <code>ON</code>. </p>
<pre><code>cmake . -DFLATBUFFERS_STRICT_MODE=ON
</code></pre>
<p>Our CI builds run with strict mode on, ensuring the code that is committed to 
the project is as portable and warning free as possible. Thus developers
contributing to the project should enable strict mode locally before making a 
PR.</p>
<h2 id="building-with-vcpkg"><a class="header" href="#building-with-vcpkg">Building with VCPKG</a></h2>
<p>You can download and install flatbuffers using the <a href="https://github.com/Microsoft/vcpkg/">vcpkg</a> dependency manager:</p>
<pre><code>git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.sh
./vcpkg integrate install
./vcpkg install flatbuffers
</code></pre>
<p>The flatbuffers port in vcpkg is kept up to date by Microsoft team members and community contributors.
If the version is out of date, please <a href="https://github.com/Microsoft/vcpkg">create an issue or pull request</a> on the vcpkg repository.</p>
<h2 id="downloading-binaries"><a class="header" href="#downloading-binaries">Downloading binaries</a></h2>
<p>You can download the binaries from the
<a href="https://github.com/google/flatbuffers/releases">GitHub release page</a>.</p>
<p>We generate <a href="slsa.dev">SLSA3 signatures</a> using the OpenSSF's <a href="https://github.com/slsa-framework/slsa-github-generator">slsa-framework/slsa-github-generator</a>. To verify the binaries:</p>
<ol>
<li>Install the verification tool from <a href="https://github.com/slsa-framework/slsa-verifier#installation">slsa-framework/slsa-verifier#installation</a></li>
<li>Download the file named <code>attestation.intoto.jsonl</code> from the GitHub release</li>
<li>Run:</li>
</ol>
<pre><code class="language-shell">$ slsa-verifier -artifact-path &lt;downloaded.zip&gt; -provenance attestation.intoto.jsonl -source github.com/google/flatbuffers -tag &lt;version&gt;
  PASSED: Verified SLSA provenance

## Building for Android

There is a `flatbuffers/android` directory that contains all you need to build
the test executable on android (use the included `build_apk.sh` script, or use
`ndk_build` / `adb` etc. as usual). Upon running, it will output to the log
if tests succeeded or not.

You may also run an android sample from inside the `flatbuffers/samples`, by
running the `android_sample.sh` script. Optionally, you may go to the
`flatbuffers/samples/android` folder and build the sample with the
`build_apk.sh` script or `ndk_build` / `adb` etc.

## Using FlatBuffers in your own projects

For C++, there is usually no runtime to compile, as the code consists of a
single header, `include/flatbuffers/flatbuffers.h`. You should add the
`include` folder to your include paths. If you wish to be
able to load schemas and/or parse text into binary buffers at runtime,
you additionally need the other headers in `include/flatbuffers`. You must
also compile/link `src/idl_parser.cpp` (and `src/idl_gen_text.cpp` if you
also want to be able convert binary to text).

To see how to include FlatBuffers in any of our supported languages, please
view the [Tutorial](@ref flatbuffers_guide_tutorial) and select your appropriate
language using the radio buttons.

### Using in CMake-based projects
If you want to use FlatBuffers in a project which already uses CMake, then a more
robust and flexible approach is to build FlatBuffers as part of that project directly.
This is done by making the FlatBuffers source code available to the main build
and adding it using CMake's `add_subdirectory()` command. This has the
significant advantage that the same compiler and linker settings are used
between FlatBuffers and the rest of your project, so issues associated with using
incompatible libraries (eg debug/release), etc. are avoided. This is
particularly useful on Windows.

Suppose you put FlatBuffers source code in directory `${FLATBUFFERS_SRC_DIR}`.
To build it as part of your project, add following code to your `CMakeLists.txt` file:
```cmake
# Add FlatBuffers directly to our build. This defines the `flatbuffers` target.
add_subdirectory(${FLATBUFFERS_SRC_DIR}
                 ${CMAKE_CURRENT_BINARY_DIR}/flatbuffers-build
                 EXCLUDE_FROM_ALL)

# Now simply link against flatbuffers as needed to your already declared target.
# The flatbuffers target carry header search path automatically if CMake &gt; 2.8.11.
target_link_libraries(own_project_target PRIVATE flatbuffers)
</code></pre>
<p>When build your project the <code>flatbuffers</code> library will be compiled and linked 
to a target as part of your project.</p>
<h4 id="override-default-depth-limit-of-nested-objects"><a class="header" href="#override-default-depth-limit-of-nested-objects">Override default depth limit of nested objects</a></h4>
<p>To override [the depth limit of recursion](@ref flatbuffers_guide_use_cpp), 
add this directive:</p>
<pre><code class="language-cmake">set(FLATBUFFERS_MAX_PARSING_DEPTH 16)
</code></pre>
<p>to <code>CMakeLists.txt</code> file before <code>add_subdirectory(${FLATBUFFERS_SRC_DIR})</code> line.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grammar-of-the-schema-language----flatbuffers_grammar"><a class="header" href="#grammar-of-the-schema-language----flatbuffers_grammar">Grammar of the schema language    {#flatbuffers_grammar}</a></h1>
<p>schema = include*
( namespace_decl | type_decl | enum_decl | root_decl |
file_extension_decl | file_identifier_decl |
attribute_decl | rpc_decl | object )*</p>
<p>include = <code>include</code> string_constant <code>;</code></p>
<p>namespace_decl = <code>namespace</code> ident ( <code>.</code> ident )* <code>;</code></p>
<p>attribute_decl = <code>attribute</code> ident | <code>&quot;</code> ident <code>&quot;</code> <code>;</code></p>
<p>type_decl = ( <code>table</code> | <code>struct</code> ) ident metadata <code>{</code> field_decl+ <code>}</code></p>
<p>enum_decl = ( <code>enum</code> ident <code>:</code> type | <code>union</code> ident )  metadata <code>{</code>
commasep( enumval_decl ) <code>}</code></p>
<p>root_decl = <code>root_type</code> ident <code>;</code></p>
<p>field_decl = ident <code>:</code> type [ <code>=</code> scalar ] metadata <code>;</code></p>
<p>rpc_decl = <code>rpc_service</code> ident <code>{</code> rpc_method+ <code>}</code></p>
<p>rpc_method = ident <code>(</code> ident <code>)</code> <code>:</code> ident metadata <code>;</code></p>
<p>type = <code>bool</code> | <code>byte</code> | <code>ubyte</code> | <code>short</code> | <code>ushort</code> | <code>int</code> | <code>uint</code> |
<code>float</code> | <code>long</code> | <code>ulong</code> | <code>double</code> |
<code>int8</code> | <code>uint8</code> | <code>int16</code> | <code>uint16</code> | <code>int32</code> | <code>uint32</code>| <code>int64</code> | <code>uint64</code> |
<code>float32</code> | <code>float64</code> |
<code>string</code> | <code>[</code> type <code>]</code> | ident</p>
<p>enumval_decl = ident [ <code>=</code> integer_constant ] metadata</p>
<p>metadata = [ <code>(</code> commasep( ident [ <code>:</code> single_value ] ) <code>)</code> ]</p>
<p>scalar = boolean_constant | integer_constant | float_constant</p>
<p>object = <code>{</code> commasep( ident <code>:</code> value ) <code>}</code></p>
<p>single_value = scalar | string_constant</p>
<p>value = single_value | object | <code>[</code> commasep( value ) <code>]</code></p>
<p>commasep(x) = [ x ( <code>,</code> x )* ]</p>
<p>file_extension_decl = <code>file_extension</code> string_constant <code>;</code></p>
<p>file_identifier_decl = <code>file_identifier</code> string_constant <code>;</code></p>
<p>string_constant = <code>\&quot;.*?\&quot;</code></p>
<p>ident = <code>[a-zA-Z_][a-zA-Z0-9_]*</code></p>
<p><code>[:digit:]</code> = <code>[0-9]</code></p>
<p><code>[:xdigit:]</code> = <code>[0-9a-fA-F]</code></p>
<p>dec_integer_constant = <code>[-+]?[:digit:]+</code></p>
<p>hex_integer_constant = <code>[-+]?0[xX][:xdigit:]+</code></p>
<p>integer_constant = dec_integer_constant | hex_integer_constant</p>
<p>dec_float_constant = <code>[-+]?(([.][:digit:]+)|([:digit:]+[.][:digit:]*)|([:digit:]+))([eE][-+]?[:digit:]+)?</code></p>
<p>hex_float_constant = <code>[-+]?0[xX](([.][:xdigit:]+)|([:xdigit:]+[.][:xdigit:]*)|([:xdigit:]+))([pP][-+]?[:digit:]+)</code></p>
<p>special_float_constant = <code>[-+]?(nan|inf|infinity)</code></p>
<p>float_constant = dec_float_constant | hex_float_constant | special_float_constant</p>
<p>boolean_constant = <code>true</code> | <code>false</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flatbuffers-intermediate-representation-intermediate_representation"><a class="header" href="#flatbuffers-intermediate-representation-intermediate_representation">Flatbuffers Intermediate Representation {#intermediate_representation}</a></h1>
<p>We use <a href="https://github.com/google/flatbuffers/blob/master/reflection/reflection.fbs">reflection.fbs</a>
as our intermediate representation. <code>flatc</code> parses <code>.fbs</code> files, checks them for
errors and stores the resulting data in this IR, outputting <code>.bfbs</code> files.
Since this IR is a Flatbuffer, you can load and use it at runtime for runtime
reflection purposes.</p>
<p>There are some quirks: </p>
<ul>
<li>Tables and Structs are serialized as <code>Object</code>s.</li>
<li>Unions and Enums are serialized as <code>Enum</code>s.</li>
<li>It is the responsibility of the code generator to check the <code>advanced_features</code>
field of <code>Schema</code>. These mark the presence of new, backwards incompatible,
schema features. Code generators must error if generating a schema with
unrecognized advanced features.</li>
<li>Filenames are relative to a &quot;project root&quot; denoted by &quot;//&quot; in the path. This
may be specified in flatc with <code>--bfbs-filenames=$PROJECT_ROOT</code>, or it will be
inferred to be the directory containing the first provided schema file.</li>
</ul>
<h2 id="invocation"><a class="header" href="#invocation">Invocation</a></h2>
<p>You can invoke it like so</p>
<pre><code class="language-{.sh}">flatc -b --schema ${your_fbs_files}
</code></pre>
<p>This generates <code>.bfbs</code> (binary flatbuffer schema) files.</p>
<p>Some information is not included by default. See the <code>--bfbs-filenames</code> and
<code>--bfbs-comments</code> flags. These may be necessary for code-generators, so they can
add documentation and maybe name generated files (depending on the generator).</p>
<p>TODO(cneo): Flags to output bfbs as flexbuffers or json.</p>
<p>TODO(cneo): Tutorial for building a flatc plugin.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
